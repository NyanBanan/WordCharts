гда необходимо, чтобы сообщение было более конкретным.
• Производительность. Для небольшой функции стоимость проверки может
перевесить стоимость вычисления самого результата. Например, в случае
с функцией area () проверка вдвое увеличивает ее размер (т.е. удваивает ко-
личество машинных инструкций, которые необходимо выполнить, а не про-
сто длину исходного кода). В некоторых программах этот факт может ока-
заться критически важным, особенно если одна и та же информация проверя-
ется постоянно, когда функции вызывают друг друга, передавая информацию
более или менее без искажений.
\Г7[ Итак, что делать? Проверять аргументы в функции, если у вас нет веских при-
'—^ чин поступать иначе.
После обсуждения некоторых тем, связанных с этим вопросом, мы вернемся
к нему в разделе 5.9.
5.5.3. Сообщения об ошибках
Рассмотрим немного иной вопрос: что делать, если вы проверили набор аргу-
ментов и обнаружили ошибку? Иногда можно вернуть сообщение "Неправильное
значение". Рассмотрим пример.
// Попросим пользователя ввести да или нет;
// Символ 'Ь' означает неверный ответ (т.е. ни да ни нет)
char ask_user(string question)
{
cout << question « "? (да или нет)\пп;
string answer = n n;
сin >> answer;
if (answer =="7" || answer== "yes") return 'y';
if (answer =="nn jj answer=="no") return *n';
return 'b*; // 'b', если "ответ неверный"174 ГЛАВА 5 • ОШИБКИ
// Вычисляет площадь прямоугольника;
// возвращает -1, если аргумент неправильный
int area(int length, int width)
if (length<=0 |J width <=0) return -1;
return length*width;
}
На этот раз мы можем поручить детальную проверку вызывающей функции, ос-
тавив каждой вызывающей функции возможность обрабатывать ошибки по-своему.
Этот подход кажется разумным, но существует множество проблем, которые во
многих ситуациях делают его бесполезным.
• Теперь проверку должны осуществлять и вызываемая функция, и все вызы-
вающие функции. Вызывающая функция должна провести лишь самую про-
стую проверку, но остается вопрос, как написать этот код и что делать, если
обнаружится ошибка.
• Программист может забыть проверить аргументы в вызывающей функции,
что приведет к непредсказуемым последствиям.
• Многие функции не имеют возможность возвращать дополнительные значе-
ния, чтобы сообщить об ошибке. Например, функция, считывающая целое
число из потока ввода (скажем, оператор >> потока с in), может возвращать
любое целое число, поэтому использовать целое число в качестве индикатора
ошибки бессмысленно.
Вторая ситуация, в которой проверка в вызывающем модуле не выполняется,
может легко привести к неожиданностям
Рассмотрим пример,
int f(int x, int y, int z)
{
int areal = area(x/y);
if (areal<=0) error("Неположительная площадь");
int area2 = framed_area(l,z) ;
int агеаЗ = framed_area(y,z);
double ratio = double(areal)/агеаЗ;
// . . .
}
Вы заметили ошибку? Такие ошибки трудно выявить, так как сам код является
правильным: ошибка заключается в том, что программист не включил в него про-
верку.
* ПОПРОБУЙТЕ
Выполните эту программу при разных значениях. Выведите на печать значения пе-
ременных areal, area2, агеаЗ и ratio. Вставьте в программу больше проверок
разных ошибок. Вы уверены, что перехватите все ошибки? Это вопрос без подвоха;
в данном конкретном примере можно ввести правильный аргумент и перехватить
все возможные ошибки.5 6. ИСКЛЮЧЕНИЯ
175
Существует другой способ решить описанную проблему: использовать исключе-
ния (exceptions)
5.6. Исключения
Как и в большинстве языков программирования, в языке C++ существует меха-
низм обработки ошибок: исключения. Основная идея этого понятия заключается
в отделении выявления ошибки (это можно сделать в вызываемой функции) от ее
обработки (это можно сделать в вызывающей функции), чтобы гарантировать, что
ни одна выявленная ошибка не останется необработанной. Иначе говоря, исключе-
ния создают механизм, позволяющий сочетать наилучшие подходы к обработке
ошибок, исследованные нами до сих пор. Какой бы легкой ни была обработка оши-
бок, исключения сделают ее еще легче.
Основная идея заключается в следующем: если функция обнаруживает ошибку,
которую не может обработать, она не выполняет оператор return как обычно,
а генерирует исключение с помощью оператора throw, показывая, что произошло
нечто неправильное.
Любая функция, прямо или косвенно вызывающая данную функцию, может пе-
рехватить созданное исключение с помощью оператора catch, т.е. указать, что сле-
дует делать, если вызываемый код использовал оператор throw. Функция расстав-
ляет ловушки для исключения с помощью блока try (мы опишем его в следующих
разделах), перечисляя виды исключений, которые она хочет обработать в своих раз-
делах catch блока try. Если ни одна из вызывающих функций не перехватила ис-
ключение, то программа прекращает работу.
Мы еще вернемся к исключениям позже (в главе 19), чтобы использовать их
немного более сложным способом.
5.6.1. Неправильные аргументы
Рассмотрим вариант функции area (), использующий исключения.
class Bad_area { }; // Тип, созданный специально для сообщений
// об ошибках,
// возникших в функции area()
// Вычисляет площадь прямоугольника;
// при неправильном аргументе генерирует исключение Bad_area
int area(int length, int width)
{
if (length<=0 || width <=0) throw BadareaO;
return length*width;
Иначе говоря, если аргументы правильные, то программа всегда возвращает
площадь прямоугольника, а если нет, то выходим из функции area О с помощью
оператора throw, надеясь найти ответ в одном из разделов catch. Badarea—
ЭТО НОВЫЙ ТИП, ПреДНаЗНаЧеННЫЙ Исключительно для генерирования исключений176
ГЛАВА 5 • ОШИБКИ
в функции area (), так, чтобы один из разделов catch распознал его как исключе-
ние, сгенерированное функцией area О. Типы, определенные пользователями
(классы и перечисления), обсуждаются в главе 9. Обозначение Bad_area () означа-
ет "Создать объект типа Bad_area", а выражение throw BadareaO означает
"Создать объект типа Bad_area и передать его (throw) дальше".
Теперь функцию можно написать так:
int main О
try {
int x ■ -1;
int у - 2;
int z = 4;
// . . .
int areal = area(x,y);
int area2 = framed_area(l,z);
int агеаЗ = framed_area(y,z);
double ratio = areal/агеаЗ;
}
catch (Bad_area) {
cout << пОй1 Неправильный аргумент функции area()\n";
}
Во-первых, этот фрагмент программы обрабатывает все вызовы функции area О
как вызов из модуля main О, так и два вызова из функции f ramed_area (). Во-вто-
рых, обработка ошибки четко отделена от ее выявления: функция main () ничего не
знает о том, какая функция вьшолнила инструкцию throw Bad_area (), а функция
area () ничего не знает о том, какая функция (если такая существует) должна пере-
хватывать исключения Bad_area, которые она генерирует. Это разделение особенно
важно в крупных программах, написанных с помощью многочисленных библиотек.
В таких программах ни один человек не может обработать ошибку, просто поместив
некоторый код в нужное место, поскольку никто не может модифицировать код одно-
временно в приложении и во всех библиотеках.
5.6.2. Ошибки, связанные с диапазоном
Большинство реальных программ работает с наборами данных. Иначе говоря,
они используют разнообразные таблицы, списки и другие структуры данных. В кон-
тексте языка C++ наборы данных часто называют контейнерами (containers). Наи-
более часто используемым контейнером стандартной библиотеки является тип vec-
tor, введенный в разделе 4.6.
Объект типа vector хранит определенное количество элементов, которое можно
узнать с помощью его функции-члена size О. Что произойдет, если мы попытаемся
использовать элемент с индексом, не принадлежащим допустимому диапазону
[0:v.size())? Обычное обозначение [low:high) означает, что индексы могут
принимать значения от low до high-1, т.е. включая нижнюю границу, но исключая
верхнюю.5 6. ИСКЛЮЧЕНИЯ
177
low: high :
I i I i i i г i
Прежде чем ответить на этот вопрос, необходимо ответить на другой: "Как это
может быть?" Помимо всего прочего, известно, что индекс вектора v должен лежать
в диапазоне [0:v.size()), поэтому достаточно просто убедиться в этом!
Легко сказать, но трудно сделать. Рассмотрим следующую вполне разумную
программу:
vector<int> v; // вектор целых чисел
int i;
while (cin>>i) v.push_back(i) ; // вводим значения в контейнер
for (int i = 0; i<=v.size(); ++i) // печатаем значения
cout << "vl" << i <<H] == H << v[i] << endl;
Видите ошибку? Попытайтесь найти ее, прежде чем двигаться дальше. Эта до-
вольно типичная ошибка. Мы часто ее делаем, особенно если программируем позд-
но ночью, когда устали. Ошибки, как правило, являются результатом спешки или
усталости.
Мы использовали 0 и size(), чтобы попытаться гарантировать, что индекс i
всегда будет находиться в допустимом диапазоне, когда мы обратимся к элементу
v[i]. К сожалению, мы сделали ошибку. Посмотрите на цикл for: условие его за-
вершения сформулировано как i<=v.size(), в то время как правильно было бы
написать i<v.size (). В результате, прочитав пять чисел, мы попытаемся вывести
шесть. Мы попытаемся обратиться к элементу v[5], индекс которого ссылается за
пределы вектора. Эта разновидность ошибок настолько широко известна, что даже
получила несколько названий: ошибка занижения или завышения на единицу (off-
by-obe error), ошибка диапазона (range error), так как индекс не принадлежит допус-
тимому диапазону вектора, и ошибка пределов (bounds error), поскольку индекс вы-
ходит за пределы вектора.
Эту ошибку можно спровоцировать намного проще.
vector<int> v(5);
int x = v[5] ;
Однако мы сомневаемся, что вы признаете такой пример реалистичным и заслу-
живающим внимания. Итак, что же произойдет на самом деле, если мы сделаем
ошибку диапазона? Операция доступа по индексу в классе vector знает размер
вектора, поэтому может проверить его (и действительно, делает это; см. разделы 4.6
и 19.4). Если проверка заканчивается неудачей, то операция доступа по индексу ге-
нерирует исключение типа out_of range. Итак, если бы ошибочный код, приве-
денный выше, являлся частью какой-то программы, перехватывающей исключения,
то мы получили бы соответствующее сообщение об ошибке.
int main О
try {178
ГЛАВА 5 • ОШИБКИ
int x;
while (cin»x) v.push_back(x); // записываем значения
for (int i в 0; i<ev.size(); ++i) // выводим значения
cout « nv[n « i «"l ■■ и « v[i] << endl;
} catch (out_of_range) {
cerr « "Ой! Ошибка диапазонаХп";
return 1;
} catch (...){ // перехват всех других исключений
cerr « "Исключение: что-то не так\пп;
return 2;
}
Обратите внимание на то, что ошибка диапазона на самом деле является част-
ным случаем ошибки, связанной с аргументами, которую мы обсудили в разде-
ле 5.5.2. Не доверяя себе, мы поручили проверку диапазона индексов вектора самой
операции доступа по индексу. По очевидным причинам оператор доступа по индек-
су (vector::operator []) сообщает об ошибке, генерируя исключение. Что еще
может произойти? Оператор доступа по индексу не имеет представления о том, что
бы мы хотели в этой ситуации делать. Автор класса vector даже не знает, частью
какой программы может стать его код.
5.6.3. Неправильный ввод
Обсуждение действий, которые следует предпринять при неправильном вводе
данных, мы отложим до раздела 10.6. Пока лишь отметим, что при обнаружении
ошибки ввода используются те же самые методы и механизмы языка программиро-
вания, что и при обработке ошибок, связанных с неправильными аргументами
и выходом за пределы допустимого диапазона. Здесь мы лишь покажем, как посту-
пать, если операции ввода достигли цели.
Рассмотрим фрагмент кода, в котором вводится число с плавающей точкой.
double d = 0;
cin » d;
Мы можем проверить, успешной ли оказалась последняя операция, подвергнув
проверке поток cin.
if (cin) {
// все хорошо, и мы можем считывать данные дальше
>
else {
// последнее считывание не было выполнено,
// поэтому следует что-то сделать
}
Существует несколько возможных причин сбоя при вводе данных. Одна из
них — тип данных, которые мы пытаемся считать, — отличается от типа double.
На ранних стадиях разработки мы часто хотим просто сообщить, что нашли ошибку
и прекратить выполнение программы, потому что еще не знаем, как на нее реагиро-5 6 ИСКЛЮЧЕНИЯ
179
вать. Иногда мы впоследствии возвращаемся к этому фрагменту и уточняем свои
действия Рассмотрим пример.
double some_function()
{
double d = 0;
cin >> d;
if (Join)
error ("невозможно считать число double в 'some_function () ' n);
// делаем что-то полезное
}
Строку, переданную функции error (), можно вывести на печать для облегчения
отладки или для передачи сообщения пользователю. Как написать функцию
error О так, чтобы она оказалась полезной для многих программ? Она не может
возвращать никакого значения, потому что неизвестно, что с ним делать дальше.
Вместо этого лучше, чтобы функция error () прекращала выполнение программы
после получения сообщения об ошибке. Кроме того, перед выходом иногда следует
выполнить определенные несложные действия, например, оставить окно с сообще-
нием активным достаточно долго, чтобы пользователь мог прочесть сообщение.
Все это вполне естественно для исключений (подробнее об этом — в разделе 7.3).
В стандартной библиотеке определено несколько исключений, таких как
out_of_range, генерируемых классом vector. Кроме того, в этой библиотеке есть
исключение runtime_error, идеально подходящее для наших нужд, поскольку
в ней хранится строка, которую может использовать обработчик ошибки.
Итак, нашу простую функцию error () можно переписать следующим образом:
void error(string s)
{
throw runtime error(s);
}
Когда нам потребуется поработать с исключением runtime_error, мы просто
перехватим его. Для простых программ перехват исключения runtime_error
в функции main () является идеальным.
int main ()
try {
// наша программа
return 0; // 0 означает успех
}
catch (runtime_error& e) {
cerr << "runtime error: п << e.what О « '\n';
Jceep_window_open ();
return 1; // 1 означает сбой
}
Вызов е.what () извлекает сообщение об ошибке из исключения runtime_error.
Символ & в выражении180
ГЛАВА 5 • ОШИБКИ
означает, что мы хотим передать исключение по ссылке. Пожалуйста, пока рассмат-
ривайте это выражение просто как техническую подробность. В разделах 8.5.4-8.56
мы объясним, что означает передача сущности по ссылке.
Обратите внимание на то, что для выдачи сообщений об ошибках мы использо-
вали поток сегг. Этот поток очень похож на поток cout за исключением того, что
он предназначен для вывода сообщений об ошибках. По умолчанию потоки сегг
и cout выводят данные на экран, но поток сегг не оптимизирован, поэтому более
устойчив к ошибкам и в некоторых операционных системах может быть перена-
правлен на другую цель, например на файл. Используя поток сегг, можно докумен-
тировать ошибки. Именно поэтому для вывода ошибок мы используем поток сегг.
Исключение out_of_range отличается от исключения runtime_error, поэтому пе-
рехват исключения runtime_error не приводит к обработке ошибок out_of_range,
которые могут возникнуть при неправильном использовании класса vector или других
контейнерных типов из стандартной библиотеки. Однако и out_of_range, и run-
time_error являются исключениями, поэтому для работы с ними необходимо преду-
смотреть перехват объекта класса exception.
int main()
try {
// наша программа
return 0; // 0 означает успех
}
catch (exceptions e) {
сегг << "error: " << e.whatO << '\n';
keep_window_open();
return 1; // 1 означает сбой
}
catch (...) {
сегг << "Ой: неизвестное исключение!\пн;
keep_window_open();
return 2; // 2 означает сбой
}
Здесь, для того чтобы перехватить все исключения, мы добавили инструкцию
catch(...).
Когда исключения обоих типов (outofrange и runtime_error) рассматри-
ваются как разновидности одного и того же типа exception, говорят, что тип
exception является базовым типом (супертипом) для них обоих. Этот исключи-
тельно полезный и мощный механизм будет описан в главах 13-16.
Снова обращаем ваше внимание на то, что значение, возвращаемое функцией
main (), передается системе, вызвавшей программу. Некоторые системы (такие как
Unix) часто используют это значения, а другие (такие как Windows), как правило,
игнорируют их. Нуль означает, что программа завершилась успешно, а ненулевое
значение, возвращенное функцией main (), означает какой-то сбои5 6 ИСКЛЮЧЕНИЯ
181
При использовании функции error () для описания возникшей проблемы часто
необходимо передать две порции информации. В данном случае эти две порции
просто объединяются в одну строку. Этот прием настолько широко распространен,
что мы решили представить его в виде второго варианта функции error ().
void error(string si, string s2)
{
throw runtime_error(sl+s2) ;
}
Этой простой обработки ошибки нам будет достаточно, пока ситуация не услож-
нится и потребуется придумать более изощренный способ исправить ситуацию.
Обратите внимание на то, что использование функции error () не зависит от
количества ее предыдущих вызовов: функция error () всегда находит ближайший
раздел catch, предусмотренный для перехвата исключения runtime_error (обыч-
но один из них размещается в функции main О). Примеры использования исключе-
ний и функции error () приведены в разделах 7.3. и 7.7. Если исключение осталось
неперехваченным, то система выдаст сообщение об ошибке (неперехваченное
исключение).
* ПОПРОБУЙТЕ
Для того чтобы увидеть неперехваченное исключение, запустите небольшую про-
грамму, в которой функция error () не перехватывает никаких исключений.
5.6.4. Суживающие преобразования
В разделе 3.9.2 продемонстрирована ужасная ошибка: когда мы присвоили пере-
менной слишком большое значение, оно было просто усечено. Рассмотрим пример.
int х а 2.9;
char с * 1066;
Здесь х будет равно 2, а не 2.9, поскольку переменная х имеет тип int, а та-
кие числа не могут иметь дробных частей. Аналогично, если используется
обычный набор символов ASCII, то переменная с будет равна 42 (что соответствует
символу *), а не 1066, поскольку переменные типа char не могут принимать такие
большие значения.
В разделе 3.9.2 показано, как защититься от такого сужения путем проверки.
С помощью исключений (и шаблонов; см. раздел 19.3) можно написать функцию,
проверяющую и генерирующую исключение runtimeexception, если присваива-
ние или инициализация может привести к изменению значения. Рассмотрим пример.
int xl = narrow_cast<int>(2.9); // генерирует исключение
int х2 = narrow_cast<int>(2.0); // OK
char cl ж narrow_cast<char>(1066); // генерирует исключение
char c2 = narrow cast<char>(85); // OK
Ш182
ГЛАВА 5 • ОШИБКИ
Угловые скобки, <*..>, означают то же самое, что и в выражении vector<int>.
Они используются, когда для выражения идеи возникает необходимость указать
тип, а не значение. Аргументы, стоящие в угловых скобках, называют шаблонными
(template arguments). Если необходимо преобразовать значение и мы не уверены, что
оно поместится, то можно использовать тип narrow_cast, определенный в заголо-
вочном файле std_lib_facilities.h и реализованный с помощью функции
error (). Слово cast (буквально гипсовая повязка. — Примеч. ред.) означает приве-
дение типа и отражает роль этой операции в ситуации, когда что-то "сломалось"
(по аналогии с гипсовой повязкой на сломанной ноге). Обратите внимание на то,
что приведение типа не изменяет операнд, а создает новое значение, имеющее тип,
требуемый операндом.
5.7. Логические ошибки
После устранения ошибок, выявленных компилятором и редактором связей, про-
грамму выполняют. Как правило, после этого программа либо ничего не выдает на
печать, либо выводит неправильные результаты. Это может происходить по многим
причинам. Возможно, вы просто неправильно поняли логику программы; написали
не то, что намеревались; сделали глупую ошибку в какой-нибудь инструкции или
что-нибудь еще. Логические ошибки обычно труднее всего находить и исправлять,
поскольку на этой стадии компьютер делает только то, что вы сами ему приказали.
Теперь ваша задача выяснить, почему он делает не то, что вы хотели. В принципе
компьютер— это очень быстро действующий идиот. Он просто покорно делает
в точности то, что вы ему сказали.
Попробуем проиллюстрировать сказанное на простом примере. Рассмотрим про-
грамму-код для поиска минимальной, максимальной и средней температуры.
int main ()
{
vector<double> temps; // температуры
double temp =0;
double sum > 0;
double hightemp = 0;
double lowtemp =0;
while (cin>>temp) // считываем и записываем в вектор temps
temps.pushback(temp);
for (int i = 0; i<temps.size(); ++i)
{
if(temps[i] > high_temp) high_temp = temps [i]; // находим
// максимум
if(temps[i] < low_temp) low_temp = temps [i]; // находим
// минимум
sum += temps[i]; // вычисляем сумму
>
cout << "Максимальная температура: " << high temp<< endl;5.7 ЛОГИЧЕСКИЕ ОШИБКИ
183
cout << "Минимальная температура: " « low_temp « endl;
cout << "Средняя температура:" << sum/ temps, size О « endl;
}
Мы проверили эту программу, введя почасовые данные о температуре в центре
Люббока, штат Техас (Lubbock, Texas) 16 февраля 2005 года (в штате Техас по-
прежнему используется шкала Фаренгейта).
-16.5# -23.2, -24.0# -25.7# -26.1# -18.6, -9.7, -2.4,
7.5, 12.6, 23.8, 25.3, 28.0, 34.8, 36.7, 41.5,
40.3, 42.6, 39.7, 35.4, 12.6, 6.5, -3.7, -14.3
Результаты оказались следующими:
Максимальная температура: 42.6
Минимальная температура: -26.1
Средняя температура: 9.3
Наивный программист может прийти к выводу, что программа работает просто
отлично. Безответственный программист продаст ее заказчику. Благоразумный про-
граммист проверит программу еще раз. Для этого мы ввели данные, полученные
23 июля 2005 года.
76.5, 73.5, 71.0, 73.6, 70.1, 73.5, 77.6, 85.3,
88.5, 91.7, 95.9, 99.2, 98.2, 100.6, 106.3, 112.4,
110.2, 103.6, 94.9, 91.7, 88.4, 85.2, 85.4, 87.7
На этот раз результаты таковы:
Максимальная температура: 112.4
Минимальная температура: 0.0
Средняя температура: 89.2
Ой, что-то не так. Крепкий мороз (0,0°F соответствует примерно 18°С) в Люббо-
ке в июле — это же просто конец света! Вы видите ошибку? Поскольку переменная
low_temp была инициализирована значением о. о, она останется равной нулю, если
все значения температуры окажутся отрицательными.
* ПОПРОБУЙТЕ
Выполните эту программу. Убедитесь, что она действительно выдает такие резуль-
таты. Попробуйте ее "сломать" (т.е. вынудить выдать неправильные результаты),
введя другой набор данных. Сколько данных вам для этого может потребоваться?
К сожалению, в этой программе ошибок намного больше. Что произойдет, если
все значения температуры окажутся отрицательными? Инициализация переменной
high_temp создает аналогичную проблему: она останется равной нулю, если в ис-
ходных данных все значения температуры окажутся больше нуля.
Такие ошибки типичны; они не создают никаких проблем при компиляции и не
приводят к неправильным ответам при разумных условиях. Однако мы забыли ука-104
— —.iliinfl
зать, что означают разумные условия. Вот как должна выглядеть исправленная
программа.
int main ()
{
double temp > 0;
double sum » 0;
double high_temp - -1000; // инициализация невозможно низким
// значением
double low_temp = 1000; // инициализация невозможно высоким
// значением
int no_of_temps =0;
while (cin»temp) { // считываем температуру
++no_of_temps; // подсчитываем количество данных
sum += temp; // вычисляем сумму
if (temp > high_temp) high_temp = temp; // находим максимум
if (temp < low_temp) low_temp = temp; // находим минимум
}
cout << "Максимальная температура: N << high_temp« endl;
cout << "Минимальная температура: " << lowtemp << endl;
cout << "Средняя температура:" << sum/temps.size() << endl;
}
Эта программа работает? Почему вы уверены в этом? Вы сможете дать точное оп-
ределение слова "работает"? Откуда взялись числа 1000 и -1000. Помните
о "магических" константах (см. раздел 5.5.1). Указывать числа 1000 и 1000 как лите-
ральные константы в тексте программы — плохой стиль, но может быть, и эти числа
неверны? Существуют ли места, где температура опускается ниже —1000°F (-573°C)?
Существуют ли места, где температура поднимается выше 1000°F (538°C)?
* ПОПРОБУЙТЕ
Просмотрите программу. Используя достоверные источники информации, введите
разумные значения для констант mintemp (минимальная температура) и maxtemp
(максимальная температура). Эти значения определят пределы применимости ва-
шей программы.
5.8. Оценка
Представьте себе, что вы написали простую программу, например, вычисляю-
щую площадь шестиугольника. Вы запустили ее и получили, что площадь равна -
34.56. Очевидно, что ответ неверен. Почему? поскольку ни одна фигура не может
иметь отрицательную площадь. Итак, вы исправляете ошибку и получаете ответ
21.65685. Этот результат правильный? Ответить на этот вопрос труднее, потому
что мы обычно не помним формулу для вычисления площади шестиугольников.
Итак, чтобы не опозориться перед пользователями и не поставить им программу,
выдающую глупые результаты, необходимо проверить, что ответ правильный5 8 ОЦЕНКА
185
В данном случае это просто. Шестиугольник похож на квадрат. Набросав на бумаге
рисунок, легко убедиться, что площадь шестиугольника близка к площади квадрата
3x3 Площадь этого квадрата равна 9. Итак, ответ 21,65685 не может быть правиль-
ным! Переделаем программу и получим ответ 9,65685. Это уже похоже на правду!
В данном случае мы ничего не делали с шестиугольниками. Дело в том, что
даже имея представление о правильном ответе, даже таком довольно точном,
мы не имеем права считать результат приемлемым. Всегда следует ответить на сле-
дующие вопросы.
1. Является ли данный ответ разумным для данной задачи?
Можно даже задать более общий (и более трудный) вопрос.
2. Как распознать разумный результат?
Обратите внимание на то, что мы не спрашиваем: "Каков точный ответ?" или
"Каков правильный ответ?" Этот ответ нам даст сама программа. Нам лишь хочет-
ся, чтобы ответ не был глупым. Только в том случае, если ответ является разумным,
имеет смысл продолжать работать над программой.
Оценка— это замечательное искусство, сочетающее в себе здравый смысл
и очень простую арифметику. Некоторые люди легко выполняют оценку умозри-
тельно, но мы предпочитаем "рисовать каракули на обратной стороне конверта",
поскольку в противном случае легко сделать ошибку. Итак, здесь мы называем
оценкой неформальный набор приемом, или прикидкой (guesstimation), сочетающей
в себе интуитивную догадку и примерную оценку.
Я ПОПРОБУЙТЕ
Длины сторон нашего правильного шестиугольника равны 2 см. Получили ли мы
правильный ответ? Просто выполните прикидочные вычисления. Возьмите лист
бумаги и набросайте эскиз. Не считайте это занятием ниже своего достоинства.
Многие знаменитые ученые восхищали людей своими способностями получать
примерный ответ с помощью карандаша и клочка бумаги (или салфетки). Эта спо-
собность — на самом деле простая привычка — поможет сэкономить массу време-
ни и избежать ошибок.
Часто оценка связана с предварительным анализом данных, необходимых для
вычисления, но не имеющихся в наличии. Представьте, что вы протестировали про-
грамму, оценивающую время путешествия из одного города в другой. Правдопо-
добно ли, что из Нью-Йорка в Денвер можно доехать на автомобиле за 15 часов
33 минуты? А из Лондона в Ниццу? Почему да и почему нет? На каких данных ос-
нована ваша догадка об ответах на эти вопросы? Часто на помощь приходит быст-
рый поиск в веб. Например, 2000 миль — это вполне правдоподобная оценка рас-
стояния между Нью-Йорком и Денвером. По этой причине было бы трудно (да и не-
законно) поддерживать среднюю скорость, равную 130 миль/ч, чтобы добраться из
0186
ГЛАВА 5 • ОШИБКИ
Нью-Йорка в Денвер за 15 часов (15*130 ненамного меньше 2000). Можете прове-
рить сами: мы переоценили и расстояние, и среднюю скорость, но наша оценка
правдоподобности ответа вполне обоснована.
* ПОПРОБУЙТЕ
Оцените указанное время путешествия на автомобиле, а также время перелета меж-
ду соответствующими городами (на обычных коммерческих авиарейсах). Теперь
попытайте проверить ваши оценки, используя информационные источники, напри-
мер карты и расписания.
5.9. Отладка
Написанная (вчерне?) программа всегда содержит ошибки. Небольшие програм-
мы случайно компилируются и выполняются правильно при первой же попытке.
Но если это происходит с любой не тривиальной программой, то это очень и очень
подозрительно. Если программа правильно выполнилась с первой попытки, идите
к друзьям и празднуйте, поскольку это происходит не каждый год.
Итак, написав определенную программу, вы должны найти и удалить ошибки.
Этот процесс обычно называют отладкой (debugging), а ошибки — жучками (bugs).
Иногда говорят, что термин жучок возник в те времена, когда аппаратное обеспече-
ние выходило из строя из-за насекомых, случайно заблудившихся среди электрон-
ных ламп и реле, заполнявших комнаты. Иногда считают, что этот термин изобрел
Грейс Мюррей Хоппер (Grace Murray Hopper), создатель языка программирования
COBOL (см. раздел 22.2.2.2). Кто бы ни придумал этот термин пятьдесят лет назад,
ошибки в программах неизбежны и повсеместны. Их поиск и устранение называют
отладкой (debugging).
Отладка выглядит примерно так.
1. Компилируем программу.
2. Редактируем связи.
3. Выполняем программу.
Обычно эта последовательность операций выполняется снова и снова: для дей-
ствительно крупных программ этот процесс повторяется сотни и тысячи раз год за
годом. Каждый раз что-то работает не так, как ожидалось, и приходится исправлять
какую-то ошибку. Я считаю отладку наиболее утомительной и затратной по време-
ни частью программирования и потратил много времени на то, чтобы минимизиро-
вать количество времени, затрачиваемого на отладку. Другие считают, что отлад-
ка — это захватывающее занятие, суть программирования, которое затягивает, как
видеоигры, и удерживает программиста у экрана дисплея многие дни и ночи (я могу
засвидетельствовать это по собственному опыту).5 9 ОТЛАДКА
187
Приведем пример, как не надо проводить отладку.
while (программа не будет выглядеть работоспособной) { // псевдокод
Бегло просматриваем программу в поисках странностей
Изменяем их так, чтобы программа выглядела лучше
}
Почему мы так беспокоимся об этом? Описанный выше плохой алгоритм отлад-
ки слабо гарантирует успех. К сожалению, это описание — не совсем карикатура.
Именно так поступают многие люди, допоздна засиживающиеся за компьютером
и ощущающие собственную неполноценность.
Основной вопрос отладки звучит так:
Как понять, что программа действительно работает правильно?
Если не можете ответить на этот вопрос, вы обречены на долгую и утомитель-
ную отладку, а ваши пользователи, скорее всего, будут вынуждены долго ждать,
когда же вы ее закончите. Мы возвращаемся к этому, потому что все, что помогает от-
ветить на поставленный вопрос, способствует минимизации отладки и помогает соз-
давать правильные и удобные в эксплуатации программы. В принципе программиро-
вать надо так, чтобы жучкам было негде укрыться. Разумеется, это слишком сильно
сказано, но наша цель — структурировать программу, чтобы минимизировать вероят-
ность ошибок и максимально увеличить вероятность их обнаружения,
5.9.1. Практические советы по отладке
Подумайте об отладке, прежде чем напишете первую строку своей программы.
Когда написано много строк, уже слишком поздно пытаться упростить отладку.
Решите, как сообщать об ошибках. По умолчанию в этой книге принят следую-
щий принцип: "Использовать функцию error () и перехватывать исключение
в функции main ()".
Старайтесь, чтобы программу было легко читать.
• Хорошо комментируйте свою программу. Это не значит просто: "Добавьте
много комментариев". Вы не можете сформулировать смысл операции на ес-
тественном языке лучше, чем на языке программирования. В комментариях
следует ясно и коротко указать то, что невозможно выразить в коде.
• Название программы.
• Цель программы.
• Кто написал программу и зачем.
• Номера версий.
• Какие фрагменты кода могут вызвать сложности.
• Основные идеи.
• Как организован код.
\Ш
0
0
0188
ГЛАВА 5 • ОШИБКИ
• Какие предположения сделаны относительно вводных данных.
• Каких фрагментов кода пока не хватает и какие варианты еще не обрабо-
таны.
• Используйте осмысленные имена.
• Это не значит: "Используйте длинные имена".
• Используйте логичную схему кода.
• Ваша интегрированная среда программирования может помочь, но она
не может сделать за вас всю работу.
• Воспользуйтесь стилем, принятым в книге.
• Разбивайте программу на небольшие фрагменты, каждый из которых выра-
жает определенную логическую операцию.
• Старайтесь, чтобы функция не превышала больше одной-двух страниц;
большинство функций будет намного короче.
• Избегайте сложных выражений.
• Пытайтесь избегать вложенных циклов, вложенных инструкций if, слож-
ных условий и т.д. К сожалению, иногда они необходимы, поэтому помни-
те, что в сложном коде легче всего спрятать ошибку.
• Используйте, где только можно, библиотечные функции, а не собственный код.
• Библиотеки, как правило, лучше продуманы и протестированы, чем ваши
собственные программы.
Пока все эти советы звучат довольно абстрактно, но скоро мы покажем примеры
их применения.
Скомпилируйте программу. Разумеется, для этого понадобится компилятор.
Его сообщения обычно весьма полезны, даже если мы хотели бы лучшего, и если
вы не профессионал, то должны считать, что компьютер всегда прав. Если же вы
реальный эксперт, то закройте книгу — она написана не для вас. Иногда програм-
мисту кажется, что правила компилятора слишком тупые и слишком строгие (как пра-
вило, это не так), и многие вещи можно было бы сделать проще (как бы не так). Одна-
ко, как говорится, "свой инструмент проклинает только плохой мастер". Хороший
мастер знает сильные и слабые стороны своего инструмента и соответственно его
настраивает. Рассмотрим наиболее распространенные ошибки компиляции.
• Закрыта ли кавычка строки литералов?
cout « "Привет, « паше << '\п'; // Ой!
• Закрыта ли кавычка отдельного литерала?
cout « "Привет, ■ « паше « '\п; // Ой/
• Закрыта ли фигурная скобка блока?ивШДКА 1.9
int f(int a)
{
if (a>0) { /* что-то делаем */ else { /* делаем что-то
другое */ }
} /Ой!
• Совпадает ли количество открывающих и закрывающих скобок?
if (a<=0 // Ой!
х = f(y);
Компилятор обычно сообщает об этих ошибках "поздно"; он просто не знает,
что вы имели в виду, когда забыли поставить закрывающую скобку после нуля.
• Каждое ли имя объявлено?
• Включены ли все необходимые заголовочные файлы (например, #include
"std_lib_facilities. h")?
• Объявлено ли каждое имя до его использования?
• Правильно ли набраны все имена?
int count; /*...*/ ++Count; // Ой!
char ch; /*...*/ Cin>>c; // Ой-ой!
• Поставлено ли двоеточие после каждой инструкции?
х = sqrt(y)+2 // Ой!
z = х+3;
В упражнениях мы привели еще больше примеров таких ошибок. Кроме того,
помните о классификации ошибок, указанной в разделе 5.2.
После того как программа скомпилирована, а ее связи отредактированы, насту-
пает самый трудный этап, на котором необходимо понять, почему программа рабо-
тает не так, как вы предполагали. Вы смотрите на результаты и пытаетесь понять,
как ваша программа могла их вычислить. На самом деле чаще программисты смот-
рят на пустой экран и гадают, почему их программа ничего не вывела. Обычная
проблема с консолью Windows заключается в том, что она исчезает, не дав вам
шанса увидеть, что было выведено на экран (если что-то все-таки было выведено).
Одно из решений этой проблемы — вызвать функцию keep_window_open () из за-
головочного файла std_lib_facilities.h в конце функции main О. В таком слу-
чае программа попросит вас ввести что-нибудь перед выходом, и вы сможете про-
смотреть результаты ее работы до того, как окно закроется.
В поисках ошибок тщательно проверьте инструкцию за инструкцией, начиная
с того места, до которого, по вашему мнению, программа работала правильно.
Встаньте на место компьютера, выполняющего вашу программу. Соответствует ли
вывод вашим ожиданиям? Разумеется, нет, иначе вы не занимались бы отладкой.
• Часто, когда программист не видит проблемы, причина заключается в том,
что вы видите не действительное, а желаемое. Рассмотрим пример.
for (int i = 0; i<=max; ++j) { // Ой! (Дважды)
for (int i=0; 0<max; ++i); // Выводим элементы вектора v
cout << ev[" << i << ,,]==и << v[i] « *\n';190
I ЛАВА 5 • ОШИБКИ
Последний пример позаимствован из реальной программы, написанной опытным
программистом (я подозреваю, что он писал этот фрагмент глубокой ночью).
• Часто, когда вы не видите проблемы, причина заключается в том, что между
точкой, где программа еще работала правильно, и следующей точкой, где
программа выдала неверный ответ, содержится слишком много инструкций
(или выводится слишком мало информации). Большинство интегрированных
сред программирования допускают пошаговую отладку программ. В конце
концов, вы научитесь пользоваться этими возможностями, но при отладке
простых программ достаточно расставить в нескольких местах дополнитель-
ные инструкции вывода (с помощью потока сегг). Рассмотрим пример.
int
{
}
my_fct(int a, double d)
int res ж 0;
cerr « "my_fct(" « a << "," « d << ")\n";
// . . . какой-то код . . .
cerr « "my_fct() возвращает ■ << res << • \n';
return res;
• Вставьте инструкции для проверки инвариантов (т.е. условий, которые всегда
должны выполняться; см. раздел 9.4.3) в подозрительные разделы.
Рассмотрим пример.
int my_complicated_f unction (int a, int bf int c)
// Аргументы являются положительными и а < b < с
{
if (l(0<a && a<b && b<c)) // l значит НЕ, а && значит И
error ("Неверные аргументы функции mcf ") ;
// . . .
}
• Если все сказанное не привело к успеху, вставьте инварианты в разделы про-
граммы, которые вы считаете правильными. Весьма вероятно, что вы найдете
ошибку. Инструкция для проверки инвариантов называется assert.
\Г7[ Интересно, что существует несколько эффективных способов программирова-
■—■ ния. Разные люди совершенно по-разному программируют. Многие различия
между методами отладки объясняются разнообразием программ, а другие происте-
кают из разных образов мышления. Следует знать, что наилучшего способа отладки
не существует. Просто надо помнить, что запутанный код чаще содержит ошибки.
Старайтесь писать программы просто и логично, форматируйте их, и вы сэкономите
время за счет отладки.
5.10. Пред- и постусловия
Теперь вернемся к вопросу, как поступать к неправильными аргументами
функции. Вызов функции — это наилучшая отправная точка, для того чтобы5 10 ПРЕД- И ПОСТУСЛОВИЯ
191
подумать о правильном коде и обработке ошибок: именно здесь происходит разде-
ление вычислений на логические блоки. Рассмотрим следующий пример, уже пока-
занный выше.
int mycomplicatedf unction (int a, int bf int c)
Аргументы являются положительными и а < b < с
{
if (1(0<а && a<b && b<c)) // ! значит НЕ, а && значит И
error ("Неверные аргументы функции mcf);
/ . . .
}
Во-первых, в комментарии утверждается, какие аргументы ожидает функция,
а затем происходит проверка этого условия (и генерирование исключения, если это
условие нарушается). Это правильная стратегия. Требования, которые функция
предъявляет к своим аргументам, часто называют предусловиями (pre-condition): они
должны выполняться, чтобы функция работала правильно. Вопрос заключается
в том, что делать, если предусловия нарушаются. У нас есть две возможности.
1. Игнорировать это (надеясь или предполагая, что все вызывающие функции
передают правильные аргументы).
2. Проверить их (и каким-то образом сообщить об ошибке).
С этой точки зрения типы аргументов — это лишь способ проверки простейших
предусловий на этапе компиляции. Рассмотрим пример.
int х = my_complicated_function(l, 2, "horsefeathers");
Здесь компилятор обнаружит, что третий аргумент не является целым числом
(предусловие нарушено). По существу, в этом разделе мы говорим о предусловиях,
которые компилятор проверить не в состоянии.
Мы предполагаем, что предусловия всегда зафиксированы в комментариях
(так что программист, вызывающий функцию, может видеть, что ожидает вы-
зываемая функция). Если функция не содержит комментарии, в которых указаны
условия, накладываемые на аргументы, будем считать, что он может принимать лю-
бые аргументы. Но стоит ли надеяться, что программист, вызывающий функцию,
станет читать эти аргументы и придерживаться установленных правил? Иногда это
можно делать, но, как правило, все же следует проверить выполнение предусловий.
Это следует делать всегда, если нет веской причины этого не делать. К таким при-
чинам относятся следующие.
• Никто не может передать неправильные аргументы.
• Проверка слишком сильно замедлит выполнение программы.
• Проверка является слишком сложной.
Первую причину можно признать уважительной, только если вы знаете, кто будет
вызывать вашу функцию. В реальном мире это практически невозможно.
0192
IJIMDA Э • ОШИБКИ
Вторая причина является веской намного реже, чем люди думают, и часто долж-
на быть отклонена как пример преждевременной оптимизации. Проверку всегда
можно удалить из программы после ее отладки. Не стоит пренебрегать такими про-
верками, иначе вас ждут бессонные ночи в поисках ошибок, которые можно было
бы предотвратить.
Третья причина является довольно серьезной. Опытный программист может лег-
ко привести пример, в котором проверка предусловия занимает намного больше
времени, чем выполнение самой функции. В качестве примера можно назвать поиск
в словаре: предусловием является упорядоченность словаря, но проверка, упорядо-
чен ли словарь, намного сложнее, чем поиск в нем. Иногда предусловие сложно за-
кодировать и правильно выразить. Тем не менее, написав функцию, обязательно
удостоверьтесь, можно ли написать быструю проверку ее предусловий, если у вас
нет веских причин этого не делать.
Написав предусловия (даже в виде комментариев), вы значительно повысите ка-
чество программы: это заставит вас задуматься о том, какие аргументы требует
функция. Если вы не можете просто и ясно сформулировать эти требования в виде
комментария, то, вероятно, вы плохо продумали свою программу. Опыт показывает,
что такие предусловия и их проверки помогают избежать многих ошибок. Мы уже
указывали, что ненавидим отладку; ясно сформулированные предусловия позволя-
ют избежать конструктивных ошибок, а также устранить неправильное использова-
ние функций на ранних стадиях разработки программы. Вариант
int my_complicated_function(int af int bf int c)
// Аргументы являются положительными и а < b < с
{
if (l(0<a && a<b && b<c)) // ! значит НЕ, а && значит И
error ("Неверные аргументы функции mcf);
// . . .
}
сэкономит ваше время и силы по сравнению с более простым вариантом:
int my_complicated_function(int a, int b, int с)
{
// ...
}
5.10.1. Постусловия
Формулировка предусловий позволяет улучшить структуру программы и пере-
хватить неправильное использование функций на ранних этапах программирования.
Можно ли использовать эту идею где-нибудь еще? Да, на ум сразу приходит опера-
тор return! Помимо всего прочего, следует указать, что именно функция будет
возвращать; иначе говоря, если мы возвращаем из функции какое-то значение,
то всегда обещаем вернуть что-то конкретное (а как иначе вызывающая функция
будет знать, чего ей ждать?).5 1 ЕСТИРОВАНИЕ
193
Верне\ся к нашей функции, вычисляющей площадь прямоугольника (см. раз-
д л5 6 1)
Вы исляет площадь прямоугольника;
если аргументы неправильные, генерирует исключение Bad_area
int area(int length, int width)
{
if (length< = 0 || width <=0) throw Badarea () ;
return length*width;
}
Эта функция проверяет предусловия, но они не сформулированы в виде коммен-
тариев (для такой короткой функции это вполне допустимо), и считается, что все
вычисления проводятся корректно (для таких простых вычислений это также впол-
не приемлемо). И тем не менее эту функцию можно было написать намного яснее.
int area(int length, int width)
// Вычисляет площадь прямоугольника;
// предусловия: аргументы length и width являются положительными
// постусловия: возвращает положительное значение, являющееся
// площадью
{
if (length<=0 || width <=0) error ("area () pre-condition");
int a = length*width;
if (a<=0) error("area() post-condition");
return a;
}
Мы не можем проверить выполнение всех постусловий, но можем проверить их
часть, убедившись, что возвращаемое число является положительным.
Э ПОПРОБУЙТЕ
Найдите пару значений, при которых предусловие выполняется, а постусловие — нет.
Пред- и постусловия обеспечивают проверку логичности кода. Они тесно связа-
ны с понятиями инвариантов (раздел 9.4.3), корректности (разделы 4.2 и 5.2), а так-
же с тестированием (глава 26).
5.11. Тестирование
Как определить, когда следует остановить отладку? Ясно, что отладка должна
идти до тех пор, пока не будут выявлены все ошибки, — или нам так покажется.
А как узнать, что мы нашли последнюю ошибку? Мы не знаем. Последняя ошиб-
ка — это шутка программистов. Такой ошибки не существует. В большой програм-
ме никогда невозможно найти последнюю ошибку.
§S| Кроме отладки, нам необходим систематический подход к поиску ошибок.
==' Он называется тестированием (testing) и рассматривается в разделе 7.3, уп-
ражнениях к главе 10 и в главе 26. В принципе тестирование— это выполнение194
ГЛАВА 5 • ОШИБКИ
программы с большим и систематически подобранным множеством входных дан-
ных и сравнение результатов с ожидаемыми. Выполнение программы с заданным
множеством входных данных называют тестовым вариантом (test case). Для ре-
альных программ могут потребоваться миллионы тестовых вариантов. Тестирова-
ние не может быть ручным, когда программист набирает варианты тест за тестом,
поэтому в последующих главах мы рассмотрим инструменты, необходимые для
правильного тестирования.
Тем временем напомним, что тестирование основано на убеждении, что поиск
ошибок выполняется правильно. Рассмотрим пример.
Точка зрения 1. Я умнее любой программы! Я могут взломать код @#$%А!
Точка зрения 2. Я вылизывал эту программу две недели. Она идеальна!
Как вы думаете, кто из этих двух программистов найдет больше ошибок? Разу-
меется, наилучшим вариантом является опытный программист, придерживающийся
первой точки зрения и спокойно, хладнокровно, терпеливо и систематически рабо-
тающий над ошибками. Хорошие тестировщики на вес золота!
Мы стараемся систематически выбирать тестовые варианты и всегда проверять
правильные и неправильные входные данные. Первый пример будет приведен
в разделе 7.3.
Задание
Ниже приведены двадцать пять фрагментов кода. Каждый из них должен быть
впоследствии вставлен в определенное место программы.
#include ■stdlibfacilities.h"
int main()
try {
«здесь будет ваш код>>
keep_window_open();
return 0;
}
catch (exceptions e) {
cerr << "error: " « e.whatO << '\n';
keep_window_open();
return 1;
}
catch (...) {
cerr << "Ой: неизвестное исключение!\n";
keep_window_open();
return 2;
}
В некоторых из них есть ошибки, а в некоторых — нет. Ваша задача — найти
и устранить все ошибки. Устранив эти ошибки, скомпилируйте программу, выпол-
ните ее и выведите на экран слово "Success!". Даже если вы считаете, что нашли все
ошибки, вставьте в программу исходный (неисправленный) вариант и протестируй-
иКОНТРОЛЬНЫЕ ВОПРОСЫ
195
те его; может быть, ваша догадка об ошибке была неверной или во фрагменте их
несколько Кроме того, одной из целей этого задания является анализ реакции ком-
пилятора на разные виды ошибок. Не набирайте эти фрагменты двадцать пять
раз — для этого существует прием "copy-paste". He устраняйте проблемы, просто
удаляя инструкции; исправляйте их, изменяя, добавляя или удаляя симюлы.
1. cout « "Success!\n";
2. cout << "SuccessI\n;
3. cout << "Success" << !\n"
4. cout << success << endl;
5. string res = 7; vector<int> v(10); v[5] = res; cout « "Success!\n";
6. vector<int> v(10); v(5) = 7; if (v(5) !=7) cout « "Successl\n";
7. if (cond) cout << "Success!\n"; else cout << "Faill\n";
8. bool с = false; if (c) cout « "Success!\n"; else cout « "Fail!\n";
9. string s = "ape"; boo с = ,,fool"<s; if (c) cout « "Success!\n";
10. string s = "ape"; if (s=="fool") cout « "SuccessI \n";
11. string s = "ape"; if (s=="fool") cout < "Success!\n";
12. string s = "ape"; if (s+"fool") cout < "Success!\n";
13. vector<char> v(5); for (int i=0; 0<v.size(); ++i) ;
cout « "Successl\n";
14. vector<char> v(5); for (int i=0; i<=v.size(); ++i) ;
cout « "Success I\n";
15. string s = "Success !\n"; for (int i=0; i<6; ++i) cout « s [i] ;
16. if (true) then cout << "Success! \n"; else cout << "Faill\n";
17. int x = 2000; char с = x; if (c==2000) cout « "Success!\n";
18. string s = "Success !\n"; for (int i=0; i<10; ++i) cout « s [i] ;
19. vector v(5); for (int i=0; i<=v.size(); ++i) ;
cout « "SuccessI\n";
20. int i=0; int j = 9; while (i<10) ++j;
if (j<i) cout « "SuccessI\n*;
21. int x = 2; double d = 5/(x-2); if (d==2*x+0.5) cout « "Success!\n";
22. string<char> s = "Success!\n"; for (int i=0; i<=10;
++i) cout « в[i] ;
23. int i=0; while (i<10) ++j; if (j<i) cout « "Success!\n";
24. int x = 4; double d = 5/(x-2); if (d=2*x+0.5) cout « "Success!\n";
25. cin << "Success!\n";
Контрольные вопросы
1. Назовите четыре основных вида ошибок и кратко опишите их.
2. Какие виды ошибок в студенческих программах можно проигнорировать?
3. Что должен гарантировать любой законченный проект?
4. Перечислите три подхода к исключению ошибок в программе и разработке пра-
вильного программного обеспечения.
5. Почему мы ненавидим отладку?
6. Что такое синтаксическая ошибка? Приведите пять примеров.
7. Что такое ошибка типа? Приведите пять примеров.
8. Что такое ошибка этапа редактирования связей? Приведите три примера.196
ГЛАВА 5 • ОШИБКИ
9. Что такое логическая ошибка? Приведите три примера.
10. Перечислите четыре источника потенциальных ошибок, рассмотренных в тексте.
11. Как распознать разумные результаты? Какие методы используются для ответа
на этот вопрос?
12. Сравните обработку ошибки во время выполнения программы в модуле, вызы-
вающем функцию, и в самой функции.
13. Почему использование исключений лучше, чем возврат признака ошибки?
14. Как выполнить тестирование при последовательном вводе данных?
15. Опишите процесс генерирования и перехвата исключений.
16. Почему выражение v [v. size () ] относительно вектора v порождает ошибку
диапазона? Каким может быть результат такого вызова?
17. Дайте определение пред- и постусловия; приведите пример (который отличается
от функции area () из этой главы), предпочтительно использовать вычисления,
требующие применения цикла.
18. В каких ситуациях можно не проверять предусловие?
19. В каких ситуациях можно не проверять постусловие?
20. Назовите этапы отладки.
21. Чем комментарии могут помочь при отладке?
22. Чем тестирование отличается от отладки?
Термины
catch
throw
инвариант
исключение
контейнер
логическая ошибка
отладка
Упражнения
ошибка
ошибка аргумента
ошибка диапазона
ошибка на этапе выполнения
программы
ошибка на этапе компиляции
ошибка на этапе редактиро-
вания связей
ошибка типа
постусловие
предусловие
синтаксическая ошибка
тестирование
требование
утверждение
1. Выполните задание из раздела Попробуйте, если вы его еще не сделали.
2. Следующая программа вводит температуру по шкале Цельсия и преобразует
ее в шкалу Кельвина. Этот код содержит много ошибок. Найдите ошибки, пере-
числите их и исправьте программу.
double сtok(double с) // преобразует шкалу Цельсия в шкалу Кельвина
{
int k = с + 273.15;
return int
}УПРАЖНЕНИЯ
197
int main ()
{
double с = 0; // объявляем переменную для ввода
cin >> d; // вводим температуру в переменную ввода
double к =» ctok("c"); // преобразуем температуру
Cout << к << endl ; // выводим температуру на печать
}
3. Самой низкой температурой является абсолютный нуль, т.е. -273,15°С, или 0 К.
Даже после исправления приведенная выше программа выводит неверные ре-
зультаты для температуры ниже абсолютного нуля. Поместите в функцию
main () проверку, которая выводит сообщение об ошибке, если температура ни-
же-273,15°С.
4. Повторите упр. 3, но на этот раз ошибку обработайте в функции ctok ().
5. Измените программу так, чтобы она преобразовывала шкалу Кельвина в шкалу
Цельсия.
6. Напишите программу, преобразовывающую шкалу Цельсия в шкалу Фаренгейта
и наоборот (по формуле из раздела 4.3.3). Для того чтобы распознать разумные
результаты, используйте оценку из раздела 5.8.
7. Квадратное уравнение имеет вид
а-х" + Ь-х + с = 0.
Для решения этого уравнения используется формула
-b±y/b2-4ac
х = .
2а
Тем не менее есть одна проблема: если Ъ2-Аас меньше нуля, возникнет ошибка.
Напишите программу, вычисляющую решение квадратного уравнения. Напиши-
те функцию, которая выводит на печать все корни квадратного уравнения при
заданных коэффициентах а, Ъ и с и генерирует исключение, если Ь -Лас меньше
нуля. Вызовите эту функцию из модуля main () и перехватите исключение, если
возникнет ошибка. Если программа выявит, что уравнение не имеет действи-
тельных корней, она должна вывести на печать соответствующее сообщение.
Как распознать разумные результаты? Можете ли вы проверить, что они являют-
ся правильными?
8. Напишите программу, считывающую ряд чисел и записывающую их в trec-
tor<int>. После того как пользователь введет все числа, он может попытаться
определить, сколько чисел он ввел, чтобы найти их сумму. Выведите ответ Nt
равный количеству элементов в векторе. Например:
"Пожалуйста, введите несколько чисел (для прекращения ввода нажмите клави-
шу < | >):-
12 23 13 24 15198
ГЛАВА 5 • ОШИБКИ
"Пожалуйста, введите количество чисел, которые хотите просуммировать
(начиная с первого):"
3
"Сумма первых 3 чисел: 12, 23 и 13 равна 48."
Обработайте все входные данные. Например, убедитесь, что программа выдает
сообщение об ошибке, если пользователь просит просуммировать больше чисел,
чем хранится в векторе.
Измените программу из упр. 6, чтобы она выводила сообщение об ошибке, если
результат нельзя представить как тип int.
9. Измените программу из упр. 8, чтобы она использовала тип double вместо int.
Кроме того, создайте вектор действительных чисел, содержащий N-\ разностей
между соседними величинами, и выведите этот вектор на печать.
10. Напишите программу, вычисляющую начальный отрезок последовательности
Фибоначчи, т.е. последовательности, начинающиеся с чисел 1 12358 1321 34.
Каждое число в этой последовательности равно сумме двух предыдущих. Найдите
последнее число Фибоначчи, которое можно записать в переменную типа int.
11. Реализуйте простую игру на угадывание "Быки и коровы'*. Программа должна
хранить вектор из четырех чисел в диапазоне от 0 до 9, а пользователь должен
угадать загаданное число. Допустим, программа загадала число 1234, а пользо-
ватель назвал число 1359; программа должна ответить "1 бык и 1 корова", по-
скольку пользователь угадал одну правильную цифру (1) на правильной пози-
ции (бык) и одну правильную цифру (3) на неправильной позиции (корова).
Угадывание продолжается, пока пользователь не получит четырех быков, т.е. не
угадает четыре правильные цифры на четырех правильных позициях.
12. Эта программа довольно сложная, поскольку ответы трудно кодировать. Соз-
дайте вариант, в котором игрок может играть постоянно (без остановки и по-
вторного запуска) и в каждой новой игре генерируются новые четыре цифры.
Четыре случайные цифры можно сгенерировать с помощью четырех вызовов
генератора случайных целых чисел randint(io) из заголовочного файла
stdlibfacilities.h. Обратите внимание на то, что при постоянном выпол-
нении программы вы каждый раз при новом сеансе будете получать одинаковые
последовательности, состоящие из четырех цифр. Для того чтобы избежать это-
го, предложите пользователю ввести любое число и вызовите функцию
srand(n), где п— число, введенное пользователем до вызова функции
randint(lO). Такое число п называется начальным значением (seed), причем
разные начальные значения приводят к разным последовательностям случайных
чисел.
13. Введите пары (день недели, значение) из стандартного потока ввода. Например:
Tuesday 23 Friday 56 Tuesday -3 Thursday 99ПОСЛЕСЛОВИЕ
199
Запишите все значения для каждого дня недели в вектор vector<int>. Запиши-
те значения семи дней недели в отдельный вектор. Напечатайте сумму чисел для
каждого из векторов. Неправильный день недели, например Funday, можно
игнорировать, но синонимы допускаются, например Моп и monday. Выведите
на печать количество отвергнутых чисел.
Послесловие
Не считаете ли вы, что мы придаем ошибкам слишком большое значение? Нович-
ки могут подумать именно так. Очевидная и естественная реакция такова: "Все не
может быть настолько плохо!" Именно так, все именно настолько плохо. Лучшие умы
планеты поражаются и пасуют перед сложностью создания правильных программ.
По нашему опыту, хорошие математики, как правило, недооценивают проблему оши-
бок, но всем ясно, что программ, которые с первого раза выполняются правильно,
очень немного. Мы вас предупредили! К счастью, за ^пятьдесят лет мы научились
организовывать код так, чтобы минимизировать количество проблем, и разработали
методы поиска ошибок, которые, несмотря на все наши усилия, неизбежны. Методы
и примеры, описанные в этой главе, являются хорошей отправной точкой.Создание программ
"Программирование — это понимание".
Кристен Нигаард (Kristen Nygaard)
Создание программы предполагает последовательное уточнение того, что
вы хотите сделать и как вы желаете это выразить. В этой и следующей
главах мы разработаем одну программу, пройдя весь путь от первой еще не-
ясной идеи через этапы анализа, проектирования, реализации, тестирования,
повторного проектирования и повторной реализации. Наша цель — дать вам
представление о способе мышления программиста, создающего свою про-
грамму. По ходу изложения мы обсудим структуру программы, типы, опре-
де ленные пользователем, и обработку входной информации.202
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
В этой главе..
6.1. Задача
6.2. Размышления над задачей
6.2.1. Стадии разработки программы
6.2.2. Стратегия
6.3. Назад к калькулятору!
6.3.1. Первое приближение
6.3.2. Лексемы
6.3.3. Реализация лексем
6.3.4. Использование лексем
6.3.5. Назад к школьной доске!
6.4. Грамматики
6.4.1. Отступление: грамматика анг-
лийского языка
6.4.2. Запись грамматики
6.5. Превращение грамматики в программу
6.5.1. Реализация грамматических правил
6.5.2. Выражения
6.5.3. Термы
6.5.4. Первичные выражения
6.6. Испытание первой версии
6.7. Испытание второй версии
6.8. Потоки лексем
6.8.1. Реализация класса Token_stream
6.8.2. Считывание лексем
6.8.3. Считывание чисел
6.9. Структура программы
6.1. Задача
Создание программы начинается с постановки задачи; иначе говоря, должна
существовать задача, которую вы хотите решить с помощью своей программы.
Понимание этой задачи является основной предпосылкой хорошей зада-
чи.Помимо всего прочего, программа, решающая неправильно поставленную задачу,
будет редко применяться, хотя может быть очень элегантной. Существуют счастливые
случаи, когда программа оказывается полезной для решения задачи, которую никто не
собирался решать, но на это везение рассчитывать не стоит. Мы хотим, чтобы про-
грамма просто и ясно решала поставленную задачу. Как может выглядеть программа
на этом этапе? Перечислим основные характеристики такой программы.
• Иллюстрирует методы проектирования и программирования.
• Дает возможность исследовать разные варианты решения, которые должен най-
ти программист, и учитывает ограничения, которые наложены на это решение.
• Не требует слишком большого количества новых языковых конструкций.
• Достаточно сложная и требует размышлений над ее проектированием.
• Допускает много вариантов решения.
• Решает понятную задачу.
• Решает задачу, которая заслуживает решения.
• Имеет решение, которое достаточно невелико, чтобы его можно было просто
и ясно описать и понять.
Мы выбрали следующую задачу: "Поручить компьютеру выполнить простые
арифметические операции, введенные пользователем". Иначе говоря, мы хотим
создать простой калькулятор. Совершенно очевидно, что такие программы полезны;
каждый настольный компьютер поставляется с такой программой, и вы можете6 2. РАЗМЫШЛЕНИЯ НАД ЗАДАЧЕЙ
203
даже купить карманный калькулятор, который выполняет только такие программы.
Наприм р, есл i вы введете строку
2+3.1*4
то программа должна ответить
14.4
К сожалению, такая программа не может сделать нам больше, чем программное
обеспечение, уже установленное на компьютере, но от первой программы не следу-
ет требовать слишком многого.
6.2. Размышления над задачей
С чего начать? Просто немного подумайте о задаче и о том, как ее можно ре-
шить. Сначала поразмышляйте о том, что должна делать программа и как вы хотели
бы с ней взаимодействовать. Затем подумайте о том, как написать такую програм-
му. Попытайтесь написать краткое изложение идеи, лежащей в основе решения,
и найдите изъяны в своей первой идее. По возможности обсудите задачу и способы
ее решения со своими друзьями. Объяснение идеи своим друзьям удивительным
образом позволяет понять ее недостатки и способы ее создания; бумага (или ком-
пьютер) не разговаривает с вами и обычно не соответствует вашим предположени-
ям. В принципе проектирование — это коллективная деятельность.
К сожалению, не существует универсальной стратегии, которая удовлетворила
бы всех людей и решила бы все задачи. Есть множество книг, авторы которых обе-
щают вам помочь при решении задач, а также огромное количество книг, посвя-
щенных проектированию программ. Наша книга не относится к такой литературе.
Мы изложим основы общей стратегии для решения небольших задач, с которыми
вы можете столкнуться. После этого быстро перейдем к реализации этой стратегии
при разработке калькулятора.
Рекомендуем при чтении наших комментариев к программе, выполняющей
функции калькулятора, занимать относительно скептическую позицию. Для реализ-
ма мы выполним несколько итераций разработки программы, создав несколько вер-
сий и продемонстрировав идеи, лежащие в основе каждой из них. Очевидно, что
большинство из этих идей являются незавершенными и даже ошибочными, иначе
нам пришлось бы слишком рано закончить эту главу. По мере продвижения вперед
мы приведем примеры разных принципов и рассуждений, которых постоянно при-
держиваются проектировщики и программисты. Следует иметь в виду, что в этой
главе мы еще не создадим достаточно удовлетворительный вариант программы, от-
ложив эту задачу до следующей главы.
Пожалуйста, имейте в виду, что путь, ведущий в окончательному варианту про-
граммы и проходящий через промежуточные решения, идеи и ошибки, не менее ва-
жен, чем сама программа, и более важен, чем технические детали языка программи-
рования, с которыми мы работаем (они будут рассмотрены позднее).204
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
6.2.1. Стадии разработки программы
Рассмотрим некоторые термины, связанные с разработкой программ. Работая
над решением задачи, вы обязательно несколько раз пройдете следующие этапы.
• Анализ. Осознаем, что следует сделать, и описываем свое (текущее) понима-
ние задачи. Такое описание называют набором требований или спецификаци-
|у | ей. Мы не будем углубляться в детали разработки и записи этих требований.
Этот вопрос выходит за рамки рассмотрения нашей книги, но он становится
все более важным по мере увеличения масштаба задачи.
• Проектирование. Разрабатываем общую структуру системы, решая, из каких
частей она должна состоять и как эти части должны взаимодействовать друг
с другом. В качестве составной части проектирования следует решить, какие
инструменты, например библиотеки, могут пригодиться при разработке про-
граммы.
• Реализация. Записываем код, отлаживаем его и тестируем, для того чтобы
убедиться, что программа делает то, что нужно.
6.2.2. Стратегия
Приведем некоторые предположения, которые при вдумчивом и творческом
подходе помогут при создании многих проектов.
Какая задача должна быть решена? Для того чтобы ответить на этот вопрос,
необходимо прежде всего попытаться уточнить, что вы пытаетесь сделать.
Как правило, для этого формулируют описание задачи, т.е. пытаются понять,
в чем заключается ее суть. На этом этапе вы должны встать на точку зрения
пользователя (а не программиста); иначе говоря, должны задавать вопросы
о том, что должна делать программа, а не о том, как она будет это делать.
Спросите: "Что эта программа может сделать для меня?" и "Как бы я хотел
взаимодействовать с этой программой?" Помните, большинство из нас явля-
ются опытными пользователями компьютеров.
• Ясна ли постановка задачи? Для реальных задач на этот вопрос никогда
нельзя ответить положительно. Даже студенческое упражнение бывает
трудно сформулировать достаточно точно и конкретно. Поэтому попытай-
тесь уточнить постановку задачи. Было бы обидно решить неправильно
поставленную задачу. Другая ловушка состоит в том, что вы можете по-
ставить слишком много вопросов. Пытаясь понять, что вы хотите, легко
увлечься и стать претенциозным. Почти всегда лучше задавать поменьше
вопросов, чтобы программу было легче описать, понять, использовать
и (возможно) реализовать. Убедившись, что этот подход работает, можно
создать более изощренную "версию 2.0", основанную на вашем опыте.6 2 РАЗМЫШЛЕНИЯ НАД ЗАДАЧЕЙ
205
• Выглядит ли задача решаемой при имеющихся времени, опыте и инстру-
ментах? Мало смысла начинать проект, который вы не сможете завер-
шить. Если у вас мало времени на реализацию (включая тестирование)
программы, в которой были бы учтены все требования, то лучше и не на-
чинать ее писать. Потребуйте больше ресурсов (особенно времени) или
(лучше всего) измените требования, чтобы упросить задачу.
• Постарайтесь разбить программу на небольшие части. Даже самая маленькая
программа, решающая реальную задачу, достаточно велика, для того чтобы
разбить ее на части.
• Знаете ли вы, какие инструменты, библиотеки и тому подобные ресурсы
вам могут понадобиться? Ответ почти всегда положительный. Даже на са-
мых ранних этапах изучения языка программирования в вашем распоря-
жении есть небольшие фрагменты стандартной библиотеки C++. Позднее
вы узнаете больше об этой библиотеке и способах ее эффективного ис-
пользования. Вам понадобятся графика и библиотеки графического ин-
терфейса пользователя, а также библиотеки для работы с матрицами и т.п.
Получив небольшой опыт, вы сможете найти тысячи таких библиотек
в веб. Помните: не стоит изобретать колесо, разрабатывая программное
обеспечение для решения реальных задач. Однако при обучении програм-
мированию все обстоит в точности наоборот: ученик должен заново изо-
брести колесо, чтобы увидеть, как оно действует. Время, которое вы сэко-
номите, используя хорошую библиотеку, можно посвятить разработке
других частей программы или отдыху. Как понять, что та или иная биб-
лиотека подходит для решения вашей задачи и имеет достаточно высокое
качество? Это трудная проблема. Можно поспрашивать у коллег, в дис-
куссионных группах по интересам или попытаться поэкспериментировать
с библиотекой на небольших примерах, прежде чем подключать ее к ва-
шему проекту.
• Проанализируйте части решения, которые описаны отдельно (и, возможно,
используются в разных местах программы или даже в других программах).
Для этого требуется опыт, поэтому в данной книге мы приводим много
примеров. Мы уже использовали векторы (класс vector), строки (класс
string), а также потоки ввода и вывода (cin и cout). Эта глава содержит
первые завершенные примеры проектирования, реализации и использова-
ния программы, содержащей типы, определенные пользователем (Token
и Token_stream). В главах 8 и 13-15 представлено много других приме-
ров вместе с принципами их проектирования. Пока рассмотрим аналогию:
если бы вы конструировали автомобиль, то начали бы с идентификации
его составных частей, например колес, двигателя, сидений, дверных ручек
И т.д. Современный автомобиль состоит из десятков тысяч таких, jcombo-206
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
нентов. Реальная программа в этом отношении не отличается от автомо-
биля за исключением того, что состоит из фрагментов кода. Мы же не пы-
таемся создавать автомобили непосредственно из исходного сырья, т.е. из
стали, пластика и дерева. Поэтому и программы не следует конструиро-
вать непосредственно из выражений, инструкций и типов, предусмотрен-
ных в языке. Проектирование и реализация составных компонентов явля-
ется основной темой нашей книги и проектирования программного обес-
печения вообще (пользовательские типы описаны в главе 9, иерархии
классов — в главе 14, а обобщенные типы — в главе 20).
• Создавайте небольшие и ограниченные версии программы, решающие клю-
чевые части вашей задачи. Начиная работу, мы редко хорошо понимаем зада-
чу. Мы часто так думаем (разве мы не знаем, что такое калькулятор), но на
самом деле это не так. Только сочетание размышлений над задачей (анализ)
и экспериментирования (проектирование и реализация) дает нам солидное
понимание того, что требуется для создания хорошей программы. Итак, пи-
шите небольшие и ограниченные версии, чтобы достичь следующих целей.
• Выявить свое понимание идеи и требуемые инструменты.
• Выявить необходимость изменений, чтобы сделать задачу проще. Анали-
зируя задачу и создавая первоначальные варианты программы, не стреми-
тесь решить все задачи сразу. Используйте возможности обратной связи,
которую дает тестирование.
Иногда такая ограниченная первоначальная версия называется прототипом
(prototype). Если первая версия не работает или работает очень плохо (что
вполне вероятно), отбросьте ее и создайте другую. Повторяйте этот процесс
до тех пор, пока не достигнете желаемого. Не барахтайтесь в путанице; со
временем она будет лишь возрастать.
• Создавайте полномасштабную версию, используя части первоначальной вер-
сии. В идеале программа должна вырастать из отдельных компонентов, а не
создаваться единым блоком. В противном случае придется рассчитывать
на чудо и ожидать, что непроверенная идея окажется работоспособной и по-
зволит достичь желаемого.
6.3. Назад к калькулятору!
Как мы хотим взаимодействовать с калькулятором? Это просто: мы знаем, как
использовать потоки с in и с out, но графические пользовательские интерфейсы
(GUI) будут рассмотрены лишь в главе 16, поэтому остановимся на клавиатуре
и консольном окне. Введя выражение с помощью клавиатуры, мы вычисляем его
и выводим результат на экран. Рассмотрим пример.
Выражение: 2+2
Результатs 46 3 НАЗАД К КАЛЬКУЛЯТОРУ!
207
Выражение: 24-2*3
Результат: 8
Выражение* 2+3-25/5
Результат: 0
Эти выражения, т.е. 2+2 и 2+2*3, должны быть введены пользователем; все ос-
тальное сделает программа. Для приглашения к вводу мы используем слово
"Выражение:". Мы могли бы выбрать фразу "Пожалуйста, введите выражение
и символ перехода на новую строку", но этот вариант выглядит слишком много-
словным и бессмысленным. С другой стороны, такие короткие приглашения, как >,
выглядят чересчур загадочно. Анализировать такие варианты использования на ран-
ней стадии проектирования программы весьма важно. Это позволяет сформулировать
очень практичное определение того, что программа должна делать как минимум.
Обсуждая проектирование и анализ, мы будем называть такие примеры преце-
дентами использования (use cases). Впервые сталкиваясь с разработкой калькулято-
ра, большинство людей сразу приходят к следующей логике программы:
read_a_line
calculate // выполните работу
write_result
Этот набросок, конечно, не программа; он называется псевдокодом (pseudo code).
Псевдокоды обычно используются на ранних этапах проектирования, когда еще
не совсем ясно, какой смысл мы вкладываем в обозначения. Например, является ли
слово "calculate" вызовом функции? Если да, то каковы его аргументы? Для ответа
на этот вопрос просто еще не настало время.
6.3.1. Первое приближение
На этом этапе мы действительно еще не готовы написать программу, имитирую-
щую функции калькулятора. Мы просто мало думали об этом, но размышления —
трудная работа, а, как большинство программистов, мы стремимся сразу писать
какой-то код. Итак, попробуем написать простую программу-калькулятор и посмот-
рим, к чему это приведет. Первое приближение может выглядеть примерно так:
#include "stdlibfacilities.h"
int main()
{
cout « "Пожалуйста, введите выражение (допускаются + и -) : ";
int lval =0;
int rval;
char op;
int res;
cin>>lval>>op>>rval; // считываем что-то вроде 1+3
if (op=='+')
res * lval + rval; // сложение
else if (op=='-')208
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
res = lval - rval; // вычитание
cout « "Результат: " « res << • \n';
keep_window_open();
return 0;
}
Иначе говоря, программа считывает пару значений, разделенных оператором,
например 2+2, вычисляет результат (в данном случае 4) и выводит его на печать.
Здесь переменная, стоящая слева от оператора, обозначена как lval, а переменная,
стоящая справа от оператора, — как rval.
Эта программа работает! Ну и что, если программа довольно простая? Очень хо-
рошо получить что-то работающее! Возможно, программирование и компьютерные
науки проще, чем о них говорят. Может быть, но не стоит слишком увлекаться ран-
ним успехом. Давайте сделаем кое-что.
1. Несколько упростим код.
2. Добавим операции умножения и деления (например, 2 *з).
3. Добавим возможность выполнять несколько операторов (например, l+2+з).
В частности, известно, что корректность входной информации следует проверять
(в нашем варианте мы "забыли" это сделать) и что сравнивать значения с несколь-
кими константами лучше всего с помощью инструкции switch, а не if.
Цепочку операций, например 1+2+3+4, будем выполнять по мере считывания
значений; иначе говоря, начнем с 1, потом увидим +2 и добавим 2 к 1 (получим
промежуточный результат, равный 3), увидим +3 и добавим 3 к промежуточному
результату, равному (з), и т.д.
После нескольких неудачных попыток и исправления синтаксических и логиче-
ских ошибок получим следующий код:
#include "stdlibfacilities.h"
int main()
{
cout <<
« "Пожалуйста, введите выражение (допускаются + , -, * и /) : ";
int lval = 0;
int rval;
char op;
cin>>lval; // считываем самый левый операнд
if (!cin) error("нет первого операнда");
while (cin»op) { // считываем оператор и правый операнд в цикле
cin>>rval;
if (Icin) error("нет второго операнда");
switch(op) {
case '+•:
lval += rval; // сложение: lval = lval + rval
break;6 3 НАЗАД К Ь У ОРУ!
209
с se - •
lval - rval; // вычитание: lval = lval - rval
brea ;
с s • * ' •
lval *- rval* // умножение: lval = lval * rval
break;
ca e '/':
lval = rval; // деление: lval = lval / rval
break;
default: // нет другого оператора: выводим результат
out << "Результат: " << lval << 'Xn';
keep_window_open();
return 0;
}
}
error("неверное выражение");
\
Это неплохо но попытайтесь вычислить выражение 1+2*3, и вы увидите, что ре-
(ультат равен 9, а не 7, как утверждают учителя математики. Аналогично, 1-2*3
)авно -3, а не -5, как мы думали. Мы выполняем операции в неправильном поряд-
се: 1+2*3 вычисляется как (1+2) *з, а не 1+ (2*3), как обычно. Аналогично, 1-2*3
вычисляется как (1-2) *3, а не 1-(2*3), как обычно. Лентяи! Мы можем считать
фавило, согласно которому умножение выполняется раньше, чем сложение, уста-
>евшим, но не стоит отменять многовековые правила просто для того, чтобы упро-
сить себе программирование.
>.3.2. Лексемы
Теперь (каким-то образом) мы должны заранее узнать, содержит ли строка сим-
юл * (или /). Если да, то мы должны (каким-то образом) скорректировать порядок
(ыполнения вычислений. К сожалению, пытаясь заглянуть вперед, мы сразу же на-
алкиваемся на многочисленные препятствия.
. Выражение не обязательно занимает только одну строку. Рассмотрим пример.
1
+
2
Это выражение до сих пор вычислялось без проблем.
\. Как обнаружить символ * (или /) среди цифр и символов + в нескольких строках
ввода?
\. Как запомнить, в каком месте стоит символ *?
\. Как вычислить выражение, которое не выполняется слева направо (как 1+2*3).
Если бы мы были безоглядными оптимистами, то сначала решили бы задачи 1-3,
отложив задачу 4 на более позднее время. Кроме того, нам понадобится помощь.
Кто-то ведь должен знать, как считать такие вещи, как числа и операторы, из
входного потока и сохранить их так, чтобы с ними было удобно работать. Обще-210
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
принятый и самый полезный ответ на эти вопросы таков: разложите выражение
на лексемы, т.е. сначала считайте символы, а затем объедините их в лексемы
(tokens). В этом случае после ввода символов
45+11.5/7
программа должна создать список лексем
45
+
11.5
/
7
Лексема (token) — это последовательность символов, выражающих нечто, что
мы считаем отдельной единицей, например число или оператор. Именно так
компилятор языка C++ работает с исходным кодом программы. На самом деле
разложение на лексемы часто в том или ином виде применяется при анализе текста.
Анализируя примеры выражений на языке C++, можно выделить три вида лексем.
• Литералы с плавающей точкой, определенные в языке C++, например 3.14,
0.274е2 и 42.
• Операторы, например +,-,*, /, %.
• Скобки (,).
Внешний вид литералов с плавающей точкой может создать проблемы: считать
число 12 намного легче, чем 12 .Зе-3, но калькуляторы обычно выполняют вычис-
ления над числами с плавающей точкой. Аналогично, следует ожидать, что скобки
в программе, имитирующей вычисления калькулятора, окажутся весьма полезными.
Как представить такие лексемы в нашей программе? Можно попытаться найти
начало (и конец) лексемы, но это может привести к путанице (особенно, если по-
зволить выражениям занимать несколько строк). Кроме того, если хранить числа
в виде строки символов, то позднее следует идентифицировать это число по его циф-
рам; например, если мы видим строку 42 и где-то храним символы 4 и 2, то позднее
должны выяснить, что эта строка представляет число 42 (т.е. 4*10+2). Общепринятое
решение этой задачи — хранить каждую лексему в виде пары (вид, значение).
Вид идентифицирует лексему как число, оператор или скобку. Для чисел (в на-
шем примере — только для чисел) в качестве значения используется само число.
Итак, как же выразить идею о паре (вид, значение) в программе? Для этого опре-
делим тип Token, представляющий лексемы. Почему? Вспомните, почему мы вооб-
ще используем типы: они хранят данные, которые нам нужны, и предоставляют
возможность выполнять полезные операции над этими данными. Например, тип
int позволяет хранить целые числа и выполнять операции сложения, вычитания,
умножения и вычисления остатка, в то время как тип string позволяет хранить по-
следовательности символов и выполнять конкатенацию и доступ к символу по ин-
и6.3 НАЗАД К КАЛЬКУЛЯТОРУ!
211
дексу. В языке C++ и его стандартной библиотеке определено много типов, напри-
мер char, int, double, string, vector и ostream, но не тип Token. На самом деле
существует огромное количество типов — тысячи и сотни тысяч, — которые мы хо-
тели бы иметь, но которых нет в языке и в стандартной библиотеке.
Среди наших любимых типов, которых нет в библиотеке,— классы Matrix
(см. главу 24), Date (см. главу 9) и целые числа с бесконечной точностью (поищите
в веб класс Bignum). Если вы еще раз поразмыслите над этим, то поймете, что язык
не может поддерживать десятки тысяч типов: кто их определит, кто их реализует,
как их найти и какое толстое руководство по использованию языка при этом полу-
чится? Как и большинство современных языков программирования, язык C++
решает эту проблему, позволяя программисту при необходимости определять свои
собственные типы (типы, определенные пользователем).
6.3.3. Реализация лексем
Как должна выглядеть лексема в нашей программе? Иначе говоря, как должен
выглядеть тип Token? Класс Token должен предусматривать выполнение операто-
ров, например + и -, а также представлять числа, такие как 42 и 3.14. В самой про-
стой реализации нужно придумать, как задать вид лексемы и как хранить числа.
Token : Token :
kind : plus kind :
value :
value :
number
3.14
Существует много способов реализации этой идеи в программе на языке C++.
Вот ее простейший вариант:
class Token { // очень простой тип, определенный пользователем
public:
char kind;
double value;
Класс Token — это тип (такой же, как int или char), поэтому его можно ис-
пользовать для определения переменных и хранения значений. Он состоит из двух
частей (членов): kind и value. Ключевое слово class означает "тип, определенный
пользователем"; это значит, что он содержит члены (хотя в принципе может их и не
содержать). Первый член, kind, имеет тип char и представляет собой символ. С его
помощью удобно хранить символы • + • и ' *», чтобы представить операции * и +.
Рассмотрим пример использования этого типа.
Token t; // t — объект класса Token
t.kind = *+•; // t представляет операцию +
Token t2; // t2 — другой объект класса Token
t2.kind ■ •в'; // цифра 8 означает, что "вид" является числом
t2.value * 3.14;212
ГЛАВА 6 * СОЗДАНИЕ ПРОГРАММ
Для доступа к члену класса используется обозначение имя_рбъекта.имя_члена.
Выражение t.kind читается как "член kind объекта t", а выражение
t2.value— как "член value объекта t2". Объекты класса Token можно копиро-
вать так же, как и переменные типа int.
Token tt s t{ // копирование при инициализации
if (tt.kind Is t.kind) error("невозможно!");
t = t2; // присваивание
cout « t.value; // вывод числа 3.14
Имея класс Token, можно выразить выражение (1.5+4)* 11 с помощью семи
лексем.
т
■
'8'
1.5
V
'
•8'
4
т
»*»
в-
11
Обратите внимание на то, что для простых лексем значение не требуется, поэто-
му мы не используем член value. Нам нужен символ для обозначения чисел.
Мы выбрали символ ' 8' просто потому, что он явно не оператор и не знак пунктуа-
ции. Использование символа ' 8 • для обозначения чисел немного загадочно, но это
лишь на первых порах.
Класс Token представляет пример типа, определенного пользователем. Тип, опре-
деленный пользователем, может иметь функции-члены (операции), а также данные-
члены. Существует много причин для определения функций-членов. В данном при-
мере мы описали две функции-члена для того, чтобы инициализация объекта класса
Token стала проще.
class Token {
public:
char kind; // вид лексемы
double value; // для чисел: значение
Token(char ch) // создаем объект класса Token
// из переменной типа char
:kind(ch), value(O) { }
Token(char chf double val) // создаем объект класса Token
:kind(ch), value (val) { } //из переменных типа
// char и double
};
Эти две функции-члена называют конструкторами (constructors). Их имя совпа-
дает с именем типа, и они используются для инициализации (конструирования)
объектов класса Token. Рассмотрим пример.
Token tl('+•); // инициализируем tlr
Token t2('8',11.5); // инициализируем t2 ,
// так что t2.kind =
так что tl.kind = '+'
8* и t2.value = 11.5
В первом конструкторе фрагмент :kind(ch), value(0) означает "инициали-
зировать член kind значением переменной ch и установить член value равным ну-6 3 А АД К АЛЬ У ЯТОРУ!
213
лю' Во втор ко структоре фрагмент :kind(ch), value (val) означает
' ин1 шал зи ь член kind значением переменной ch и установить член value
равным пе еме ной 1" В обоих вариантах нам требуется лишь создать объект
кла са Токе поэтому тело функции ничего не содержит: { }. Специальный син-
таксис инициализации (список инициализации членов класса) начинается с двоето-
чия и i спользуется только в конструкторах.
Обратите нимаш е на то, что конструктор не возвращает никаких значений, по-
тому что в кон трукторе это не предусмотрено. (Подробности изложены в разделах
9.4.2 и 9 7.)
6.3.4. Использование лексем
Итак, похоже, что мы можем завершить нашу программу, имитирующую каль-
кулятор! Однако следует уделить немного времени для планирования. Как исполь-
зовать класс Token в калькуляторе?
Можно считать входную информацию в вектор объектов Token.
Token get token О; // считываем объекты класса Token из потока cin
vector<Token> tok; // здесь храним объекты класса Token
int main()
{
while (cin) {
Token t = get_token();
tok.push_back(t) ;
}
// . . .
}
Теперь можно сначала считать выражение, а вычислить его позднее. Например,
для выражения 11*12 получим следующие лексемы:
'8'
11
•*»
'8*
12
Эти лексемы можно использовать для поиска операции умножения и ее операн-
дов. Это облегчает выполнение умножения, поскольку числа 11 и 12 хранятся как
числовые значения, а не как строки.
Рассмотрим теперь более сложные выражения. Выражение 1+2*3 состоит из пяти
объектов класса Token.
'8'
1
•+•
'8'
2
***
V '
*8-
3,214
ГЛАВА 6 • СОЗДАНИЕ Программ
Теперь операцию умножения можно выполнить с помощью простого цикла.
for (int i ш 0; i<tok.size(); ++i) {
if (tok[i],kind=='*•) { // мы нашли умножение!
double d = tok[i-l].value*tok[i+l].value;
// и что теперь?
}
}
Да, и что теперь? Что делать с произведением d? Как определить порядок вы-
полнения частичных выражений? Хорошо, символ + предшествует символу *, по-
этому мы не можем выполнить операции просто слева направо. Можно попытаться
выполнить их справа налево! Этот подход сработает для выражения 1+2*3, но не
для выражения 1*2+3. Рассмотрим выражение 1+2*3+4. Это пример "внутренних
вычислений": 1+(2*3)+4. А как обработать скобки? Похоже, мы зашли в тупик.
Теперь необходимо вернуться назад, прекратить на время программировать и поду-
мать о том, как считывается и интерпретируется входная строка и как вычисляется
арифметическое выражение.
Первая попытка решить эту задачу (написать программу-калькулятор) оказа-
лась относительно удачной. Это нетипично для первого приближения, которое
играет важную роль для понимания задачи. В данном случае это даже позво-
лило нам ввести полезное понятие лексемы, которое представляет собой частный
случай широко распространенного понятия пары (имя, значение). Тем не менее все-
гда следует помнить, что "стихийное" программирование не должно занимать
слишком много времени. Необходимо программировать как можно меньше, пока не
будет завершен этап анализа (понимание задачи) и проектирования (выявление об-
щей структуры решения).
* ПОПРОБУЙТЕ
С другой стороны, почему невозможно найти простое решение этой задачи? Ведь
она не выглядит слишком сложной. Такая попытка позволит глубже понять задачу
и ее решение. Сразу же определите, что следует сделать. Например, проанализируй-
те строку 12.5+2. Ее можно разбить на лексемы, понять, что выражение простое,
и вычислить ответ. Это может оказаться несколько запутанным, но прямым реше-
нием, поэтому, возможно, следовало бы идти в этом направлении! Определите, что
следует сделать, если строка содержит операции + и * в выражении 2+3*4?
Его также можно вычислить с помощью "грубой силы". А что делать с более слож-
ным выражением, например 1+2*3/4%5+ (6-7* (8)) ? И как выявлять ошибки, такие
как 2+*3 и 2&3? Подумайте об этом, опишите на бумаге возможные решения, ис-
пользуя интересные или типичные арифметические выражения.
6.3.5. Назад к школьной доске!
Теперь настало время снова проанализировать задачу и не бросаться сломя
голову программировать код, руководствуясь плохо продуманным планом. Как вы-
06.3 НАЗАД К КАЛЬКУЛЯТОРУ!
215
яснилось, программа-калькулятор, вычисляющая только одно выражение, никому
не интересна. Хотелось бы, чтобы она могла вычислять несколько выражений.
По этой причине наш псевдокод усложняется.
while (not_finished) {
read_a_line
calculate // выполняем вычисления
write_result
}
Очевидно, что задача усложнилась, но, размышляя о применении калькуляторов,
мы ведь понимаем, что они могут вычислять разные арифметические выражения.
Следует ли позволить пользователю несколько раз вызывать программу, чтобы вы-
полнить несколько вычислений. Можно, но эта программа под управлением совре-
менных операционных систем будет работать слишком медленно, поэтому такое
решение неприемлемо.
Проанализировав указанный псевдокод, наши первые попытки решить задачу,
а также примеры использования, мы сталкиваемся с рядом вопросов.
1. Если мы введем выражение 45+5/7, то как выделить его отдельные части —
45, +, 5, / и 7? (Выделение лексем!)
2. Как идентифицировать конец ввода выражения? Разумеется, с помощью символа
перехода на новую строку! (Слово "разумеется" всегда подозрительно: "разуме-
ется" — это не причина.)
3. Как представить выражение 45+5/7 в виде данных, чтобы потом вычислить его?
Прежде чем выполнить сложение, необходимо из цифр 4 и 5 образовать целое
число 45 (т.е. вычислить выражение 4*10+5). (Таким образом, выделение лек-
сем — только часть решения.)
4. Как гарантировать, что выражение 45+5/7 вычисляется как 45+(5/7), а не как
(45+5)/7?
5. Чему равно значение 5/7? Около .71, но это число не целое. Используя свой
опыт работы с калькуляторами, легко понять, что ответ должен быть числом
с плавающей точкой. Следует ли разрешить ввод таких чисел? Конечно!
6. Можно ли использовать переменные? Например, можно написать
v=7
m=9
v*m
Хорошая идея, но давайте подождем. Сначала следует понять, как работает про-
грамма. Возможно, ответ на шестой вопрос является самым важным. В разделе 7.8
мы увидим, что, ответив "да'*, мы практически вдвое увеличим размер программы.
Это приведет к удвоенным затратам времени, необходимого для разработки первого
приближения. Если вы новичок, то ваши усилия увеличатся даже вчетверо и проект
выйдет из-под вашего контроля. Очень важно избегать углубления во всевозмож-216
ГЛАВА б • СОЗДАНИЕ ПРОГРАММ
ные детали на ранних этапах проекта. Сначала создайте простую версию, реализо-
вав лишь основные функции. Получив работоспособную программу, вы станете бо-
лее уверенными. Намного проще разрабатывать программу поэтапно, а не сразу
всю. Ответив "да" на шестой вопрос, вы столкнетесь с еще одним неприятным эф-
фектом: теперь вам будет сложнее устоять перед соблазном реализовать еще одно
"важное свойство". Как насчет вычисления математических функций? А насчет
циклов? Начав накапливать "важные свойства", трудно остановиться.
С точки зрения программиста вопросы 1, 3 и 4 бессмысленны. Они связаны друг
с другом, поскольку, обнаружив число 45 и оператор +, мы должны решить, что
с ними делать? Иначе говоря, мы должны решить, как их хранить в программе?
Очевидно, что выделение лексем является частью решения, но только частью.
Как поступает опытный программист? Сложные технические вопросы часто име-
ют стандартные ответы. Известно, что люди пишут программы-калькуляторы так же
давно, как существует ввод символов с клавиатуры, т.е. как минимум пятьдесят лет.
Должен быть стандартный ответ! В такой ситуации опытный программист кон-
сультируется с коллегами или изучает научную литературу. Глупо надеяться, что
в один прекрасный день вы сможете придумать что-то лучшее, чем то, что было
сделано за пятьдесят лет.
6.4. Грамматики
Существует стандартный способ придать выражениям смысл: сначала ввести
символы, а затем собрать их в лексемы (как мы и сделали). Поэтому, если мы вве-
дем выражение
45+11.5/7
программа должна создать список лексем
45
+
11.5
/
7
Лексема— это последовательность символов, представляющих собой отдель-
ную единицу языка, например число или оператор.
После создания лексем программа должна обеспечить корректную интерпрета-
цию завершенных выражений. Например, нам известно, что выражение 45+11.5/7
означает 45+(11.5/7), а не (45+11.5)/7, но как объяснить программе, что деле-
ние имеет более высокий приоритет, чем сложение? Стандартный ответ — написать
грамматику, определяющую синтаксис ввода, а затем программу, реализующую
правила этой грамматики. Рассмотрим пример.
// Пример простой грамматики выражений:
Выражение:6.4. ГРАММАТИКИ
217
Терм
Выражение п + и Терм // сложение
Выражение "-" Терм // вычитание
Терм:
Первичное выражение
Терм "*" Первичное выражение // умножение
Терм "/" Первичное выражение // деление
Терм "%" Первичное выражение // остаток (деление по модулю)
Первичное выражение:
Число
»•(•' Выражение п)" // группировка
Число:
литерал_с_плавающей_точкой
Это набор простых правил. Последнее правило читается так: "Число — это ли-
терал с плавающей точкой". Предыдущее правило утверждает: "Первичное вы-
ражение — это Число или скобка, • (', за которой следует Выражение и скобка,
•) •". Правила для Выражения и Терма аналогичны; каждый из них определяется
в терминах одного из предыдущих правил.
Как показано в разделе 6.3.2, наши лексемы, позаимствованные из определения
языка C++, таковы:
• литералсплаванщейточкой (по правилам языка C++, например, 3.14,
0.274е2 или 42);
• +,-,*,/,% (операторы);
• ( , ) (скобки).
Переход от нашего пробного псевдокода к подходу, основанному на лексемах
и грамматиках, представляет собой огромный скачок вперед. Этот скачок является
мечтой любого программиста, но его редко удается сделать самостоятельно:
для этого нужен опыт, литература и учителя.
На первый взгляд грамматика абсолютна бессмысленна. Формальные обозначе-
ния всегда выглядят так. Однако следует иметь в виду, что они (как вы скоро убеди-
тесь) весьма элегантны, носят универсальный характер и позволяют формализовать
все арифметические вычисления. Вы без проблем можете вычислить выражения
1-2*3, i+2-з и 3*2+4/2. Кажется, что эти вычисления "зашиты" в вашем мозге.
Однако можете ли вы объяснить, как вы это делаете? Можете ли вы объяснить это
достаточно хорошо кому-нибудь, кто таких вычислений никогда не делал? Можете
ли вы сделать это для любого сочетания операторов и операндов? Для того чтобы
достаточно точно и подробно объяснить все это компьютеру, необходимы обозна-
чения, и грамматика является наиболее мощным и удобным инструментом*
Как читать грамматику? Получив некое входное выражение, мы ищем среди
правил совпадения для считанной лексемы, начиная с первого правила Выражение.
Считывание потока лексем в соответствии с грамматикой называется синтаксиче-218
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
ским разбором (parsing), а программа, выполняющая эту работу, называется син-
таксическим анализатором (parser, or syntax analyser). Синтаксический анализатор
считывает лексемы слева направо, точно так же, как мы печатаем, а затем читаем
слова. Рассмотрим простой пример: 2 — это выражение?
1. Выражение должно быть Термом или заканчиваться Термом. Этот Терм должен
быть Первичным выражением или заканчиваться Первичным выражением.
Это Первичное выражение должно начинаться с открывающей скобки, (, или
быть Числом. Очевидно, что 2 — не открывающая скобка, (, а ли*ерал_с_
плавагащей_точкой, т.е. Число, которое является Первичным выражением.
2. Этому Первичному выражению (Число 2) не предшествует ни символ /, ни *,
ни %, поэтому оно является завершенным Термом (а не выражением, которое
заканчивается символом /, * или %).
3. Этому Терму (Первичное выражение 2) не предшествует ни символ +, ни -, по-
этому оно является завершенным Выражением (а не выражением, которое
заканчивается символами + или -).
Итак, в соответствии с нашей грамматикой 2 — это выражение. Этот просмотр
грамматики можно описать так.
Грамматический раэбор выражения 2
Выражение:
Терм
Выражение"-»-" Терм
Выражение"—" Терм
Терм:
Первичное выражение
Терм '*" Первичное выражение
Терм "/" Первичное выражение
Терм"%" Первичное выражение
Первичное выражение:
Число
"(" Выражение")"
Число:
литерал_с_плавающей_точкой
Этот рисунок иллюстрирует путь, который мы прошли, перебирая определения.
Повторяя этот путь, мы видим, что 2 — это выражение, поскольку 2 — это лите-
рал_с_плавающей_точкой, который является Числом, которое является Первичным
выражением, которое является Термом, который является Выражением.
Выражение
Терм
Первичное выражение
t
Число
I
литерал_с_ппавающей_точкой
26 4 ГРАММАТИКИ
219
Попробуем проделать более сложное упражнение: 2+3 — это Выражение? Есте-
ственно, большинство рассуждений совпадает с рассуждениями для числа 2.
1. Выражение должно быть Термом или заканчиваться Термом, который должен быть
Первичным выражением или заканчиваться Первичным выражением, а Первичное
выражение должно начинаться с открывающей скобки, (, или быть Числом. Оче-
видно, что 2 не является открывающей скобкой, (, а литералом_с_плава-
ющейточкой, который является Числом, которое является Первичным выра-
жением.
2. Этому Первичному выражению (Число 2) не предшествует ни символ /, ни *,
ни %, поэтому оно является завершенным Термом (а не выражением, которое за-
канчивается символом /, * или %).
3. За этим Термом (Числом 2) следует символ +, поэтому он является окончанием
первой части Выражения, и мы должны поискать Терм, который следует за сим-
волом +.Точно так же мы приходим к выводу, что 2 и 3 — это Термы. Поскольку за
Термом 3 не следует ни символ +, ни -, он является завершенным Термом (а не
первой частью Выражения, содержащего символ + или -). Следовательно, 2+3 со-
ответствует правилу Выражение + Term и является Выражением.
Снова проиллюстрируем эти рассуждения графически (для простоты останавли-
вая разбор на правиле для литерала_с_плавающей_точкой).
Этот рисунок иллюстрирует путь, который мы прошли, перебирая определения.
Повторяя его, мы видим, что 2+3 — это Выражение, так как 2 — это Терм, который
является Выражением, 3 — это Терм, а Выражение, за которым следует символ +
и Терм, является Выражением.
Грамматический разбор выражения 2 + 3
г
Выражение
t
Терм
t
Выражение:
Терм
Выражение"+" Терм
Выражение ■—■ Терм
Терм:
Первичное выражение
Терм "*" Первичное выражение Первичное
Терм у Первичное выражение Ра^вн*1*
Терм"%" Первичное выражение
Первичное выражение:
Число
"(" Выражение")"
Число:
литералт_с_плавающей_точкой
Выражение
и
7
Число
4
Терм
t
Первичное
выражение
I
Число
3220
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Действительная причина, по которой мы так интересуемся грамматиками, за-
ключается в том, что с их помощью можно решить проблему корректного грамма-
тического разбора выражений, содержащих символы + и *, такие как 45+11.5*7.
Однако заставить компьютер анализировать правила так, как это сделали мы, очень
трудно. Поэтому пропустим промежуточные этапы, которые проделали для выра-
жений 2 и 2+3. Очевидно, что 45, 11.5 и 7 являются литераламисплаваю-
щей_точкой, которые являются Числами, которые являются Первичными выра-
жениями, так что можем игнорировать все остальные правила.
1. 45— это Выражение, за которым следует символ +, поэтому следует искать
Терм, чтобы применить правило Выражение+Терм.
2. 11.5 — это Терм, за которым следует символ *, поэтому следует искать Первич-
ное выражение, чтобы применить правило Терм*Первичное выражение.
3. 7— это первичное выражение, поэтому 11.5*7— это Терм в соответствии
с правилом Терм*Первичное выражение. Теперь можем убедиться, что
45+11.5*7— это Выражение в соответствии с правилом Выражение*Терм.
В частности, это Выражение, которое сначала выполняет умножение 11.5*7,
а затем сложение 45+11.5*7 так, будто мы написали выражение 45+(11.5*7).
Еще раз проиллюстрируем эти рассуждения графически (как и ранее, для про-
стоты останавливая разбор на правиле для литераласллавагащейточкои).
Как и прежде, этот рисунок иллюстрирует путь, который мы прошли, перебирая
определения. Обратите внимание на то, что правило Терм*Первичное выражение
гарантирует, что 11.5 умножается на 7, а не добавляется к 45.
Грамматический разбор выражения 45 +11.5 * 7
Выражение
Выражение:
Терм
Выражение "+" Терм
Выражение *—" Терм
Терм:
Первичное выражение
Терм "*" Первичное выражение
Терм У" Первичное выражение
Терм"%" Первичное выражение
Первичное выражение:
Число
"(" Выражение')'
Число:
литерал__с_плавающей_точкой
Выражение
t
Терм
Первичное
выражение
I
Число
Терм
t
Первичное
вьражен е
Число
Тер
ч
Первичное
выражение
Число
45
11 56 4. ГРАММАТИКИ
221
Эта логика может показаться запутанной, но многие люди читают грамматики,
и простые грамматики несложно понять. Тем не менее мы не собираемся учить вас
вычислять выражение 2+2 или 45+11.5*7. Очевидно, вы это и так знаете. Мы лишь
стараемся выяснить, как выполняет эти вычисления компьютер. Разумеется, для то-
го чтобы выполнять такие вычисления, людям грамматики не нужны, а вот компью-
терам они очень хорошо подходят. Компьютер быстро и правильно применяет пра-
вила грамматики. Точные правила — вот что нужно компьютеру.
6.4.1. Отступление: грамматика английского языка
Если вы еще никогда не работали с грамматиками, то ваша голова может закру-
житься. Но, даже если вы уже сталкивались с грамматиками раньше, ваша голова
может закружиться, когда вы увидите следующую грамматику, описывающую
очень небольшую часть английского языка.
Предложение :
Имя существительное Глагол // например, C++ rules
Предложение Союз Предложение // например, Birds fly but
// fish swim
Союз :
"and"
"or"
"but"
Имя существительное :
"birds"
"fish"
"C++"
Глагол :
"rules"
"fly"
n swim"
Предложение состоит из частей речи (например, имен существительных, глаго-
лов и союзов). В соответствии с этими правилами предложение можно разложить
на слова — имена существительные, глаголы и т.д. Эта простая грамматика также
включает в себя семантически бессмысленные предложения, такие как "C++ fly and
birds rules," но решение этой проблемы выходит далеко за рамки рассмотрения на-
шей книги.
Многие читатели наверняка уже изучали такие правила в средней школе при
изучении иностранных языков. Эти правила носят фундаментальный характер. В их
основе лежат серьезные неврологические аргументы, утверждающие, что эти пра-
вила каким-то образом "встроены" в наш мозг!
Рассмотрим дерево грамматического разбора простого предложения на англий-
ском языке.222
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Грамматический разбор простого предложения на английском языке
Имясущесгетвльное
Ш Sentence Conjunction Sentence
f
f Союз:
, /and"
•or*
•buT
Имя существительное:
, "birds'
fish*
-C++*
Глагол:
"rules"
•fly*
"swim"
Предложение
i L
Предложение
Союз
Имя существительное Глагол
Предложение
__*
Имя существительное Глагол
■birds'
"fly*
"but"
•fish"
-swim"
Сложности еще не закончились. Если вы не уверены, что все правильно поняли,
то вернитесь и перечитайте раздел 6.4 с самого начала. Возможно, при втором чте-
нии вы поймете, о чем идет речь!
6.4.2. Запись грамматики
Как выбираются грамматические правила для разбора указанных выше выраже-
ний? Самым честным ответом является "опыт". Способ, который мы применили,
просто повторяет способ, с помощью которого люди обычно записывают граммати-
ки. Однако запись грамматики совершенно очевидна: нам необходимо лишь сделать
следующее.
1. Отличать правило от лексемы.
2. Записывать правила одно за другим (последовательно).
3. Выражать альтернативные варианты (разветвление).
4. Выражать повторяющиеся варианты (повторение).
5. Распознавать начальное правило.
В разных учебниках и системах грамматического разбора используются разные
соглашения и терминология. Например, иногда лексемы называют терминалами
(terminals), а правила — нетерминалами (non-terminals), или продукциями (productions).
Мы просто заключаем лексемы в двойные кавычки и начинаем с первого правила.
Альтернативы выражаются с помощью линий. Рассмотрим пример.
Список:
■{" Последовательность п}п6.5 ПРЕВРАЩЕНИЕ ГРАММАТИКИ В ПРОГРАММУ
223
Последов ательность:
Элемент
Элемент п ,п Последовательность
Элемент:
"А"
••В"
Итак, Последовательность — это Элемент или Элемент, за которым следует
разделяющая запятая и другая Последовательность. Элемент — это либо буква А,
либо в. Список — это Последовательность в фигурных скобках. Можно сгенери-
ровать следующие Списки (как?):
{ А }
{ В }
{ А,В }
{А,А,А,А,В }
Однако то, что перечислено ниже, списком не является (почему?):
{ }
А
{ А/А/А/А/В
{А,А,С,А,В }
{ А В С }
{А,А,А,А,В, }
Этим правилам вас в детском садике не учили, и в вашем мозге они не "встроены",
но понять их не сложно. Примеры их использования для вьфажения синтаксических
идей можно найти в разделах 7.4 и 7.8.1.
6.5. Превращение грамматики в программу
Существует много способов заставить компьютер следовать грамматическим
правилам. Мы используем простейший из них: напишем функцию для каждого
грамматического правила, а для представления лексем применим класс Token. Про-
грамму, реализующую грамматику, часто называют программой грамматического
разбора (parser).
6.5.1. Реализация грамматических правил
Для реализации калькулятора нам нужны четыре функции: одна — для считыва-
ния лексем и по одной для каждого грамматического правила.
get_token() // считывает символы и составляет лексемы
// использует поток cin
expression() // реализует операции + и -
// вызывает функции term() и get_token()
term() // реализует операции *, / и %
// вызывает функции primary () и get__token()
primary() // реализует числа и скобки
// вызывает функции expression {) и get_token{>224
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
^rv Примечание: каждая функция обрабатывает отдельные части выражения,
==] оставляя все остальное другим функциям; это позволяет радикально упро-
стить каждую функцию. Такая ситуация напоминает группу людей, пытаю-
щихся решить задачу, разделив ее на части и поручив решение отдельных подзадач
каждому из членов группы.
Что же эти функции должны делать в действительности? Каждая из них должна
вызывать другие грамматические функции в соответствии с грамматическим прави-
лом, которое она реализует, а также функцию gettokenO, если в правиле упоми-
нается лексема. Например, когда функция primary () пытается следовать правилу
(Выражение), она должна вызвать следующие функции-
get_tokenO // чтобы обработать скобки ( и )
expression() // чтобы обработать Выражение
Что должен возвращать такой грамматический анализатор? Может быть, реаль-
ный результат вычислений? Например, для выражения 2+3 функция expression()
должна была бы возвращать 5. Теперь понятно! Именно это мы и должны сделать!
Поступая таким образом, мы избегаем ответа на один из труднейших вопросов:
"Как представить выражение 45+5/7 в виде данных, чтобы его можно было вычис-
лить?" Вместо того чтобы хранить представление этого выражения в памяти, мы
просто вычисляем его по мере считывания входных данных. Эта простая идея ко-
ренным образом изменяет ситуацию! Она позволяет в четыре раза уменьшить раз-
мер программы по сравнению с вариантом, в котором функция expression () воз-
вращает что-то сложное для последующего вычисления. Таким образом, мы сэко-
номим около 80% объема работы.
Функция gettokenO стоит особняком: поскольку она обрабатывает лексемы,
а не выражения, она не может возвращать значения подвыражений. Например, +
и ( — это не выражения. Таким образом, функция gettoken () должна возвращать
объект класса Token.
// функции, подчиняющиеся грамматическим правилам
Token get_token() // считывает символы и составляет лексемы
double expression О // реализует операции + и -
double term() // реализует операции *, и %
double primary() // реализует числа и скобки
6.5.2. Выражения
Сначала напишем функцию expression (). Грамматическое правило Выражение
выглядит следующим образом:
Выражение:
Терм
Выражение '+' Терм
Выражение '-' Терм
Поскольку это первая попытка реализовать грамматиче к в 1Ло в ви е про-
граммного кода, продемонстрируем неск лько н ip в л ьх п ьток В каждой6 5 ПРЕВРАЩЕНИЕ ГРАММАТИКИ В ПРОГРАММУ
225
из н IX мы покажем отдельный метод и по ходу дела научимся полезным вещам.
В частности, новичок может многое узнать, обнаружив, что одинаковые фрагменты
кода могут вести себя совершенно по-разному. Чтение программного кода —
это полезный навык, который следует культивировать.
6.5.2.1 Выражения: первая попытка
Посмотрев на правило Выражение ■ + ■ Терм, сначала попытаемся вызвать функ-
цию expression (), поищем операцию + (и -), а затем вызовем функцию term().
double expression()
double left = expression() ; // считываем и вычисляем Выражение
Token t = gettokenO; // получаем следующую лексему
switch (t.kind) { // определяем вид лексемы
case ' + *:
return left + term() ; // считываем и вычисляем Терм,
// затем выполняем сложение
case '-':
return left - term() ; // считываем и вычисляем Терм,
// затем выполняем вычитание
default:
return left; // возвращаем значение Выражения
}
}
Программа выглядит неплохо. Это почти тривиальная транскрипция граммати-
ки. Она довольно проста: сначала считываем Выражение, а затем проверяем, следу-
ет ли за ним символ + или -, и в случае положительного ответа считываем Терм.
К сожалению, на самом деле этот программный код содержит мало смысла.
Как узнать, где кончается выражение, чтобы искать символ + или -? Напомним, что
наша программа считывает символы слева направо и не может заглянуть вперед,
чтобы узнать, нет ли там символа +. Фактически данный вариант функции
expression О никогда не продвинется дальше своей первой строки: функция
expression () начинает работу с вызова функции expression О, которая, в свою
очередь, начинается с вызова функции expression (), и так до бесконечности. Этот
процесс называется бесконечной рекурсией, но на самом деле он довольно быстро
заканчивается, исчерпав память компьютера. Термин рекурсия используется для
описания процесса, который выполняется, когда функция вызывает саму себя. Не
любая рекурсия является бесконечной; рекурсия является очень полезным методом
программирования (см. раздел 8.5.8).
6.5.2.2. Выражения: вторая попытка
Итак, что же мы делаем? Каждый Терм является Выражением, но не любое Выра-
жение является Термом; иначе говоря, можно начать поиск с Терма и переходить к
поиску полного Выражения, только обнаружив символ + или -. Рассмотрим пример.
double expression()226
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
{
double left я Term О ; // считываем и вычисляем Терм
Token t ■ get_token(); // получаем следующую лексему
switch (t.kind) { // определяем вид лексемы
case ' + *:
return left + expression(); // считываем и вычисляем
// Выражение, затем
// выполняем сложение
case ' -' :
return left - expression(); // считываем и вычисляем
// Выражение, затем
// выполняем вычитание
default:
return left; // возвращаем значение Терма
}
}
Этот программный код действительно — более или менее — работает. Мы вклю-
чим его в окончательный вариант программы для грамматического разбора правиль-
ных выражений и отбраковки неправильных. Он позволяет правильно вычислить
большинство выражений. Например, вьфажение 1+2 считывается как Терм (имеющий
значение 1), за которым следует символ +_, а за ним — Вьфажение (которое оказыва-
ется Термом, имеющим значение 2). В итоге получаем ответ, равный 3. Аналогично,
вьфажение 1+2+3 дает ответ 6. Можно было бы много говорить о том, что эта про-
грамма делает хорошо, но мы сразу поставим вопрос ребром: а чему равно выражение
1-2-3? Функция expression О считает число 1 как Терм, затем переходит к считы-
ванию 2-3 как Выражения (состоящего их Терма 2, за которым следует Выражение
3). Таким образом, из 1 будет вычтено значение выражения 2-3. Иначе говоря, про-
грамма вычисляет выражение 1-(2-3). Оно равно 2. Однако мы еще со школьной
скамьи знаем, что выражение 1-2-3 означает (1-2) -3 и, следовательно, равно -4.
0Итак, мы написали превосходную программу, которая выполняет вычисления
неправильно. Это опасно. Это особенно опасно, поскольку во многих случаях
программа дает правильный ответ. Например, выражение 1+2+3 будет вычис-
лено правильно (б), так как 1+ (2+3) эквивалентно (1+2) +3.
Что же мы сделали неправильно с точки зрения программирования? Этот вопрос
следует задавать себе каждый раз, когда обнаружите ошибку. Именно так мы можем
избежать повторения одних и тех же ошибок. По существу, мы просто просмотрели
программный код и угадали правильное решение. Это редко срабатывает! Мы долж-
ны понять, как работает программа, и объяснить, почему она работает правильно.
Анализ ошибок — часто лучший способ найти правильное решение. В данном
случае функция expression О сначала искала Терм, а затем, если за Термом следо-
вал символ + или -, искала Выражение. На самом деле функция реализовала немно-
го другую грамматику.
Выражение:6 5. ПРЕВРАЩЕНИЕ ГРАММАТИКИ В ПРОГРАММУ
227
Терм
Терм •+• Выражение // сложение
Терм •-• Выражение // вычитание
Отличие от нашей грамматики заключается именно в том, что выражение 1-2-з
должно трактоваться как Выражение 1-2, за которым следует символ -и Терм 3,
а на самом деле функция интерпретирует выражение 1-2-3 как Терм 1, за которым
следует символ - и Выражение 2-3. Иначе говоря, мы хотели, чтобы выражение
1-2-3 было эквивалентно (1-2)-3, а не 1-(2-3).
Да, отладка утомительна, скучна и требует много времени, но в данном случае
мы действительно работаем с правилами, известными со школьной скамьи, и не
должны испытывать больших затруднений. Проблема заключается лишь в том, что-
бы научить этим правилам компьютер, а он учится намного медленнее нас.
Обратите внимание на то, что мы могли бы определить выражение 1-2-3 как
1-(2-3), а не 1-2 )-з и вообще избежать этой дискуссии. Довольно часто самые
трудные программистские проблемы возникают тогда, когда мы работаем с при-
вычными для людей правилами, которые изобрели задолго до компьютеров.
6.5.2.3. Выражения: третья попытка (удачная)
Итак, что теперь? Еще раз взгляните на грамматику (правильная грамматика
приведена в разделе 6.5.2): любое Выражение начинается с Терма, за которым мо-
жет следовать символ + или -. Следовательно, мы должны найти Терм, проверить,
следует ли за ним символ + или -, и делать это, пока символы "плюс" и "минус"
не закончатся. Рассмотрим пример.
double expression()
{
double left « term(); // считываем и вычисляем Терм
Token t = get_token(); // получаем следующую лексему
while ( t.kind==, + « || t.kind=*»-«) { // ищем + или -
if (t.kind == •+•)
left += term(); // вычисляем Терм и добавляем его
else
left -я term(); // вычисляем Терм и вычитаем его
t * get_token() ;
>
return left; // финал: символов + и - нет; возвращаем ответ
>
Этот вариант немного сложнее: мы ввели цикл для поиска символов + и -. Кроме
того, дважды повторили проверку символов + и -, а также дважды вызвали функ-
цию get_token(). Поскольку это запутывает логику кода, просто продублируем
проверку символов + и -.
double expressionО
double left - termO; // считываем и вычисляем Терм228 ГЛАВА б • СОЗДАНИЕ ПРОГРАММ
Token t ■ get_token(); // получаем следующую лексему
while(true) {
switch(t.kind) {
case •+':
left +s termО; // вычисляем Терм и добавляем его
t ■ get_token();
break;
case '-':
left -s term О; // вычисляем Терм и вычитаем его
t ■ get_token();
break;
default:
return left; // финал: символов + и - нет;
// возвращаем ответ
}
}
>
Обратите внимание на то, что — за исключением цикла — этот вариант напоми-
нает первый (см. раздел 6.5.2.1). Мы просто удалили вызов функции expression ()
в функции expression () и заменили его циклом. Другими словами, перевели Вы-
ражение в грамматическом правиле в цикл поиска Терма, за которым следует сим-
вол + или -.
6.5.3. Термы
Грамматическое правило для Терма очень похоже на правило для Выражения.
Терм:
Первичное выражение
Терм •*' Первичное выражение
Терм •/' Первичное выражение
Терм '%' Первичное выражение
Следовательно, программный код также должен быть похож на код для Выраже-
ния. Вот как выглядит его первый вариант:
double term О
{
double left = primary();
Token t = gettoken();
while(true) {
switch (t.kind) {
case •*' :
left *= primaryt);
t = get_token() ;
break;
case '/•:
left /= primaryO;
t = gettoken();
break;
case '%':
left %= primaryO;6 5 ПРЕВРАЩЕНИЕ ГРАММАТИКИ В ПРОГРАММУ
229
t = get_token();
break;
default:
return left;
}
}
}
0K сожалению, этот код не компилируется: операция вычисления остатка (%) для
чисел с плавающей точкой не определена. Компилятор вежливо предупредит нас
об этом. Когда мы утвердительно ответили на вопрос 5 — "Следует ли позво-
лить ввод чисел с плавающей точкой?",— мы не думали о таких последствиях
и просто поддались искушению добавить в программу дополнительные возможности.
Вот так всегда! Что же делать? Можно во время выполнения программы проверить,
являются ли оба операнда операции % целыми числами, и сообщить об ошибке, если
это не так. А можно просто исключить операцию % из возможностей нашего кальку-
лятора. Эту функцию всегда можно добавить позднее (см. раздел 7.5). Исключив опе-
рацию %, получим вполне работоспособную функцию: термы правильно распознаются
и вычисляются. Однако опытный программист заметит нежелательную деталь, кото-
рая делает функцию term () неприемлемой. Что произойдет, если ввести выражение
2/0? На нуль делить нельзя. Если попытаться это сделать, то аппаратное обеспечение
компьютера обнаружит это и прекратит выполнение программы, выдав сообщение об
ошибке. Неопытный программист обязательно столкнется с этой проблемой. По этой
причине лучше провести проверку и выдать подходящее сообщение.
double term ()
{
double left = primaryO;
Token t = get_token();
while(true) {
switch (t.kind) {
case •*':
left *= primaryO;
t = gettokenO ;
break;
case '/•:
{ double d = primaryO;
if (d == 0) error("деление на нуль");
left /= d;
t = gettokenO ;
break;
}
default:
return left;
}
}
}230
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Почему мы поместили обработку операции / внутри блока? На этом настоял
компилятор. Если мы хотим определить и инициализировать переменные в опера-
торе switch, то должны поместить ее в блоке.
6.5.4. Первичные выражения
Грамматическое правило для первичных выражений также простое.
Первичное выражение:
Число
1(' Выражение ') '
Программный код, реализующий это правило, немного сложен, поэтому он
открывает больше возможностей для синтаксических ошибок.
double primary О
{
Token t ■ get_token();
switch (t.kind) {
case f (': // обработка варианта ' (' выражение ') '
{ double d в expression();
t я get_token();
if (t.kind 1= ')') error(n')' expected");
return d;
}
case ' в1? // используем '8' для представления числа
return t.value; // возвращаем значение числа
default:
error("ожидается первичное выражение");
}
}
По сравнению с функциями expression () и term() в этом программном коде
нет ничего нового. В нем используются те же самые языковые конструкции и мето-
ды, и объекты класса Token обрабатываются точно так же.
6.6. Испытание первой версии
Для того чтобы выполнить эти функции калькулятора, необходимо реализовать
функции get_token() и mainQ. Функция main() тривиальна: мы просто вызыва-
ем функцию expression О и выводим результат на печать.
int main ()
try {
while (cin)
cout << expression() << '\n';
keep_window_open();
catch (exceptionfc e) {
cerr << e.what О << endl;
keep_window_open О;
return 1;6 6. ИСПЫТАНИЕ ПЕРВОЙ ВЕРСИИ 231
}
catch (...) {
cerr << "exception \nn;
keep_window_open О;
return 2;
}
Обработка ошибок представляет собой обычный шаблон (см. раздел 5.6.3).
Отложим реализацию функции get_token() до раздела 6.8 и протестируем эту
первую версию калькулятора.
Я ПОПРОБУЙТЕ
Первая версия программы, имитирующей работу калькулятора (включая функцию
gettoken ()), содержится в файле calculatorOO .cpp. Запустите его и испытайте.
Нет ничего удивительного в том, что эта первая версия калькулятора работает
не совсем так, как мы ожидали. Мы пожимаем плечами и спрашиваем себя: *Тючему?",
или "Почему программа работает так, а не иначе?", или "Что же она делает?" Введите
число 2 и символ перехода на новую строку. Ответа вы не получите! Введите символ
перехода на новую строку еще раз, чтобы убедиться, что компьютер не завис. Ответа
по-прежнему нет. Введите число 3 и символ перехода на новую строку. Ответа нет!
Введите число 4 и символ перехода на новую строку. Ответ равен 2! Теперь экран вы-
глядит так:
2
3
4
2
Введем выражение 5+6. Ответ равен 5, а экран выглядит так:
2
3
4
2
5+6
5
Несмотря на свой опыт, скорее всего, вы будете сильно озадачены? Даже опыт-
ный программист будет озадачен таким поведением программы. Что происходит?
В этот момент попробуйте выйти из программы. Как это сделать? Мы "забыли" ука-
зать в программе команду выхода, но прекращение работы может спровоцировать
ошибка, поэтому введите символ х, и программа в ответ выведет на экран фразу Не*
правильная лексема и закончит работу. Наконец-то хоть что-то работает» как за-
планировано!232
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Однако мы забыли провести различие между вводом и выводом на экран. Преж-
де чем перейти к решению основной задачи, давайте исправим вывод, чтобы экран
лучше отражал то, что мы делаем. Добавим символ =, чтобы отметить результат.
while (cin) cout << п = п << expression() << '\n'; // версия 1
Теперь введем ту же самую последовательность символов, что и раньше. На экране
появится следующее:
2
3
4
= 2
5 + 6
= 5
х
Bad token.
Странно! Попробуйте понять, почему программа делает это. Мы попробовали
еще несколько примеров. Только посмотрите на эту головоломку!
• Почему программа реагирует после ввода символов 2 и 3 и ввода символа
перехода на новую строку?
• Почему после ввода числа 4 программа выводит на экран число 2, а не 4?
• Почему при вычислении выражения 5+6+7 программа выводит число 5, а не 11?
Существует множество способов получить такие загадочные результаты. Неко-
торые из них мы проверим в следующей главе, а пока просто подумаем. Может ли
программа руководствоваться неверной арифметикой? Это крайне маловероятно:
значение 4 не может быть равным 2, а 5+6 равно 11, а не 5. Попробуем разобраться,
что происходит, когда мы вводим символы 1 2 3 4+5 6+7 8+9 10 11 12 и сим-
вол перехода на новую строку.
12 3 4+5 6+7 8+9 10 11 12
= 1
= 4
= б
= 8
= 10
Что? Ни 2, ни 3. Почему число 4 в выводе есть, а числа 9 нет (т.е. 4+5)? Почему
среди результатов есть число б и нет числа 13 (т.е. 6+7)?
Хорошенько подумайте: программа выводит каждую третью лексему! Может
быть, программа "съедает" часть входной информации без вычислений*? Похоже
на это. Проанализируем функцию expression ().
double expression()
{6 6. ИСПЫТАНИЕ ПЕРВОЙ ВЕРСИИ 233
double left = term() ; // считываем и вычисляем Терм
Token t = get_token(); // получаем следующую лексему
while(true) {
switch(t.kind) {
case '+':
left += term О ; // вычисляем и добавляем Term
t = get token();
break;
case •-•:
left -= term О ; // вычисляем и вычитаем Терм
t = gettokenO ;
break;
default:
return left; // финал: символов + и - нет;
// возвращаем ответ
}
}
}
Если объект класса Token, возвращаемый функцией gettoken (), не равен ' +'
или • - •, выполняем оператор return. Мы не используем этот объект и не храним
его в памяти для использования в других функциях. Это не умно. Отбрасывание
входной информации без анализа недальновидно. Беглый анализ показывает, что
функции term () присущ такой же недостаток. Это объясняет, почему наш кальку-
лятор "съедает" по две лексемы после одной использованной.
Модифицируем функцию expression () так, чтобы она не "съедала" лексемы.
Куда поместить следующую лексему (t), если программа никак не использует ее?
Можно рассмотреть много сложных схем, но давайте просто перейдем к очевидно-
му ответу (его очевидность станет ясной позднее): поскольку лексема будет исполь-
зована другой функцией, которая будет считывать ее из потока ввода, давайте вер-
нем лексему обратно в поток ввода, чтобы ее могла считать другая функция! Дейст-
вительно, мы можем вернуть символ обратно в поток ввода, но это не совсем то, что
мы хотим. Мы хотим работать с лексемами, а не возиться с символами. Итак, хоте-
лось бы, чтобы поток ввода работал с лексемам, а мы имели бы возможность запи-
сывать в него уже считанные лексемы.
Предположим, в нашем распоряжении есть поток лексем — "Tokenstream" —
с именем ts. Допустим также, что поток Tokenstream имеет функцию-член
get (), возвращающую следующую лексему, и функцию-член putback(t), возвра-
щающую лексему t обратно в поток.
Мы реализуем класс Tokenstream в разделе 6.8, как только увидим, как его
следует использовать. Имея поток Tokenstream, можем переписать функцию
expression О так, чтобы она записывала неиспользованную лексему обратно
в поток Tokenstream.
double expression()
{234
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
double left в termO; // считываем и вычисляем Терм
Token t я ts.getO; // получаем следующую лексему
// из потока лексем
while(true) {
switch(t.kind) {
case '+':
left +■ termО; // вычисляем и добавляем Терм
t = ts.getO ;
break;
case '-':
left -* term О ; // вычисляем и вычитаем Терм
t = ts.getO ;
break;
default:
ts.putback(t); // помещает объект t обратно
// в поток лексем
return left; // финал: символов + и - нет;
// возвращаем ответ
}
}
}
Кроме того, такие же изменения следует внести в функцию term ().
double term ()
{
double left = primary О;
Token t = ts.getO; // получаем следующую лексему
// из потока лексем
while(true) {
switch (t.kind) {
case •*':
left *= primary();
t = ts.getO ;
break;
case '/':
{
double d = primary();
if (d == 0) error("деление на нуль");
left /= d;
t = ts.getO ;
break;
}
default:
ts.putback(t); // помещает объект t обратно в поток лексем
return left;
>
>
}
Для последней функции программы грамматического анализа primary () достаточно
заменить функцию gettoken () функцией ts .get (); функция primary () использует
каждую лексему, которую она считывает.6 7 ИСПЫТАНИЕ ВТОРОЙ ВЕРСИИ
235
6.7. Испытание второй версии
Итак, мы готовы к испытанию второй версии. Введем число 2 и символ перехода
на новую строку. Нет ответа. Попробуйте ввести еще один символ перехода на но-
вую строку, чтобы убедиться, что компьютер не завис. По-прежнему нет ответа.
Введите число 3 и символ перехода на новую строку. Ответ равен 2. Попробуйте
ввести выражение 2+2 и символ перехода на новую строку. Ответ равен 3. Экран
выглядит следующим образом:
2
з
=2
2+2
=3
Хм... Может быть, наша функция putbackO и ее использование в функции
expression () и term () не решает проблему. Попробуем другой тест.
2 3 4 2+3 2*3
= 2
= 3
= 4
= 5
Да! Это правильные ответы! Но последний ответ (б) пропущен. Проблема сле-
дующей лексемы не решена. Однако на этот раз она заключается не в том, что наш
программный код "съедает" символы, а в том, что он вообще не получает информа-
ции, пока не будет введено следующее выражение. Результат вычисления выраже-
ния не выводится на экран немедленно; он откладывается до тех пор, пока про-
грамма не увидит первую лексему следующего выражения. К сожалению, програм-
ма не видит эту лексему, пока мы не нажмем клавишу <Enter> после следующего
выражения. Эта программа на самом деле не настолько плоха, она просто немного
медленно реагирует.
Как исправить этот недостаток? Очевидное решение — потребовать немедленно
выполнить вывод. Договоримся считать, что каждое выражение завершается точкой
с запятой, которая одновременно служит триггером вывода. Кроме того, добавим
в программу команду выхода. Для этого подходит символ q (первая буква слова
quit (выход)). Функция main () содержит инструкцию
while (cin) cout << п = п << expression() << ' \n'; // version 1
Заменим ее более запутанной, но более полезной инструкцией.
double val = 0;
while (cin) {
Token t ■ ts.getO;
if (t.kind ss «q») break; // * q' для выхода236 ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
if (t.kind w ';') // ';' для команды "печатать немедленно"
cout « в = " « val « '\п';
else
ta.putback(t);
val * expression();
}
Теперь калькулятор действительно можно использовать. Рассмотрим пример.
2;
* 2
2+3;
* 5
3+4*5;
= 23
q
В данный момент мы имеем хорошую начальную версию калькулятора. Она де-
лает еще не совсем то, что мы хотели, но на ее основе программу можно усовер-
шенствовать. Следует отметить, что теперь мы можем устранять недостатки один
за другим, сохраняя работоспособность программы.
6.8. Потоки лексем
Прежде чем далее улучшать наш калькулятор, продемонстрируем реализацию
класса TokenStream. В конце концов, программа никогда не сможет правильно
работать, если данные вводятся некорректно. Несмотря на то что мы реализуем
класс TokenStream в первую очередь, нам не хотелось бы далеко отклоняться
от основной темы, пока не сможем получить минимальное решение задачи.
Входной информацией для нашего калькулятора является последовательность лек-
сем, как было показано выше на примере выражения (1.5+4)* 11 (см. раздел 6.5.1).
Нам лишь нужна функция, считывающая символы из стандартного потока с in и вво-
дящая в программу следующую лексему по запросу. Кроме того, мы видели, что наша
программа часто считывает слишком много лексем, поэтому необходимо как-то воз-
вращать их обратно, чтобы использовать в дальнейшем. Эта ситуация очень типична.
Допустим, мы считываем выражение 1.5+4 слева направо. Как убедиться, что число
1.5 считано полностью, а символ + — нет. Пока мы не увидим символ +, можем счи-
тывать число 1.55555. Таким образом, нам нужен поток, порождающий лексему при
вызове функции get (), и возможность возвращать лексему обратно в поток при вы-
зове функции putback (). Все сущности в языке C++ имеют тип, поэтому необходимо
определить тип TokenStream.
Возможно, вы заметили ключевое слово public в определении класса Token,
приведенном выше. В том случае для его использования не было очевидных при-
чин. Однако при определении класса Tokenstream мы должны применить его
и объяснить его предназначение. В языке C++ тип, определенный пользователем,
часто состоит из двух частей: открытого интерфейса (помеченного как public:)6 8. ПОТОКИ ЛЕКСЕМ
237
и реализации деталей типа (помеченной как private:). Идея заключается в том,
чтобы отделить то, что пользователю необходимо для удобства, от деталей реализа-
ции типа, в которые пользователю вникать не обязательно.
class Token_stream {
public:
// пользовательский интерфейс
private:
// детали реализации
// (скрывается от пользователей класса Token_stream)
Очевидно, что пользователи и разработчики исполняют разные роли, но раз-
деление (открытого) интерфейса, предназначенного для пользователей, от
(закрытых) деталей реализации, используемых только разработчиками, пред-
ставляет собой мощное средство структурирования программного кода. Открытый
интерфейс должен содержать только средства, необходимые пользователю, вклю-
чая конструкторы для инициализации объектов. Закрытая реализация содержит
только то, что необходимо для реализации открытых функций, как правило, данные
и функции, связанные с массой деталей, о которых пользователю незачем знать, по-
скольку он их не использует непосредственно.
Приступим к разработке типа Token_stream. Что пользователь ждет от него?
Очевидно, что нам нужны функции get () и putback ()— именно поэтому мы вве-
ли понятие потока лексем. Класс Token_stream должен создавать объекты класса
Token из символов, считанных из потока ввода, поэтому нам необходима возмож-
ность создавать объекты класса Tokenstream, способные считывать данные из по-
тока с in. Таким образом, простейший вариант класса Tokenstream выглядит
примерно так:
class Token_stream {
public:
TokenstreamO ; // создает объект класса Token_stream,
// считывающий данные из потока cin
Token get О; // получает объект класса Token
void putback(Token t); // возвращает объект класса Token
// обратно
private:
// детали реализации
ъ
Это все, что требуется от пользователя для использования объектов класса
Token_stream. Опытные программисты могут поинтересоваться, почему поток cin
является единственным возможным источником символов,— просто мы решили
вводить символы с клавиатуры. Это решение можно пересмотреть в упражнений,
приведенном в главе 7.
Почему мы использовали "длинное" имя putback(), а не логичное имя put О?
Тем самым мы подчеркнули асимметрию между функциями get О и putback О;
0238 ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
мы возвращаем лексему в поток ввода, а не вставляем ее в поток вывода. Кроме
того, функция putbackO есть в классе istream: непротиворечивость имен — полез-
ное свойство. Это позволяет людям запоминать имена функций и избегать ошибок.
Теперь можем создать класс Tokenstream и использовать его.
Token_stream ts; // объект класса Token_stream с именем ts
Token t = ts.getO; // получаем следующий объект класса Token из
объекта ts
// . . .
ts.putback(t); // возвращает объект t класса Token обратно в объект ts
Это все, что нам нужно, чтобы закончить разработку калькулятора.
6.8.1. Реализация класса Token_stream
Теперь необходимо реализовать три функции класса Tokenstream. Как пред-
ставить класс Tokenstream? Иначе говоря, какие данные необходимо хранить
в объекте класса Tokenstream, чтобы он мог выполнить свое задание? Необходи-
ма память для лексемы, которая будет возвращена обратно в объект класса
Tokenstream. Для простоты будем считать, что лексемы возвращаются в поток по
одной. Этого вполне достаточно для нашей программы (а также для очень многих
аналогичных программ). Таким образом, нужна память для одного объекта класса
Token и индикатор ее занятости.
class Token_stream {
public:
Token_stream(); /I создает объект класса Token_stream/
// считывающий данные из потока cin
Token get О; // получает объект класса Token
// (функция get() определена в другом месте)
void putback(Token t); // возвращает объект класса Token
// обратно
private:
bool full; // находится ли в буфере объект класса Token?
Token buffer; // здесь хранится объект класса Token,
// возвращаемый в поток функцией putbackO
};
Теперь можно определить (написать) три функции-члена. Конструктор и функ-
ция putback () никаких трудностей не вызывают, поскольку они невелики. Мы оп-
ределим их в первую очередь. Конструктор просто устанавливает настройки, свиде-
тельствующие о том, что буфер пуст.
Token_stream::Tokenstream ()
:full(false), buffer(O) // в буфере нет ни одного объекта
класса Token
{
}
Определяя функцию-член вне определения самого класса, мы должны указать,
какому классу она принадлежит. Для этого используется обозначение имякласса
:: имяфункциичлена. В данном случае нам необходимо определить конструктор6 8 ПОТОКИ ЛЕКСЕМ
239
класса Token_stream. Конструктор— это член класса, имя которого совпадает
с именем класса.
Почему мы определяем функцию-член вне определения класса? Ответ очевиден:
определение класса (в основном) описывает, что класс может делать. Определения
функций-членов представляют собой реализации, которые уточняют, как именно
класс выполняет то, для чего он предназначен. Мы предпочитаем размещать эти де-
тали там, где они не отвлекают внимание от главного. В идеале на экране должна
отразиться каждая логическая единица программы. Определение класса обычно
удовлетворяет этому требованию, если его функции-члены определены в другом
месте, а не в классе.
Члены класса инициализированы в списке инициализации (см. раздел 6.3.3); вы-
ражение full (false) устанавливает член класса Tokenstream с именем full
равным значению false, а вьфажение buffer(0) инициализирует член buffer
пустой лексемой, которую мы специально для этого изобрели. Определение класса
Token (см. раздел 6.3.3) утверждает, что каждый объект класса Token должен иметь
начальное значение, поэтому мы не можем просто проигнорировать член Token_
stream: :buf f er.
Функция-член putback () возвращает аргументы обратно в буфер объекта клас-
са Token_stream.
void Token_strearn::putback(Token t)
{
buffer = t; // копируем объект t в буфер
full я true; // теперь буфер полон
}
Ключевое слово void (означающее "ничто") означает, что функция putback О
не возвращает никакого значения. Если бы мы хотели гарантировать, что эта функ-
ция не будет использована дважды без считывания лексем, возвращенных в проме-
жутке между ее вызовами (с помощью функции get О), то нам следовало бы доба-
вить проверку.
void Tokenstrearn::putback(Token t)
{
if (full) error("putback() в полный буфер");
buffer « t; // копируем объект t в буфер
full a true; // буфер теперь полон
}
Проверка переменной full соответствует проверке предусловия "В буфере нет
ни одного объекта класса Token*'.
6.8.2. Считывание лексем
Всю реальную работу выполняет функция get(). Если в переменной Token_
stream: t buffer еще нет ни одного объекта класса Token, to функция get О
должна считать символы из потока с in и составить из них объект класса Token.240
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Token Token_strearn::get()
{
if (full) { // если в буфере есть лексема,
// удаляем ее оттуда
fullsfalse;
return buffer;
}
char ch;
cin » ch; // обратите внимание на то, что оператор >>
// пропускает разделители (пробелы, символы перехода
// на новую строку, символы табуляции и т.д.)
switch (ch) {
case *;': // для печати
case 'q': // для выхода
case f (': case ')'* case ' + ': case '-': case '*': case '/':
case '%':
return Token(ch); // пусть каждый символ
// представляет себя сам
case '.':
case '0': case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case '9':
{ cin.putback(ch); // возвращаем цифру обратно в поток ввода
double val;
cin >> val; // считываем число с плавающей точкой
return Token('8',val); // пусть символ '8' означает "число"
}
default:
error("Неправильная лексема");
}
}
Детально рассмотрим функцию get(). Сначала проверим, есть ли в буфере
объект класса Token. Если есть, то мы просто вернем его.
if (full) { // если в буфере есть лексема,
// удаляем ее оттуда
full=false;
return buffer;
}
Только если переменная full равна false (т.е. в буфере нет лексем), нам при-
дется иметь дело с символами. В данном случае считываем символ и соответст-
вующим образом обрабатываем его. Мы распознаем скобки, операторы и числа.
Любой другой символ становится причиной вызова функции error (), которая пре-
кращает выполнение программы.
default:
error("Неправильная лексема");
Функция error () описана в разделе 5.6.3 и находится в заголовочном файле
std lib facilities.h.6 8 ПОТОКИ ЛЕКСЕМ
241
Необходимо решить, как представлять разные виды лексем, т.е. выбрать значе-
ния, идентифицирующие вид члена. Для простоты отладки мы решили обозначать
скобки и операторы соответствующими им символами.
Это позволяет чрезвычайно просто обрабатывать скобки и операторы.
case '(': case ')': case ' + ': case '-': case '*': case '/':
return Token(ch) ; // пусть каждый символ представляет себя сам
Честно говоря, мы "забыли" точку с запятой, ■;', для вывода и букву q в первой
версии. Мы не будем добавлять их, пока в них не возникнет потребность во второй
версии.
6.8.3. Считывание чисел
Осталось обработать числа. На самом деле это не просто. Действительно, как уз-
нать значения числа 123? Хорошо, оно равно 100+20+3. А что вы скажете о числе
12.34? Следует ли принять научную систему обозначения, такую как 12.34е5? Мы
могли бы провести часы и дни, решая эту задачу, но, к счастью, это не обязательно.
Потоки ввода в языке C++ распознают литералы и сами умеют переводить их в тип
double. Все, что нам нужно, — как-то заставить поток с in сделать это в функции
get().
case • . ' :
case '0': case ' 1': case '2': case '3': case '41: case '5': case
•6': case '7 • :
case '8'tease •9' :
{ cin.putback(ch); // возвращаем цифру в поток ввода
double val;
cin >> val; // считываем число с плавающей точкой
return Token ('8 ' , val) ; // пусть символ '8' обозначает "число"
}
Мы в некотором смысле произвольно решили, что символ • 8 • будет представ-
лять число в классе Token. Как узнать, что на вход поступило число? Хорошо, зная
по опыту или изучая справочник по языку C++ (например, в приложении А), можно
установить, что числовой литерал должен начинаться с цифры или символа •. •
(десятичной точки). Итак, этот факт следует проверить. Далее, мы хотим, чтобы по-
ток cin считывал число, но мы уже считали первый символ (цифру или десятичную
точку), поэтому пропуск оставшейся части лексемы приведет к ошибке. Можно по-
пытаться скомбинировать значение первого символа со значением оставшейся час-
ти; например, если некто ввел число 123, можем взять число 1, а поток cin считает
число 23, и нам останется лишь сложить 100 и 23. Это тривиальный случай.
К счастью (и не случайно), поток cin работает точно так же, как поток Token_
stream, в том смысле, что мы можем вернуть в него символ обратно. Итак, вместо
того чтобы выполнять сложные арифметические действия, мы возвращаем первый
символ обратно в поток cin и позволяем ему считать все число.242 ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Пожалуйста, обратите внимание на то, как мы снова и снова избегаем слож-
ностей и вместо этого находим простые решения, часто полагаясь на библио-
теки. В этом заключается смысл программирования: постоянно искать про-
стые решения. Иногда в шутку говорят: "Хороший программист — ленивый про-
граммист". Это означает, что мы должны быть ленивыми (в хорошем смысле): за-
чем писать длинную программу, если можно написать короткую?
6.9. Структура программы
Как утверждает пословица, за деревьями трудно увидеть лес. Аналогично, легко
потерять смысл программы, просматривая все ее функции, классы и т.д. Давайте
рассмотрим программу, пропуская ее детали.
«include ■etdlibfacilities.h"
class Token {/*...*/}»
class Token_stream {/*...*/};
Token_stream::Token_stream() :full(false), buffer(O) {/*...*/
void Token_strearn::putback(Token t) { /* . . . */ }
Token Tokenstrearn::get() { /* . . . */ }
Token_stream ts; // содержит функции get О и putback()
double expression() ; // объявление, позволяющее функции primary О
// вызывать функцию expression()
double primary О {/*•••*/} // обрабатывает числа и скобки
double term() {/*•••*/} // обрабатывает операции *, / и %
double expression О { /* . . •*/}// обрабатывает операции + и -
int main() { /* . . •*/}// основной цикл и обработка ошибок
Порядок следования объявлений важен. Мы не можем использовать имя, пока
оно не объявлено, поэтому объект ts должен быть объявлен до того, как будет
вызвана функция ts.getO, а функция error () должна быть объявлена до
функций грамматического анализа, поскольку они используют ее. В графе вызовов
существует интересный цикл: функция expression () вызывает функцию term О,
которая вызывает функцию primary (), которая вызывает функцию expression О.
Эту ситуацию можно проиллюстрировать графически (удалив вызовы функций
error ()).
Это значит, что мы не можем просто определить эти три функции: не существует
такого порядка их следования, при котором вызываемая функция была бы опреде-
лена заранее. Таким образом, необходимо объявление, которое не было бы опреде-
лением. Мы решили объявить "наперед" функции expression ().
06 9. СТРУКТУРА ПРОГРАММЫ
243
IJUMII^^'IN-M
term() ?
C^jJfc-UJ *Л*1Ъ-,^т*Л№~&*£.
Работает ли эта программа? Работает, если придать этому слову определенный
смысл. Она компилируется, запускается, правильно вычисляет выражения и выдает
осмысленные сообщения об ошибках. Но работает ли она так, как мы от нее ожида-
ем? Не удивительно, что на самом деле она работает не совсем так, как надо.
Мы испытали первую версию в разделе 6.6 и удалили серьезные ошибки. Однако
вторая версия (см. раздел 6.7) не намного лучше, хотя в этом нет ничего страшного
(это было вполне предсказуемо). Программа вполне успешно выполняет свою ос-
новную задачу и позволяет проверить основные идеи. В этом смысле она вполне
успешна, но как только вы станете работать с ней, получите массу проблем.
* ПОПРОБУЙТЕ
Запустите программу, посмотрите, что она делает, и попытайтесь понять, почему
она так работает.
Задание
Это задание связано с рядом модификаций, которые превратят довольно беспо-
лезный код в полезную программу.
1. Откройте файл calculator02buggy.cpp. Скомпилируйте его. Найдите и исправь-
те несколько ошибок. Этих ошибок в тексте книги нет.
2. Измените символ, кодирующий команду выхода, с g на х.
3. Измените символ, кодирующий команду печати, с ; на =.
4. Добавьте в функцию main () приветствие.
"Добро пожаловать в программу-калькулятор!
Пожалуйста, введите выражения, содержащее числа с плавапцей точкой."
5. Усовершенствуйте это приветствие, указав, какие операторы можно выполнить
и как вывести данные на экран и выйти из программы.
6. Найдите три логические ошибки, преднамеренно внесенные в файл
calculator02buggy .срр, и удалите их из программы.244
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
Резюме
1. Что означает выражение "Программирование — это понимание"?
2. В главе подробно описан процесс разработки программы-калькулятора. Прове-
дите краткий анализ того, что должен делать калькулятор.
3. Как разбить задачу на небольшие части?
4. Почему следует начинать с небольшой версии программы?
5. Почему нагромождение возможностей может привести в тупик?
6. Перечислите три основных этапа разработки программного обеспечения.
7. Что такое прецедент использования?
8. Для чего предназначено тестирование?
9. Следуя схеме, лежащей в основе этой главы, опишите разницу между Термом,
Выражением, Числом и Первичным выражением.
10. В главе входная информация разделена на компоненты: Термы, Выражения,
Первичные выражения и Числа. Сделайте это для арифметического выражения
(17+4)/(5-1).
11. Почему в программе нет функции number () ?
12. Что такое лексема?
13. Что такое грамматика? Что такое грамматическое правило?
14. Что такое класс? Для чего мы используем классы?
15. Что такое конструктор?
16. Почему в функции expression () в операторе switch по умолчанию преду-
смотрен возврат лексемы обратно в поток?
17. Что значит "смотреть вперед"?
18. Что делает функция putback () и чем она полезна?
19. Почему операцию вычисления остатка (деление по модулю) % трудно реализо-
вать с помощью функции term () ?
20. Для чего используются два члена класс Token?
21. Зачем члены класса разделяются на закрытые и открытые?
22. Что произойдет в классе Token_stream, если в буфере есть лексема и вызвана
функция get () ?
23. Зачем в оператор switch в функцию get () в классе Token_stream добавлены
символы ';' и ' q ■ ?
24. Когда следует начинать тестирование программы?
25. Что такое тип, определенный пользователем? Зачем он нужен?
26. Что такое интерфейс типа, определенного пользователем9
27. Почему следует полагаться на библиотечные коды?ТЕРМИНЫ
Термины
class
private
public
анализ
грамматика
данные-члены
деление на нуль
интерфейс
лексема
прецедент использования
программа грамматиче-
ского анализа
программа синтаксиче-
ского анализа
проектирование
прототип
псевдокод
реализация
функция-член
член класса
Упражнения
1. Выполните упражнения из раздела Попробуйте, если вы не сделали этого раньше.
2. Добавьте в программу возможность обработки скобок {} и (), чтобы выраже-
ние { (4+5) *б}/ (3+4) стало корректным.
3. Добавьте оператор вычисления факториала: для его представления используйте
знак восклицания, !. Например, выражение 7! означает 7*6*5*4*3*
2*1. Присвойте оператору » более высокий приоритет по сравнению с опера-
торами * и /, т.е. 7*8! должно означать 7* (8»), а не (7*8) I. Начните с моди-
фикации грамматики, чтобы учесть оператор с более высоким приоритетом.
Для того чтобы учесть стандартное математическое определение факториала,
установите выражение 0! равным 1.
4. Определите класс Name_value, хранящий строку и значение. Включите в него
конструктор (так же как в классе Token). Повторите упр. 19 из главы 4, чтобы
вместо двух векторов использовался вектор vector<Name_value>.
5. Добавьте пункт в английскую грамматику из раздела 6.4.1, чтобы можно было
описать предложения вида "The birds fly but the fish swim".
6. Напишите программу, проверяющую корректность предложений в соответствии
с правилами грамматики английского языка из раздела 6.4.1. Будем считать, что
каждое предложение заканчивается точкой, ., окруженной пробелами. Напри-
мер, фраза birds fly but the fish swim . является предложением, а фразы
but birds fly but the fish swim (пропущена точка) и birds fly but
the fish swim, (перед точкой нет пробела)— нет. Для каждого введенного
предложения программа должна просто отвечать "Да" или "Нет". Подсказка:
не возитесь с лексемами, просто считайте строку с помощью оператора ».
7. Напишите грамматику для описания логических выражений. Логическое выра-
жение напоминает арифметическое за исключением того, что в нем использу-
ются не арифметические, а логические операторы; i (отрицание), - (допол-
нение), & (и), 1 (или) и ж (исключающее или). Операторы 1 и - являются пре-
фиксными унарными операторами. Оператор ж имеет более высокий приоритет,
чем оператор | (так же, как оператор * имеет более высокий приоритет.246
ГЛАВА 6 • СОЗДАНИЕ ПРОГРАММ
чем оператор +), так что выражение x|yAz означает х| (yAz), а не (х|у)Аа.
Оператор & имеет более высокий приоритет, чем оператор А, так что выражение
xAy&z означает хА (y&z).
8. Повторите упр. 12 из главы 5 (игра "Коровы и быки"), используя четыре буквы,
а не четыре цифры.
9. Напишите программу, считывающую цифры и составляющую из них целые
числа. Например, число 123 считывается как последовательность символов 1, 2
и 3. Программа должна вывести на экран сообщение: "123 - это 1 сотня, 2
десятки и 3 единицы". Число должно быть выведено как значение типа int.
Обработайте числа, состоящие из одной цифры, двух, трех и четырех цифр.
Подсказка: для того чтобы получить число 5 из символа • 5 •, вычтите из него
символ • 0 ■, иначе говоря, • 5 • - • 0 • »=5.
10. Перестановка— это упорядоченное подмножество множества. Например, до-
пустим, что вы хотите подобрать код к сейфу. Существует шестьдесят возмож-
ных чисел, а вам необходимо выбрать три числа для комбинации. Для этой ком-
бинации чисел существует Р(60,3) перестановок, где количество перестановок
определяется по формуле .
Р(а,Ъ)=, ч
v ; (а-Ъ)\ '
где символ I означает факториал. Например, 4! — это 4*3*2*1. Сочетания напо-
минают перестановки за исключением того, что в них порядок следование не име-
ет значения. Например, если вы делаете банановое мороженое и хотите использо-
вать три разных вкуса из пяти, имеющихся в наличии, вам все равно, когда вы ис-
пользуете ваниль — в начале или в конце, вы просто хотите использовать ваниль.
Формула для вычисления количества комбинаций имеет следующий вид:
C(fl,i) = ^).
v ' b\
Разработайте программу, запрашивающую у пользователя два числа, предлагаю-
щую ему вычислить количество перестановок или сочетаний и вывести результат
на экран. Напишите, что именно должна делать программа. Затем переходите на
этап проектирования. Напишите псевдокод программы и разбейте ее на части.
Эта программа должна проверять ошибки. Убедитесь, что все неправильные
входные данные приводят к появлению осмысленных сообщений об ошибках.
Послесловие
Осмысление входных данных— одна из основных составных частей програм-
мирования. Каждая программа в той или иной степени сталкивается с этой пробле-
мой. Осмысление чего бы то ни было, сделанного человеком, относится к одной из
труднейших задач. Например, многие аспекты распознавания голоса остаются
нерешенными задачами. Простые варианты этой задачи, такие как наш калькулятор,
можно решить с помощью грамматики, описывающей входные данные.Завершение программы
и
Цыплят по осени считают".
Поговорка
Создание программы предполагает последовательное уточнение того, что
вы хотите сделать и как вы желаете это выразить. В главе 6 мы разрабо-
тали первоначальную версию программы, имитирующей работу калькулято-
ра. Теперь мы ее улучшим. Завершение программы, т.е. ее настройка с учетом
потребностей пользователей, подразумевает улучшение пользовательского
интерфейса, выполнение серьезной работы по устранению ошибок, добавле-
ние новых полезных функциональных возможностей и перестройку програм-
мы для повышения ее ясности и проведения модификаций.248
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
В этой главе...
7.1. Введение 7.6. Приведение кода в порядок
7.2. Ввод и вывод 7.6.1. Символические константы
- н ле t- - 7.6.2. Использование функций
7.3. Обработка ошибок _ е , _ J
7.6.3. Расположение кода
7.4. Отрицательные числа 7.6.4. Комментарии
7.5. Остаток от деления: % 7.7. Исправление ошибок
7.8. Переменные
7.8.1. Переменные и определения
7.8.2. Использование имен
7.8.3. Предопределенные имена
7.8.4. Все?
7.1. Введение
Когда программа в первый раз начинает работать нормально, вы, вероятно,
находитесь лишь на полпути к финишу. Для больших программ и программ,
неправильная работа которых может привести к тяжелым последствиям, даже
"полпути" — слишком оптимистическая оценка. Когда программа в принципе рабо-
тает, начинается самое интересное! Именно в этот момент мы можем приступить
к экспериментам с нашими идеями на основе работоспособного кода.
В данной главе мы продемонстрируем ход мыслей профессионального програм-
миста, пытающегося улучшить калькулятор из главы 6. Обратите внимание на то,
что вопросы о программе и рассмотренные проблемы намного интереснее, чем сам
калькулятор. Мы покажем, как эволюционирует реальная программа под влиянием
требований и ограничений и как программист может постепенно улучшить ее.
7.2. Ввод и вывод
В начале главы 6 мы решили, что приглашение пользователю ввести данные
должно выглядеть следующим образом:
Выражение:
Кроме того, вывод результатов предварялся словом Результат:.
Результат:
Торопясь поскорее запустить программу, мы постоянно забываем об этих дета-
лях. И это совершенно естественно. Мы не можем постоянно думать обо всем сразу,
поэтому, когда прекращаем размышлять, обнаруживаем, что нечто забыли.
Иногда первоначальные требования измениться не могут. Как правило, про-
граммы, учитывающие такие требования, подчиняются слишком жестким правилам
и представляют собой слишком ограниченное решение поставленных задач. Таким
образом, целесообразно рассмотреть, что мы можем сделать, предполагая, что мо-
жем изменять спецификации, описывающие цели программы. Действительно ли мы
ХОТИМ, чтобы программа выводила на экран слова Выражение: и Результат:?7.2. ВВОД И ВЫВОД
249
На каком основании? Простые размышления тут вряд ли помогут. Мы должны
проверить разные варианты и выбрать лучший.
В текущей версии при вычислении выражения
2+3; 5*7; 2 + 9;
программа выводит следующие результаты:
= 5
= 35
= 11
Если добавить слова Выражение: и Результат:, получим следующее:
Выражение: 2+3; 5*7; 2+9;
Результат : 5
Выражение: Результат: 3 5
Выражение: Результат: 11
Выражение:
Мы уверены, что кому-то нравится один стиль, а кому-то — другой. В таких си-
туациях мы можем предоставить пользователям выбор, но для данной простой
задачи это было бы излишне, поэтому мы должны принять волевое решение.
По нашему мнению, слова Выражение: и Результат: слишком загромождают
экран и сбивают с толку. Из-за них сами выражения и результаты занимают лишь
небольшую часть экрана, а ведь именно они являются предметом нашего внимания,
поэтому ничто не должно нас отвлекать от них. С другой стороны, если каким-то
образом не отделить входную информацию, которую печатает пользователь, и ре-
зультаты, вычисленные компьютером, получится путаница. Во время первоначаль-
ной отладки для индикации результата мы использовали символ =, а для короткого
приглашения — символ >, который часто используется для этой цели.
> 2+3;
= 5
> 5*7;
= 35
>
Теперь экран выглядит намного лучше, и мы можем приступать к изменениям
основного цикла в функции main ().
double val =0;
while (cin) {
cout << "> n; // приглашение к вводу
Token t = ts.get();
if (t.kind == 'q') break;
if (t.kind == ■;')
cout « "= ■ « val « '\n'; // вывод результатов
else
ts.putback(t) ;
val a expression();
}250
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
К сожалению, результат ввода нескольких выражений в одной строке выглядит
запутанно.
> 2-1-3; 5*7; 2+9;
- 5
> - 35
> - 11
>
Основная проблема заключается в том, что мы не подумали о возможности вве-
сти в одной строке сразу несколько выражений. На самом деле мы подразумевали
следующий вариант ввода и вывода:
> 2+3; 5*7; 2+9;
- 5
• 35
- 11
>
Это выглядит правильно, но, к сожалению, неясно, как этого добиться. Сначала
посмотрим на функцию main (). Существует ли способ выводить символ > тогда
и только тогда, когда он не следует за символом ш немедленно? Неизвестно!
Мы должны вывести символ > до вызова функции get (), но мы не знаем, действи-
тельно ли функция get () считывает новые символы или просто возвращает объект
класса Token, созданный из символов, уже считанных с клавиатуры. Иначе говоря,
для того чтобы внести это улучшение, нам придется переделать поток Tokenstream.
Пока можем считать, что текущий вариант достаточно хорош. Если мы будем
вынуждены модифицировать поток Tokenstream, то пересмотрим это решения.
Нецелесообразно вносить в программу серьезные структурные изменения, чтобы
добиться минимальных преимуществ, а ведь мы еще даже не протестировали каль-
кулятор как следует.
7.3. Обработка ошибок
Первое, что необходимо сделать, получив в принципе работающую програм-
му,— попытаться "сломать" ее, т.е. ввести входные данные, надеясь вызвать непра-
вильную работу программы. Мы говорим "надеясь", потому что основная задача на
этом этапе — найти как можно больше ошибок, чтобы исправить их до того, как их
обнаружит кто-то другой. Если вы приступите к проверке с убеждением: "Моя про-
грамма работает, и я не делаю никаких ошибок!", то не сможете найти многих оши-
бок и будете очень огорчены, если все же обнаружите их. Вы должны подвергать
сомнению то, что делаете! Правильная позиция формулируется так: "Я "сломаю"
ее! Я умнее, чем любая программа, даже моя собственная!" Итак, введем в кальку-
лятор мешанину правильных и неправильных выражений. Рассмотрим пример.
1+2+3+4+5+6+7+8
1-2-3-4
1+27 3 ОБРАБОТКА ОШИБОК
251
(1+3;
(1+);
1*2/3%4+5-6;
О;
1+;
+1
1++;
1/0
1/0;
1++2;
-2;
_9 • • • •
*• i i i i
1234567890123456;
■ а' ;
q
1+q
1+2; q
Я ПОПРОБУЙТЕ
Введите некоторые из этих проблематичных выражений в калькулятор и постарай-
тесь понять, сколько существует способов вызвать неправильное поведение про-
граммы. Можете ли вызвать ее крах, т.е. обойти обработку ошибок и вызвать ма-
шинную ошибку? Мы не уверены, что сможете. Можете ли вы выйти из программы
без осмысленного сообщения об ошибке? Можете.
Формально говоря, этот процесс называется тестированием (testing). Сущест-
вуют даже люди, занимающиеся испытанием программ профессионально. Тестиро-
вание— очень важная часть разработки программного обеспечения. Оно может
быть весьма увлекательным занятием. Более подробно тестирование рассматривает-
ся в главе 26. Есть один большой вопрос: "Существует ли способ систематического
тестирования программ, позволяющий найти все ошибки?" Универсального ответа
на этот вопрос, т.е. ответа, который относился бы ко всем программам, нет. Однако,
если отнестись к тестированию серьезно, можно неплохо протестировать многие
программы. Пытаясь систематически тестировать программы, не стоит забывать,
что выбор тестов не бывает полным, поэтому следует использовать и так называе-
мые "странные" тесты, такие как следующий:
Mary had a little lamb
srtvrqtiewcbet7rewaewre-wqcntrretewru754389652743nvcqnwq;
!@#$%А&*()~:;
Тестируя компиляторы, я привык подавать на вход компилятора электронные
отчеты о его собственных сообщениях — заголовки писем, объяснения поль-
зователей и все остальное. Это было неразумно, поскольку этого никто никогда
не делал. Однако программа идеально кэшировала все ошибки, а не только разум-
ные, и вскоре компилятор стал очень устойчивым к странному вводу.252
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Первый действительно неудобный момент мы обнаружили, когда при тестирова-
нии калькулятора выяснилось, что окно закрывается сразу после вывода результатов.
+li
О
1+2
Немного поразмыслив (или проследив за выполнением программы), мы поняли,
что проблема заключается в том, что окно закрывается сразу после вывода сообщения
об ошибке. Это происходит потому, что наш механизм активизации окна должен был
ожидать ввода символа. Однако во всех трех случаях, упомянутых выше, программа
обнаруживала ошибку до того, как считьшала все символы, поэтому в строке ввода
всегда существовал символ, расположенный слева. Программа не могла сообщить об
этом символе, оставшемся от ввода выражения в ответ на приглашение Чтобы за-
крыть окно, введите символ. Этот "остаточный" символ закрывал окно.
Справиться с этой ошибкой можно, модифицировав функцию main () (см. раз-
дел 5.6.3).
catch (runtime_error& e) {
cerr « е.what() « endl;
// keep_window_open():
cout « "Чтобы закрыть окно, введите символ ~\пп;
char ch;
while(cin » ch) // продолжает чтение после ввода символа ~
if (ch=='~') return 1;
return 1;
}
По существу, мы заменили функцию keep_window_open () своим собственным
кодом. Обратите внимание на то, что проблема останется нерешенной, если символ
~ окажется следующим после возникновения ошибки, но это маловероятно.
Обнаружив эту проблему, мы написали вариант функции keepwindowopen (),
аргументом которой была строка, закрывающая окно, как только пользователь вво-
дил ее после приглашения. Таким образом, более простое решение выглядит так:
catch (runtime_error& e) {
cerr « е.what() « endl;
keep_window_open("--");
return 1;
}
Рассмотрим еще один пример.
+1
!1—
О
Эти данные вынуждают калькулятор выдавать соответствующие сообщения об
ошибках, например
Чтобы выйти, введите ~~
и не прекращать работу, пока пользователь не введет строку —.7.3 ОБРАБОТКА ОШИБОК
253
Входные данные для калькулятора вводятся с клавиатуры. Это затрудняет тести-
рование: каждый раз, внося улучшение, мы должны напечатать множество кон-
трольных примеров (каждый раз заново!), чтобы убедиться, что программа по-
прежнему работает. Было бы лучше, если бы контрольные примеры где-то храни-
лись и вызывать их одной командой. Некоторые операционные системы (в частно-
сти, Unix) упрощают эту задачу, позволяя потоку с in считывать данные из файла
без модификации программы, а потоку cout — направлять данные в файл. В других
случаях мы должны модифицировать программу так, чтобы она использовала файл
(подробнее об этом — в главе 10).
Рассмотрим примеры.
1+2; q
1+2 q
Мы хотели бы вывести результат (3) и выйти из программы. Забавно, что строка
1+2 q
приводит к этому результату, а более очевидная строка
1+2; q
вызывает ошибку Ожидается первичное выражение. Где следует искать эту
ошибку? Конечно, в функции main (), где обрабатываются символы ; и q. Мы до-
бавили инструкции "печать" и "выход" просто для того, чтобы поскорее получить
работающий вариант калькулятора (см. раздел 6.6), а теперь расплачиваемся за эту
поспешность. Рассмотрим еще раз следующий фрагмент:
double val =0;
while (cin) {
cout << n> ";
Token t = ts.getO;
if (t.kind == *q') break;
if (t.kind == ';')
cout « "s ■ « val « '\n';
else
ts.putback(t);
val = expression();
}
Если обнаруживаем точку с запятой, то вызываем функцию expression (), не про-
веряя символ q. Эта функция в первую очередь ищет вызов функции primary{)?
но обнаруживает символ q. Буква q не является первичным выражением, поэтому по-
лучаем сообщение об ошибке. Итак, после тестирования точки с запятой мы должны
обработать символ q. В этот момент мы почувствовали необходимость несколько
упростить логику, поэтому окончательный вариант функции main () выглядит так:
int main ()
tryГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
2S4
{
while (сin) {
cout « "> ";
Token t » ts.getO;
while <t,kind « ';•) t«ts.get(); // считывает •;*
if (t.kind « 'q') {
keep_window_open();
return 0;
}
ts.putback(t);
cout « ■= " « expression () << endl;
}
keep_window_open();
return 0;
}
catch (exceptions e) {
cerr « e.whatO « endl;
keep_window_open(■—■);
return 1;
}
catch (...) {
cerr << "exception \nn;
keep_window_open("--");
return 2;
}
Это повышает надежность обработки ошибок. Таким образом, теперь можно
искать новые пути улучшения калькулятора.
7.4. Отрицательные числа
Проверив калькулятор, легко убедиться, что он не слишком элегантно обрабаты-
вает отрицательные числа. Например, выражение
-1/2
является ошибочным.
Для того чтобы калькулятор работал корректно, мы должны были бы написать
(0-1)/2
Однако это неприемлемо.
Обычно такие проблемы выявляются на поздних этапах отладки и тестирова-
ния. Только тогда можно увидеть, что на самом деле делает программа, и по-
лучить информацию, позволяющую уточнить исходные идеи. Планируя проект, це-
лесообразно сэкономить время и извлечь выгоду из наших уроков. Очень часто пер-
вая версия поставляется пользователям без необходимых уточнений из-за напря-
женного расписания и жесткой стратегии управления, которая не позволяет вносить
исправления в спецификацию на поздних этапах разработки. Поздние добавле-
ния— это кошмар менеджера. На самом деле, когда программа уже достаточно7.5. ОСТАТОК ОТ ДЕЛЕНИЯ: %
25
работоспособна, но еще не готова к поставке, еще не поздно внести дополнение
это самый первый момент, когда можно учесть опыт ее использования. Реалиста*
ное расписание должно учитывать это обстоятельство.
В данном случае необходимо внести исправления в грамматику, чтобы пред]
смотреть унарный минус. На первый взгляд легче всего внести исправления в пун*
Первичное выражение. Сейчас он выглядит так:
Первичное выражение:
Число
п(" Выражение п) ■
Нам требуется, чтобы этот пункт выглядел примерно таким образом:
Первичное выражение:
Число
"(" Выражение ") "
"-" Первичное выражение
п+" Первичное выражение
Мы добавили унарный плюс, поскольку он есть в языке C++. Если есть унарны
минус, то легче реализовать унарный плюс, чем объяснить его бесполезность. Ко;
реализующий Первичное выражение, принимает следующий вид:
double primary ()
{
Token t = ts.getO;
switch (t.kind) {
case ' (' : // обработка пункта ' (' выражение ') '
{
double d = expression();
t = ts.get();
if (t.kind 1= ')') error("•)' expected");
return d;
}
case '8': // символ '8' используется для представления числа
return t.value; // возвращаем число
case •-■:
return - primary О;
case •+■:
return primary();
default:
error("ожидается первичное выражение");
}
}
Этот код настолько прост, что работает с первого раза.
7.5. Остаток от деления: %
Обдумывая проект калькулятора, мы хотели, чтобы он вычислял остаток от де-
ления — оператор %. Однако этот оператор не определен для чисел с плавающейГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Точкой, поэтому мы отказались от этой идеи. Настало время вернуться к ней снова,
Это должно быть простым делом.
1. Добавляем символ % как Token.
2. Преобразовываем число типа double в тип int, чтобы впоследствии применить
к нему оператор %.
Вот как изменится код функции term ():
case '%':
{ double d = term ();
int il = int(left);
int 12 = int(d);
return il%i2;
}
Для преобразования чисел типа double в числа типа int проще всего использо-
вать явное выражение int (d), т.е. отбросить дробную часть числа. Несмотря на то
что это избыточно (см. раздел 3.9.2), мы предпочитаем явно указать, что знаем
о произошедшем преобразовании, т.е. избегаем непреднамеренного или неявного
преобразования чисел типа double в числа типа int. Теперь получим правильные
результаты для целочисленных операндов. Рассмотрим пример.
> 2%3;
= о
> 3%2;
= 1
> 5%3;
- 2
Как обработать операнды, которые не являются целыми числами? Каким должен
быть результат следующего выражения:
> 6.7%3.3;
Это выражение не имеет корректного результата, поэтому запрещаем примене-
ние оператора % к аргументам с десятичной точкой. Проверяем, имеет ли аргумент
дробную часть, и в случае положительного ответа выводим сообщение об ошибке.
Вот как выглядит результат функции term ():
double term()
{
double left = primary О;
Token t = ts.getO; // получаем следующую лексему
// из потока Token_stream
while(true) {
switch (t.kind) {
case '*':
left *= term О ;
t = ts.getO ;
break;7 6 ПРИВЕДЕНИЕ КОДА В ПОРЯДОК
257
case ■/':
{ double d « term();
if (d за 0) error ("деление на нуль");
left /«= d;
t = ts.get();
break;
}
case '%':
{ double d = termO;
int il - int(left);
if (il I» left)
error ("левый операнд % не целое число");
int i2 = int(d);
if (i2 != d) error ("правый операнд % не целое число");
if (i2 == 0) error(■%: деление на нуль");
left = il%i2;
t = ts.get();
break;
}
default:
ts.putback(t) ; // возвращаем t обратно в поток
// Token_stream
return left;
}
}
}
Здесь мы лишь проверяем, изменилось ли число при преобразовании типа dou-
ble в тип int. Если нет, то можно применять оператор %. Проблема проверки цело-
численных операндов перед использованием оператора % — это вариант проблемы
сужения (см. разделы 3.9.2 и 5.6.4), поэтому ее можно решить с помощью оператора
narrow_cast.
case '%■:
{ int il = narrow_cast<int>(left) ;
int i2 = narrow_cast<int> (termO ) ;
if (i2 == 0) error(n%: деление на нуль");
left = il%i2;
t = ts.get();
break;
}
Это очевидно короче и яснее, но не позволяет получать осмысленные сообщения
об ошибках.
7.6. Приведение кода в порядок
jS| Мы уже внесли несколько изменений в программу. По нашему мнению,
'==' все они являются улучшениями, но код начинает постепенно запутываться.
Настало время пересмотреть его, чтобы понять, что можно сделать проще и короче,
где добавить необходимые комментарии и т.д. Другими словами, мы не закончимл т ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
258
программу до тех пор, пока она не примет вид, понятный для пользователя. За ис-
ключением практически полного отсутствия комментариев программа калькулятора
не очень плоха, но ее код нужно привести в порядок.
7.6.1. Символические константы
Оглядываясь назад, вспомним, что с помощью символа ■ 8 ■ мы решили обозна-
чать объекты класса Token, содержащие числовое значение. На самом деле совер-
шенно не важно, какое именно число будет обозначать числовые лексемы, нужно
лишь, чтобы оно отличалось от индикаторов других разновидностей лексем. Однако
наш код пока выглядит довольно странно, и мы должны вставить в него несколько
комментариев.
case '8': // символ '8' обозначает число
return t.value; // возвращаем число
case •-':
return - primary();
Честно говоря, здесь мы также сделали несколько ошибок, напечатав • 0 ■, а не
■ 8 ■, поскольку забыли, какое число выбрали для этой цели. Иначе говоря, ис-
пользование символа ' 8 • непосредственно в коде, предназначенном для обработки
объектов класса Token, является непродуманным, трудным для запоминания и уяз-
вимым для ошибок; символ ' 8' представляет собой так называемую "магическую
константу", о которой мы предупреждали в разделе 4.3.1. Теперь необходимо вве-
сти символическое имя константы, которая будет представлять число.
const char number = '8'; // t.kind==number означает, что t — число
Модификатор const сообщает компилятору, что мы определили число, которое
не будет изменяться: выражение numbers ■ 0' должно вызвать сообщение об ошиб-
ке. При таком определении переменной number нам больше не нужно использовать
символ • 8 • явным образом.
Фрагмент кода функции primary (), упомянутый выше, теперь принимает сле-
дующий вид:
case number:
return t.value; // возвращает число
case '-':
return - primary();
Этот фрагмент не требует комментариев. Совершенно необязательно сооб-
щать в комментариях, что очевидно в самом коде. Повторяющиеся коммента-
рии, объясняющие нечто, часто свидетельствуют о том, что программа требует
улучшения. Аналогично, код функции Tokenstream: :get (), распознающий чис-
ла, принимает такой вид:
case '.':
case 'О1; case '1': case '2': case '3': case '4':
m7.6 ПРИВЕДЕНИЕ КОДА В ПОРЯДОК
259
case '5': case 'б1: case '71: case '8': case '9':
{ cin.putback(); // вернуть цифру в поток ввода
double val;
cin >> val; // считать число с плавающей точкой
return Token(number,val) ;
}
Можно было бы придумать символические имена для всех лексем, но это из-
лишне. Помимо всего прочего, символы • (' и ' + ■ самоочевидны. Анализируя лек-
семы, легко понять, что лишь символы ';' для инструкции "печать" (или "конец
выражения") и 'q* для инструкции "выход" выбраны произвольным образом.
А почему не ' р' или ' е' ? В более крупной программе такая малопонятная и произ-
вольная система обозначения рано или поздно вызвала бы проблемы, поэтому
введем следующие переменные:
const char quit = 'q'; // t.kind==quit значит, что лексема t —
// код выхода
const char print = ';'; // t.kind==print значит, что лексема t —
// код печати
Теперь цикл в функции main () можно переписать так:
while (cin) {
cout << "> ";
Token t = ts.getO;
while (t.kind == print) t=ts.get();
if (t.kind =* quit) {
keep_window_open();
return 0;
}
ts.putback(t);
cout << "= " << expression() « endl;
}
Введя символические имена для инструкции "печать" и "выход", мы сделали код
понятнее. Кроме того, теперь тот, кто будет читать текст функции main (), не будет
гадать, как кодируются эти инструкции. Например, не удивительно, если мы решим
изменить представление инструкции "выход" на символ 'е* (от слова "exit").
Для этого не требуется вносить изменения в функцию main (). Теперь в глаза бро-
саются строки "> ■ и " = ". Почему мы используем эти "магические" литералы
в своей программе? Как новый программист, читающий текст функции
main(), сможет догадаться об их предназначении? Может быть, стоит добавить
комментарии? Это может оказаться удачной идеей, но использование символиче-
ского имени более эффективно.
const string prompt ■ "> ";
const string result e ■= "; // используется для указания на то, чтс^
// далее следует результат260
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Если нам в дальнейшем понадобится изменить приглашение или индикатор
результата, будет достаточно просто изменить эти константы. Теперь цикл выгля-
дит иначе.
while (cin) {
cout « prompt;
Token t ■ ts.getO;
while (t.kind «sprint) t=ts.get();
if (t.kind « quit) {
keep_window_open();
return 0;
}
ts.putback(t);
cout « result « expression () « endl;
}
7.6.2. Использование функций
Функции должны отражать структуру программы, и их имена должны обеспечи-
вать логическое разделение кода на отдельные части. В этом отношении наша про-
грамма до сих пор не вызывала нареканий: функции expression (), term О и pri-
mary () непосредственно отражают наше понимание грамматики, а функция get ()
выполняет ввод и распознавание лексем. Тем не менее анализ функции main () по-
казывает, что ее можно разделить на две логически разные части.
1. Функция main () описывает общую логическую структуру: начало программы,
конец программы и обработку фатальных ошибок.
2. Функция main () выполняет цикл вычислений.
=2| Теоретически любая функция выполняет отдельное логическое действие
==• (см. раздел 4.5.1). Если функция main О выполняет оба эти действия, то это
затемняет структуру программы. Напрашивается выделение цикла вычислений
в виде отдельной функции calculate ().
void calculate О // цикл вычисления выражения
{
while (cin) {
cout « prompt;
Token t з ts.getO;
while (t.kind == print) t=ts.get(); // отмена печати
if (t.kind == quit) return; // выход
ts.putback(t);
cout « result « expression() « endl;
}
}
int main О
try {
calculate О ;7 6 ПРИВЕДЕНИЕ КОДА В ПОРЯДОК
261
keep_window_open() ; // обеспечивает консольный режим Windows
return 0;
catch (runtime_error& e) {
cerr << e.whatO << endl;
keep_window_open(n — ") ;
return 1;
}
catch (. . .) {
cerr << "exception \n";
keep_window_open(" — n);
return 2;
}
Этот код намного более четко отражает структуру программы, и, следовательно,
его проще понять.
7.6.3. Расположение кода
Поиск некрасивого кода приводит нас к следующему фрагменту:
switch (ch) {
case 'q': case ';': case '%': case '(': case ')':
case '+': case '-': case '*': case '/':
return Token(ch); // пусть каждый символ обозначает сам себя
Этот код был неплох, пока мы не добавили символы 'q1, ■; • и ■%', но теперь
он стал непонятным. Код, который трудно читать, часто скрывает ошибки. И конеч-
но, они есть в этом фрагменте! Для их выявления необходимо разместить каждый
раздел case в отдельной строке и расставить комментарии. Итак, функция Token_
stream: :get () принимает следующий вид:
Token Tokenstream::get()
// считываем символ из потока cin и образуем лексему
{
if (full) { // проверяем, есть ли в потоке хотя бы одна лексема
full=false;
return buffer;
}
char ch;
cin >> ch; // Перевод: "оператор >> игнорирует разделители пробелы,
// переходы на новую строку, табуляцию и пр»)11
switch (ch) {
case quit:
case print:
case '('
case ')'
case '-i-1
case '-■
case ■ *'262
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
case »/■s
case •%':
return Token(ch); // пусть каждый символ обозначает сам себя
case '. •; // литерал с плавающей точкой может начинаться с точки
case 'О1: case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case • 9': // числовой
// литерал
{ cin.putback(ch); // возвращаем цифру обратно во входной
// поток
double val;
cin >> val; // считываем число с плавающей точкой
return Token(number,val);
}
default:
error("Bad token");
}
}
Разумеется, можно было бы поместить в отдельной строке раздел case для каж-
дой цифры, но это нисколько не прояснит программу. Кроме того, в этом случае
функция get () вообще осталась бы за пределами экрана. В идеале на экране долж-
ны поместиться все функции; очевидно, что ошибку легче скрыть в коде, который
находится за пределами экрана. Расположение кода имеет важное значение. Кроме
того, обратите внимание на то, что мы заменили простой символ ' q' символиче-
ским именем quit. Это повышает читабельность кода и гарантирует появление со-
общения компилятора при попытке выбрать для имени quit значение, уже связан-
ное с другим именем лексемы.
=Э| При уточнении кода можно непреднамеренно внести новые ошибки. После
=• уточнения всегда следует проводить повторное тестирование кода. Еще лучше
проводить его после внесения каждого улучшения, так что, если что-то пойдет не-
правильно, вы всегда можете вспомнить, что именно сделали. Помните: тестировать
надо как можно раньше и как можно чаще.
7.6.4. Комментарии
При разработке кода мы включили в него несколько комментариев. Хорошие
комментарии — важная часть программирования. В рабочей суматохе мы часто за-
бываем об этом. Момент, когда мы возвращаемся к коду для приведения его в поря-
док, лучше всего подходит для проверки следующих свойств комментариев.
1. Корректность (вы могли изменить код, оставив старый комментарий).
2. Адекватность (редкое качество).
3. Немногословность (чтобы не отпугнуть читателя).
Подчеркнем важность последнего свойства: все, что необходимо сказать в ко-
де, следует выражать средствами самого языка программирования. Избегайте
т7 б ПРИВЕДЕНИЕ КОДА В ПОРЯДОК
263
комментариев, описывающих действие, которое и так совершенно понятно для тех,
кто знает язык программирования. Рассмотрим пример.
х ■ Ь+с; // складываем переменные b и с и присваиваем результат
// переменной х
Такие комментарии часто можно встретить в учебниках, но они нужны лишь для
того, чтобы объяснить свойства языка, которые еще не известны читателям. Ком-
ментарии нужны для того, чтобы объяснять то, что сложно выразить средствами
языка программирования. Примером такой ситуации является выражение намере-
ния программиста: код означает лишь то, что программа делает на самом деле, но
он ничего не может сказать читателю о действительных намерениях программиста
(см. раздел 5.9.1). Посмотрите на код программы калькулятора. В нем кое-чего не
хватает: функции описывают, как мы обрабатываем выражения и лексемы, но ниче-
го не сказано (помимо самого кода) о том, что именно мы считаем выражением
и лексемой. Лучше всего поместить такие комментарии в грамматике.
/*
Простой калькулятор
История версий:
Переработан Бьярне Страуструпом в мае 2007 г.
Переработан Бьярне Страуструпом в августе 2006 г.
Переработан Бьярне Страуструпом в августе 2004 г.
Разработан Бьярне Страуструпом
(bs@cs.tamu.edu) весной 2004 г.
Эта программа реализует основные выражения калькулятора.
Ввод из потока cin; вывод в поток cout.
Грамматика для ввода:
Инструкция:
Выражение
Печать
Выход
Печать:
Выход:
q
Выражение:
Терм
Выражение + Терм
Выражение - Терм
Терм:
Первичное выражение
Терм * Первичное выражение264
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Терм / Первичное выражение
Терм % Первичное выражение
Первичное выражение:
Число
( Выражение )
- Первичное выражение
+ Первичное выражение
Число:
литерал_с_плавающей_точкой
Ввод из потока cin через поток Token_stream с именем ts.
*/
Здесь мы использовали блок комментариев, который начинается символами /*
и заканчивается символами */. В реальной программе история пересмотра может со-
держать сведения о том, какие именно изменения были внесены и какие улучшения
были сделаны. Обратите внимание на то, что эти комментарии помещены за предела-
ми кода. Фактически это несколько упрощенная грамматика: сравните правило для
Инструкции с тем, что на самом деле происходит в программе (например, взгляните
на код в следующем разделе). Этот комментарий ничего не говорит от цикле в функ-
ции calculate (), позволяющем выполнять несколько вычислений в рамках одного
сеанса работы программы. Мы вернемся к этой проблеме в разделе 7.8.1.
7.7. Исправление ошибок
Почему мы прекращаем работу программы, когда находим ошибку? В свое вре-
мя это казалось простым и очевидным решением, но почему? Почему бы не вывести
сообщение об ошибке и продолжить работу? Помимо всего прочего, мы часто дела-
ем опечатки, и такие ошибки не означают, что мы решили не выполнять вычисле-
ния. Итак, попробуем исправить ошибки. Это по существу значит, что мы должны
перехватить исключение и продолжить работу после исправления ошибки.
До сих пор все ошибки представлялись в виде исключений и обрабатывались
функцией main (). Если мы хотим исправить ошибку, то функция calculate О
должна перехватывать исключения и попытаться устранить неисправность прежде,
чем приступить к вычислению следующего выражения.
void calculate ()
{
while (cin)
try {
cout << prompt;
Token t = ts.getO;
while (t.kind == print) t=ts.get(); // сначала
// игнорируем все
// инструкции
// "печать"
if (t.kind »= quit) return; // выход
ts.putback(t);
cout << result << expression О << endl;7 7 ИСПРАВЛЕНИЕ ОШИБОК
265
catch (exception& e) {
cerr << e.what О << endl; // выводим сообщение об ошибке
clean_up_mess О ;
}
}
Мы просто поместили цикл while в блоке try, который выводит сообщения
об ошибке и устраняет неисправности. После этого работу можно продолжать по-
прежнему. Что означает выражение '"устранить неисправность"? В принципе готов-
ность к выполнению вычислений после исправления ошибки означает, что все дан-
ные находятся в полном порядке и вполне предсказуемы. В калькуляторе единст-
венные данные за пределами отдельных функций находятся в потоке Token_
stream. Следовательно, мы должны убедиться, что в потоке нет лексем, связанных
с прекращенными вычислениями и способных помешать будущим вычислениям.
Рассмотрим пример.
1++2*3; 4 + 5;
Эти выражения вызывают ошибку, и лексемы 2*3; 4+5 останутся в буфере потока
Tokenstream после того, как второй символ + породит исключение. У нас есть две
возможности.
1. Удалить все лексемы из потока Tokenstream.
2. Удалить из потока все лексемы Tokenstream, связанные с текущими вычисле-
ниями.
В первом случае отбрасываем все лексемы (включая 4+5;), а во втором —
отбрасываем только лексему 2*3, оставляя лексему 4+5 для последующего вычис-
ления. Один выбор является разумным, а второй может удивить пользователя.
Обе альтернативы одинаково просто реализуются. Мы предпочли второй вариант,
поскольку его проще протестировать. Он выглядит проще. Чтение лексем выполня-
ется функцией get(), поэтому можно написать функцию cleanupmessO,
имеющую примерно такой вид:
void clean_up_mess() // наивно
{
while (true) { // пропускаем,
// пока не обнаружим инструкцию "печать"
Token t = ts.getO;
if (t.kind == print) return;
>
}
К сожалению, эта функция не всегда работает хорошо. Почему? Рассмотрим
следующий вариант:
l@z; 1+3;266
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Символ 9 приводит нас к разделу catch в цикле while. Тогда для выявления
следующей точки с запятой вызываем функцию clean_up_mees(). Функция
cleanupmess () вызывает функцию get О и считывает символ z. Это порождает
следующую ошибку (поскольку символ z не является лексемой), и мы снова оказы-
ваемся в блоке catch внутри функции main () и выходим из программы. Ой! У нас
теперь нет шансов вычислить лексему i+з. Вернитесь к меловой доске!
Можно было бы уточнить содержание блоков try и catch, но это внесет в про-
грамму еще большую путаницу. Ошибки в принципе трудно обрабатывать, а ошиб-
ки, возникающие при обработке других ошибок, обрабатывать еще труднее. Поэто-
му стоит попытаться найти способ удалять из потока Tokenstream символы, кото-
рые могут породить исключение. Единственный путь для ввода данных в каль-
кулятор пролегает через функцию get (), и он может, как мы только что выяснили,
порождать исключения. Таким образом, необходима новая операция. Очевидно, что
ее целесообразно поместить в класс Token_stream.
class Token_stream {
public:
TokenstreamO ; // создает поток Token_stream/ считывающий
// данные из потока cin
Token get О; // считывает лексему-
void putback(Token t); // возвращает лексему
void ignore(char с); // отбрасывает символы,
// предшествующие символу с включительно
private:
bool full; // есть лексема в буфере?
Token buffer; // здесь хранится лексема, которая возвращается
// назад с помощью функции putback ()
};
Функция ignore О должна быть членом класса Token_stream, так как она
должна иметь доступ к его буферу. Мы выбрали в качестве искомого символа аргу-
мент функции ignore О. Помимо всего прочего, объект класса Tokenstream не
обязан знать, что калькулятор считает хорошим символом для исправления ошибок.
Мы решили, что этот аргумент должен быть символом, потому что не хотим риско-
вать, работая с составными лексемами ( мы уже видели, что при этом происходит).
Итак, мы получаем следующую функцию:
void Tokenstrearn::ignore(char c)
// Символ с обозначает разновидность лексем
{
// сначала проверяем буфер:
if (full && c==buffer.kind) {
full = false;
return;
}
full = false;
// теперь проверяем входные ДаН7 8 ПЕРЕМЕННЫЕ
267
char ch = 0;
while (cin>>ch)
if (ch==c) return;
}
В этом коде сначала происходит проверка буфера. Если в буфере есть символ с,
прекращаем работу, отбрасывая этот символ с; в противном случае необходимо
считывать символы из потока с in, пока не встретится символ с. Теперь функцию
clean_up_mess () можно написать следующим образом:
void clean_up_mess ()
{
ts.ignore(print);
}
Обработка ошибок всегда является сложной. Она требует постоянного экспери-
ментирования и тестирования, поскольку крайне трудно представить заранее, какая
ошибка может возникнуть в ходе выполнения программы. Защита программы от
неправильного использования всегда представляет собой очень сложную задачу.
Дилетанты об этом никогда не беспокоятся. Качественная обработка ошибок —
один из признаков профессионализма.
7.8. Переменные
Поработав над стилем и обработкой ошибок, можем вернуться к попыткам улуч-
шить функциональные возможности калькулятора. Мы получили вполне работоспо-
собную программу; как же ее улучшить? Во-первых, необходимо ввести переменные.
Использование переменных позволяет лучше выражать более длинные вычисления.
Аналогично для научных вычислений хотелось бы иметь встроенные имена,
такие как pi и е, как в научных калькуляторах. Переменные и константы— основ-
ные новшества, которые мы внесем в калькулятор. Это коснется многих частей ко-
да. Такие действия не следует предпринимать без весомых причин и без достаточ-
ного времени на работу. В данном случае мы вносим переменные и константы, по-
скольку это дает возможность еще раз проанализировать код и освоить новые
методы программирования.
7.8.1. Переменные и определения
Очевидно, что для работы с переменными и константами программа-калькулятор
должна хранить пары (имя, значение) так, чтобы мы имели доступ к значению
по имени. Класс Variable можно определить следующим образом:
class Variable {
public:
string name;
double value;
Variable (string n, double v) :name(n), value (v) { }268
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Член класса name используется для идентификации объекта класса Variable,
а член value — для хранения значения, соответствующего члену name. Конструк-
тор добавлен просто для удобства.
Как хранить объекты класса Variable так, чтобы их значение можно было най-
ти или изменить по строке name? Оглядываясь назад, видим, что на этот вопрос есть
только один правильный ответ: в виде вектора объектов класса Variable.
vector<Variable> var__table;
В вектор vartable можно записать сколько угодно объектов класса Variable,
а найти их можно, просматривая элементы вектора один за другим. Теперь можно
написать функцию getvalue (), которая ищет заданную строку name и возвращает
соответствующее ей значение value.
double get_value(string e)
// возвращает значение переменной с именем s
{
for (int i в 0; i<var_table.size(); ++i)
if (var_table [i] .name == s) return var_table [i] .value;
error ("get: неопределенная переменная ", в);
}
Этот код действительно прост: он перебирает объекты класса variable в векто-
ре var_table (начиная с первого элемента и продолжая до последнего включи-
тельно) и проверяет, совпадает ли их член name с аргументом в. Если строки name
и в совпадают, функция возвращает член value соответствующего объекта. Анало-
гично можно определить функцию setvalueO, присваивающую новое значение
члену value объекта класса Variable.
void set_value(string s, double d)
// присваивает объекту класса Variable с именем s значение d
{
for (int i = 0; i<var_table.size(); ++i)
if (var_table[i].name == s) {
var_table[i].value = d;
return;
}
error("set: неопределенная переменная ", s);
}
Теперь можем считать и записывать переменные, представленные в виде объек-
тов класса Variable в векторе vartable. Как поместить новый объект класса
Variable в вектор var_table? Как пользователь калькулятора должен сначала за-
писать переменную, а затем присвоить ей значения? Можно сослаться на обозначе-
ния, принятые в языке C++.
double var = 7.2;7 8. ПЕРЕМЕННЫЕ
269
Это работает, но все переменные в данном калькулятора и так хранят значения
типа double, поэтому явно указывать этот тип совершенно не обязательно. Можно
было бы написать проще.
var = 7.2;
Что ж, возможно, но теперь мы не можем отличить определение новой перемен-
ной от синтаксической ошибки.
varl =7.2; // определение новой переменной с именем varl
varl «= 3.2; // определение новой переменной с именем var2
Ой! Очевидно, что мы имели в виду var2 = 3.2; но не сказали об этом явно
(за исключением комментария). Это не катастрофа, но будем следовать традициям
языков программирования, в частности языка C++, в которых объявления перемен-
ных с их инициализацией отличаются от присваивания. Мы можем использовать
ключевое слово double, но для калькулятора нужно что-нибудь покороче, поэто-
му — следуя другой старой традиции— выбрали ключевое слово let.
let var = 7.2;
Грамматика принимает следующий вид:
Вычисление:
Инструкция
Печать
Выход
Инструкция вычисления
Инструкция:
Объявление
Выражение
Объявление:
"let" Имя "=" Выражение
Вычисление — это новое правило вывода в грамматике. Оно выражает цикл
(в функции calculate О), который позволяет выполнять несколько вычислений
в ходе одного сеанса работы программы. При обработке вьфажений и объявлений
это правило опирается на правило Инструкция. Например, инструкцию можно
обработать следующим образом:
double statement()
{
Token t = ts.get();
switch (t.kind) {
case let:
return declarationО;
default:
ts.putback(t);
return expression();
}
}270
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Вместо функции expression О в функции calculate () можем использовать
функцию statement ().
void calculate()
с
while (cin)
try {
cout « prompt;
Token t as ts. get ();
while (t.kind ■■ print) t=ts.get(); // игнорируем
// "печать"
if (t.kind ■■ quit) return; // выход
ts.putback(t);
cout « result « statement О « endl;
>
catch (exceptions e) {
cerr « e.whatO « endl; // выводим сообщение об ошибке
clean_up_mess ();
}
}
Теперь необходимо написать функцию declaration(). Что следует сделать?
Нужно убедиться, что после ключевого слова let следует Имя, а за ним — символ ■
и Выражение. Именно это утверждает грамматика. Что делать с членом name?
Мы должны добавить в вектор var_table типа vector<Variable> объект класса
Variable с заданными строкой name и значением выражения. После этого мы смо-
жем извлекать значения с помощью функции getvalue () и изменять их с помо-
щью функции setvalue (). Однако сначала надо решить, что случится, если мы
определим переменную дважды. Рассмотрим пример.
let vl * 7;
let vl = 8;
Мы решили, что повторное определение является ошибкой. Обычно это просто
синтаксическая ошибка. Вероятно, мы имели в виду не то, что написали, а следую-
щие инструкции:
let vl e 7;
let v2 = 8;
Определение объекта класса Variable с именем var и значением val состоит
из двух логических частей.
1. Проверяем, существует ли в векторе vartable объект класса Variable с име-
нем var.
2. Добавляем пару (var,val) в вектор vartable.7.8. ПЕРЕМЕННЫЕ
271
Мы не должны использовать неинициализированные переменные, поэтому оп-
ределили функции isdeclaredO и definenameO, представляющие эти две
операции.
bool isdeclared(string var)
/ есть ли переменная var в векторе var_table?
{
for (int i = 0; i<var_table.size(); ++i)
if (var_table [i] .name == var) return true;
return false;
}
double define_name(string var, double val)
// добавляем пару (var,val) в вектор var_table
{
if (is_declared(var)) error(var,n declared twice");
var_table.push_back (Variable (var, val)) ;
return val;
}
Добавить новый объект класса Variable в вектор типа vector<Variable>
легко; эту операцию выполняет функция-член вектора pushbackO •
var_table.push_back(Variable(var,val));
Вызов конструктора Variable (var, val) создает соответствующий объект
класса Variable, а затем функция pushbackO добавляет этот объект в конец век-
тора vartable. В этих условиях и с учетом лексем let и name функция declara-
tion () становится вполне очевидной.
double declaration()
// предполагается, что мы можем выделить ключевое слово "let"
// обработка: name = выражение
// объявляется переменная с именем "name" с начальным значением,
// заданным "выражением"
{
}
Token t = ts.getO;
if (t.kind != name) error ("в объявлении ожидается переменная
name") ;
string var__name = t.name;
Token t2 = ts.getO;
if (t2.kind != 'я') error("в объявлении пропущен символ =",
var_name);
double d = expression О;
def ine_name (var_name,d);
return d;272
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Обратите внимание на то, что мы возвращаем значение, хранящееся в новой
переменной. Это полезно, когда инициализирующее выражение является нетриви-
альным. Рассмотрим пример.
let v = d/(t2-tl);
Это объявление определяет переменную v и выводит ее значение. Кроме того,
печать переменной упрощает код функции calculate (), поскольку при каждом вы-
зове функция statement () возвращает значение. Как правило, общие правила позво-
ляют сохранить простоту кода, а специальные варианты приводят к усложнениям.
Описанный механизм отслеживания переменных часто называют таблицей сим-
волов (symbol tables). Его можно радикально упростить с помощью стандартной
библиотеки тар (см. раздел 21.6.1).
7.8.2. Использование имен
Все это очень хорошо, но, к сожалению, не работает. Это не должно было стать
для нас сюрпризом. Первый вариант никогда — почти никогда — не работает.
В данном случае мы даже не закончили программу — она даже не скомпилируется.
У нас нет лексемы ■ ш *, но это легко исправить, добавив дополнительный раздел
case в функцию Token_stream: :get () (см. раздел 7.6.3). А как представить клю-
чевые слова let и name в виде лексем? Очевидно, для того чтобы распознавать эти
лексемы, необходимо модифицировать функцию get (). Как? Вот один из способов.
const char name = 'а'; // лексема name
const char let = 'L'; // лексема let
const string declkey = "let"; // ключевое слово let
Token Token_strearn::get()
{
if (full) { full=false; return buffer; }
char ch;
cin >> ch;
switch (ch) {
// как и прежде
default:
if (isalpha(ch)) {
cin.putback(ch);
string s;
cin>>s;
if (s == declkey) return Token(let); // ключевое
// слово let
return Token(name,s);
}
error("Неправильная лексема");
}
}
В первую очередь обратите внимание на вызов функции isalpha (ch). Этот вы-
зов отвечает на вопрос "Является ли символ ch буквой?"; функция isalpha О при-78 ПЕРЕМЕННЫЕ
273
надлежит стандартной библиотеке и описана в заголовочном файле stdlibf aci-
lities.h Остальные функции классификации символов описаны в разделе 11.6.
Логика распознавания имен совпадает с логикой распознавания чисел: находим
первый символ соответствующего типа (в данном случае букву), а затем возвраща-
ем его назад в поток с помощью функции putback () и считываем все имя целиком
с помощью оператора >>.
К сожалению, этот код не компилируется; класс Token не может хранить строку,
поэтому компилятор отказывается распознавать вызов Token (name, в). К счастью,
эту проблему легко исправить, предусмотрев такую возможность в определении
класса Token.
struct Token {
char kind;
double value;
string name;
Token(char ch) :kind(ch), value(O) { }
Token(char ch, double val) :kind(ch), value(val) { }
Token(char ch, string n) :kind(ch), name (n) { }
};
Для представления лексемы let мы выбрали букву 'L1, а само ключевое слово
храним в виде строки. Очевидно, что это ключевое слово легко заменить ключевы-
ми словами double, var, #, просто изменив содержимое строки declkey, с которой
сравнивается строка в.
Попытаемся снова протестировать программу. Если напечатать следующие
выражения, то легко убедиться, что программа работает:
let х = 3.4;
let у = 2;
х + у * 2;
Однако следующие выражения показывают, что программа еще не работает так,
как надо:
let х = 3.4;
let у = 2;
х+у*2;
Чем различаются эти примеры? Посмотрим, что происходит. Проблема в том,
что мы небрежно определили лексему Имя. Мы даже "забыли" включить правило
вывода Имя в грамматику (раздел 7.8.2). Какие символы могут бы частью имени?
Буквы? Конечно. Цифры? Разумеется, если с них не начинается имя. Символ под-
черкивания? Нет? Символ +? Неужели?
Посмотрим на код еще раз. После первой буквы считываем строку в объект
класса string с помощью оператора >>. Он считывает все символы, пока не встре-
тит пробел. Так, например, строка х+у*2; является отдельным именем — даже за-
вершающая точка с запятой считывается как часть имени. Это неправильно и не-
приемлемо.274
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Что же сделать вместо этого? Во-первых, мы должны точно определить, что
представляет собой имя. а затем изменить функцию get О. Ниже приведено вполне
разумное определение имени: последовательность букв и цифр, начинающаяся
с буквы. Например, все перечисленные ниже строки являются именами.
а
ab
al
Z12
asdsddsfdfdasfdsa434RTHTD12345dfdsa8fsd888fadsf
А следующие строки именами не являются:
1а
as_s
#
as*
а саг
За исключением отброшенного символа подчеркивания это совпадает с правилом
языка C++. Мы можем реализовать его в разделе default в функции get ().
default;
If (isalpha(ch)) {
string s;
s += ch;
while (cln.get(ch) && (isalpha(ch) || isdigit(ch)))
s+=ch;
cin.putback(ch);
if (s == declkey) return Token(let); // ключевое слово let
return Token(name,в);
}
error("Bad token");
Вместо непосредственного считывания в объект string в считываем символ
и записываем его в переменную s, если он является буквой или цифрой. Инструкция
s+=ch добавляет (приписывает) символ ch в конец строки в. Любопытная инструкция
while (cin.get(ch) && (isalpha(ch) || isdigit(ch)) s+=ch;
считывает символ в переменную ch (используя функцию-член get() потока cin)
и проверяет, является ли он символом или цифрой. Если да, то она добавляет сим-
вол ch в строку s и считывает символ снова. Функция-член get () работает как опе-
ратор >>, за исключением того, что не может по умолчанию пропускать пробелы.
7.8.3. Предопределенные имена
Итак, теперь можем легко предопределить некоторые из них. Например, если
представить, что наш калькулятор будет использован для научных вычислений,
то нам понадобятся имена pi и е. В каком месте кода их следует определить?
В функции main О до вызова функции calculate () или в функции calculateO7.8. ПЕРЕМЕННЫЕ
275
до цикла Мы поместим их определения в функцию main (), поскольку они не яв-
ляются частью каких-либо вычислений.
int main О
try {
// предопределенные имена:
definename("pi п,3.1415926535);
define_name(пеп,2.7182818284);
calculate ();
keep window_open(); // обеспечивает консольный режим Windows
return 0;
}
catch (exceptions e) {
cerr << e.whatO << endl;
keep_window_open(n — ");
return 1;
}
catch (...) {
cerr << "exception \nn;
keep_window_open("—");
return 2;
}
7.8.4. Bee?
Еще нет. Мы внесли так много изменений, что теперь программу необходимо
снова протестировать, привести в порядок код и пересмотреть комментарии. Кроме
того, можно было бы сделать больше определений. Например, мы "забыли" об опе-
раторе присваивания (см. упр. 2), а наличие этого оператора заставит нас как-то
различать переменные и константы (см. упр. 3). Вначале мы отказались от исполь-
зования именованных переменных в калькуляторе. Теперь, просматривая код
их реализации, можем выбрать одну из двух реакций.
1. Реализация переменных была совсем неплохой; она заняла всего три дюжины
строк кода.
2. Реализация переменных потребовала много работы. Она коснулась каждой функ-
ции и внесла новую концепцию в проект калькулятора. Она увеличила размер
программы на 45%, а ведь мы еще даже не приступали к реализации оператора
присваивания.
Если учесть, что наша первая программа имеет значительную сложность, вторая
реакция является правильной. И вообще, это справедливо относительно любого
предложения, увеличивающего на 50% размер или сложность программы. В такой
ситуации целесообразнее написать новую программу, основанную на предыдущих
наработках. В частности, намного лучше создавать программу поэтапно, как мы
разрабатывали калькулятор, чем пытаться сделать ее целиком и сразу.276
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
Задание
1. Скомпилируйте файл calculator08buggy.cpp.
2. Пройдитесь по всей программе и добавьте необходимые комментарии.
3. В ходе комментирования вы обнаружите ошибки (специально вставленные
в код, чтобы вы их нашли). Исправьте их; в тексте книги их нет.
4. Тестирование: подготовьте набор тестовых вводных данных и используйте их
для тестирования калькулятора. Насколько полон ваш список? Что вы ищете?
Включите в список отрицательные числа, нуль, очень маленькие числа
и "странный" ввод.
5. Проведите тестирование и исправьте все ошибки, которые пропустили при ком-
ментировании.
6. Добавьте предопределенное имя к со значением 1000.
7. Предусмотрите возможность вычисления функции sqrt (), например sqrt (2+6.7).
Естественно, значение sqrt (x) — это квадратный корень из числа х; например
sqrt (9) равно 3.
8. Используйте стандартную функцию sqrt (), описанную в заголовочном файле
stdlibf acilities .h. He забудьте обновить комментарии и грамматику.
9. Предусмотрите перехват попыток извлечь квадратный корень из отрицательно-
го числа и выведите на экран соответствующее сообщение об ошибке.
1Q. Предусмотрите возможность использовать функцию pow(xfi), означающую
''умножить х на себя i раз"; например pow(2.5,3) равно 2.5*2.5*2.5. Аргу-
мент i должен быть целым числом. Проверьте это с помощью оператора %.
11. Измените "ключевое слово объявления" с let на #.
12. Измените "ключевое слово выхода" с q на exit. Для этого понадобится строка
для кодирования инструкции "выход", как мы уже делали для инструкции "let"
в разделе 7.8.2.
Контрольные вопросы
1. Зачем работать над программой, когда ее первая версия уже доказала свою ра-
ботоспособность? Перечислите причины.
2. Почему выражение "1+2; q", введенное в программу, не приводит к выходу
из нее после обнаружения ошибки?
3. Зачем нам понадобилась символьная константа с именем number?
4. Мы разбили функцию main() на две разные функции. Что делает новая функ-
ция и зачем мы разделили функцию main () ?
5. Зачем вообще разделять код на несколько функций? Сформулируйте принципы.
6. Зачем нужны комментарии и как они должны быть организованы?ТЕРМИНЫ
277
7. Что делает оператор narrowcast?
8 Как испол зуются символические константы?
9 Почему важна организация кода?
10. Как мы реализовали оператор % (остаток) применительно к числам с плавающей
точкой?
11. Что и как делает функция isdeclared () ?
12. Реализация "ключевого слова" let использует несколько символов. Как обеспе-
чен ввод этой лексемы как единого целого в модифицированном коде?
13. Сформулируйте правило, определяющее, что является именем в калькуляторе
и что нет?
14. Чем хороша идея о постепенной разработке программ?
15. Когда следует начинать тестирование?
16. Когда следует проводить повторное тестирование?
17. Как вы принимаете решение о том, какие функции следует сделать отдельными?
18. Как используются символические константы?
19. Зачем нужны комментарии?
20. Что следует писать в комментариях, а что нет?
21. Когда следует считать программу законченной?
Термины
восстановление
гонка за возможностями
история переработки
комментирование
Упражнения
1. Предусмотрите использование символа подчеркивания в именах.
2. Реализуйте оператор присваивания =, чтобы можно было изменять значение
переменной после ее объявления с помощью инструкции let.
3. Реализуйте именованные константы, которые действительно не могут изменять
свои значения. Подсказка: в класс Variable необходимо добавить функцию-
член, различающую константы и переменные и проверяющую это при выполне-
нии функции setvalue (). Если хотите дать пользователю возможность объ-
являть собственные именованные константы (а не только pi и е), то необходимо
добавить соответствующее обозначение, например const pi » 3.14;.
4. Функции get_value(), set_value(), isdeclaredO и declarename() опе-
рируют глобальной переменной var_table. Определите класс Symbol_table
"леса" символическая константа
обработка ошибок сопровождение
организация кода тестирование278
ГЛАВА 7 • ЗАВЕРШЕНИЕ ПРОГРАММЫ
с членом vartable типа vector<Variable> и функциями-членами get О,
set (), iedeclaredO и declare О. Перепишите программу так, чтобы
использовать переменную типа Symboltable.
5. Модифицируйте функцию Token_stream: :get () так, чтобы, обнаружив символ
перехода на следующую строку, она возвращала лексему Token (print). Для это-
го требуется обеспечить поиск разделителей и обработку символа ' \п'. Для этого
можно использовать стандартную библиотечную функцию isspace (ch), возвра-
щающую значение true, если символ ch является разделителем.
6. Каждая программа должна содержать подсказки для пользователя. Пусть при на-
жатии клавиши <Н> калькулятор выводит на экран инструкции по эксплуатации.
7. Измените команды q и h на quit и help соответственно.
8. Грамматика в разделе 7.6.4 является неполной (мы уже предостерегали вас
от чрезмерного увлечения комментариями); в ней не определена последователь-
ность инструкций, например 4+4; 5-6;, и не учтены усовершенствования, опи-
санные в разделе 7.8. Исправьте грамматику. Кроме того, добавьте в первый
и все остальные комментарии программы все, что считаете нужным.
9. Определите класс Table, содержащий объект типа vector<Variable> и функ-
ции-члены get (), set () и declare (). Замените вектор var_table в калькуля-
торе объектом класса Table с именем symboltable.
10. Предложите три усовершенствования калькулятора (не упомянутых в главе).
Реализуйте одно из них.
11. Модифицируйте калькулятор так, чтобы он работал только с целыми числами;
предусмотрите ошибки, возникающие при потере точности и переполнении.
12. Реализуйте оператор присваивания, чтобы значение переменной можно было
изменять после ее инициализации. Объясните целесообразность этого новшест-
ва и потенциальные проблемы, связанные с ним.
13. Переработайте две программы, написанные вами при выполнении упражнений
к главам 4 и 5. Приведите в порядок их код в соответствии с правилами, приве-
денными в данной главе. Найдите ошибки.
Послесловие
Итак, на простом примере мы увидели, как работает компилятор. Наш калькуля-
тор анализирует вводные данные, разбитые на лексемы, и распознает их по прави-
лам грамматики. Именно так функционирует компилятор. Однако после анализа ре-
зультатов компилятор создает представление (объектный код), который впоследст-
вии можно выполнить, а калькулятор немедленно вычисляет анализируемые
выражения; такие программы называются интерпретаторами, а не компиляторами.Технические детали:
функции и прочее
"Ни один талант не может преодолеть
пристрастия к деталям".
Восьмой закон Леви
В этой и следующей главах мы перейдем от общих рассуждений о про-
граммировании к нашему основному инструменту программирова-
ния — языку C++. Мы приведем технические детали, чтобы дать более широ-
кое и систематическое представление о функциональных возможностях языка
C++. Кроме того, эти главы представляют собой обзор многих понятий про-
граммирования, введенных ранее, и позволяют исследовать язык без привле-
чения новых методов и концепций.280
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
В этой главе...
8.5. Вызов функции и возврат значения
8.5.1. Объявление аргументов и тип возвращаемого
значения
8.5.2. Возврат значения
8.5.3. Передача параметров по значению
8.5.4. Передача параметров по константной ссылке
8.5.5. Передача параметров по ссылке
8.5.6. Сравнение механизмов передачи параметров
по значению и по ссылке
8.5.7. Проверка аргументов и преобразование типов
8.5.8. Реализация вызова функции
8.6. Порядок вычислений
8.6.1. Вычисление выражения
8.6.2. Глобальная инициализация
8.7. Пространства имен
8.7.1. Объявления using и директивы using
8.1. Технические детали
Если бы у нас был выбор, то мы предпочли бы говорить о программировании
вообще, а не о свойствах языка программирования. Иначе говоря, намного интерес-
нее изучать, как идеи выражаются в виде кода, чем вникать в технические детали
языка программирования, с помощью которого эти идеи воплощаются. Проведем
аналогию с естественным языком: ведь никто не станет спорить с тем, что обсуж-
дать стиль и идеи нового романа гораздо увлекательнее, чем изучать грамматику
и словарь. Нас намного больше интересуют сами идеи и способы их выражения
в виде кода, чем отдельны языковые конструкции.
Однако у нас не всегда есть выбор. Когда вы начинаете программировать, язык
программирования можно рассматривать как иностранный, изучать "грамматику
и словарь" которого просто необходимо. Именно этим мы и займемся в этой и сле-
дующих главах, но читатели должны помнить следующее.
• Мы изучаем программирование.
• Результатом нашей работы являются программы и системы.
• Язык программирования — это лишь средство.
Как ни странно, помнить об этом довольно сложно. Многие программисты не мо-
гут устоять перед увлечением мелкими деталями синтаксиса и семантики. В частно-
сти, слишком многие ошибочно полагают, что их первый язык программирования —
самый лучший. Пожалуйста, не попадайтесь в эту ловушку. Язык C++ во многих
отношениях прекрасный язык, но он не идеален; впрочем, то же самое можно сказать
о любом языке программирования.
8.1. Технические детали
8.2. Объявления и определения
8.2.1. Виды объявлений
8.2.2. Объявления переменных
и констант
8.2.3. Инициализация по умол-
чанию
8.3. Заголовочные файлы
8.4. Область видимости
08 2 ОБЪЯВЛЕНИЯ И ОПРЕДЕЛЕНИЯ
281
Большинство понятий, связанных с проектированием и программированием,
являются универсальными, и многие из них поддерживаются популярными
языками программирования. Это значит, что фундаментальные идеи и методы, изу-
чаемые нами в рамках достаточно продуманного курса программирования, перехо-
дят из одного языка в другой. Они могут быть реализованы — с разной степенью
легкости — во всех языках программирования. Однако технические детали языка
весьма специфичны. К счастью, языки программирования разрабатываются не
в вакууме, поэтому у понятий, которые мы изучаем в нашем курсе, очевидно, есть
аналоги в других языках программирования. В частности, язык C++ принадлежит
к группе языков, к которым помимо него относятся языки С (глава 27), Java и С#,
поэтому между ними есть много общего.
Заметьте, что, когда мы говорим о технических деталях языка, мы свободно опе-
рируем неопределенными именами, такими как f, g, x и у. Мы делаем это, чтобы
подчеркнуть техническую природу таких примеров, сделать их очень короткими
и не смешивать языковые детали с логикой программы. Когда вы увидите неопре-
деленные имена (которые ни в коем случае нельзя использовать в реальном коде),
пожалуйста, сосредоточьтесь на технических аспектах кода. Технические примеры
обычно содержат код, который просто иллюстрирует правила языка. Если вы ском-
пилируете и запустите его, то получите множество предупреждений о неиспользуе-
мых переменных, причем некоторые из таких программ вообще не делают никаких
осмысленных действий.
Пожалуйста, помните, что эту книгу не следует рассматривать как полное описа-
ние синтаксиса и семантики языка C++ (даже по отношению к свойствам, которые
мы рассматриваем). Стандарт ISO C++ состоит из 756 страниц, а объем книги Язык
программирования Страуструпа, предназначенной для опытных программистов,
превышает 1000 страниц. Наше издание не конкурирует с этими книгами ни по ох-
вату материала, ни по полноте его изложения, но соревнуется с ними по удобопо-
нятности текста и по объему времени, которое требуется для его чтения.
8.2. Объявления и определения
Объявление (declaration) — это инструкция, которая вводит имя в область види-
мости (раздел 8.4), устанавливает тип именованной сущности (например, перемен-
ной или функции) и, необязательно, устанавливает инициализацию (например,
начальное значение или тело функции).
Рассмотрим пример.
int а = 7; // переменная типа int
const double cd = 8.7; // константа с плавающей точкой
// двойной точности
double sqrt(double); // функция, принимающая аргумент типа double
//и возвращающая результат типа double
vector<Token> v; // переменная — вектор объектов класса Token
0282
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
До того как имя в программе на языке C++ будет использовано, оно должно
быть объявлено. Рассмотрим пример.
int main ()
{
cout « f(i) << ' \n';
}
Компилятор выдаст как минимум три сообщения об ошибках, связанных с не-
объявленными идентификаторами: сущности cout, f и i в программе нигде не объ-
явлены. Исправить ошибку, связанную с потоком cout, можно, включив в про-
грамму заголовочный файл etd_lib_f acilities .h, содержащий его объявление.
#include ■std_lib_facilities.hn // здесь содержится объявление
// потока cout
int main ()
с
cout << f(i) « ' \n';
>
Теперь осталось только две ошибки, вызванных отсутствием определения иден-
тификаторов. При создании реальных программ большинство определений разме-
щают в заголовочных файлах. Именно там определяются интерфейсы полезных
функциональных возможностей, которые сами определяются "в другом месте".
В принципе объявление лишь устанавливает, как некая сущность может быть ис-
пользована; оно определяет интерфейс функции, переменной или класса. Следует
помнить об одном очевидном, но невидимом преимуществе такого использования
объявлений: мы можем не беспокоиться о деталях определения потока cout и его
операторов «; мы просто включаем их объявления в программу с помощью дирек-
тивы #include. Мы можем даже не заглядывать в их объявления; из учебников,
справочников, примеров программ и других источников нам известно, как исполь-
зуется поток cout. Компилятор считывает объявления из заголовочных файлов,
необходимых для понимания кода.
Однако нам по-прежнему необходимо объявить переменные £ и i. И сделать
это можно следующим образом:
#include nstd_lib_facilities.h" // здесь содержится объявление
// потока cout
int f(int); // объявление переменной f
int main ()
{
int i = 7; // объявление переменной i
cout « f(i) << '\n';
}
Этот код компилируется без ошибок, поскольку каждое имя было определено,
но он не проходит редактирование связей (см. раздел 2.4), поскольку в нем не опреде-
лена функция f (); иначе говоря, мы нигде не указали, что именно делает функция f ().8 2 ОБЪЯВЛЕНИЯ И ОПРЕДЕЛЕНИЯ
283
Объявление, которое полностью описывает объявленную сущность, называют
определением (definition) Рассмотрим пример.
int а ш 7;
vector<double> v;
double sqrt(double d) {/*...*/ }
Каждое определение — это объявление, но только некоторые объявления одно-
временно являются определениями. Ниже приведены некоторые примеры объявле-
ний, которые не являются определениями; каждому из них должно соответствовать
определение, размещенное где-то в другом месте кода.
double sqrt(double); // здесь функция не имеет тела
extern int a; // "extern плюс отсутствие инициализатора"
// означает, что это — не определение
Сравнивая определения и объявления, мы придерживаемся общепринятого согла-
шения, которое устанавливает, что объявлением считается только объявление,
не являющееся определением, даже если вас немного запутывает такая терминология.
Определение устанавливает, на что именно ссылается имя. В частности, опреде-
ление переменной выделяет память для этой переменной. Следовательно, ни одну
сущность невозможно определить дважды. Рассмотрим пример.
double sqrt(double d) {/*...*/} // определение
double sqrt (double d) { /* . . .*/}// ошибка: повторное определение
int a; // определение
int a; // ошибка: повторное определение
И наоборот, объявление, которое не является одновременно объявлением, просто
сообщает, как можно использовать имя; оно представляет собой интерфейс, не вы-
деляет памяти и не описывает тело функции. Следовательно, одно и то же имя мож-
но объявлять несколько раз при условии, что объявления являются согласованными.
int х = 7; // определение
extern int х; // объявление
extern int x; // другое объявление
double sqrt(double); // объявление
double sqrt(double d) { /* . . .*/}// определение
double sqrt(double); // другое объявление функции sqrt
double sqrt(double); // еще одно объявление функции sqrt
int sqrt(double) ; // ошибка: несогласованное определение
Почему последнее объявление является ошибкой? Потому что в одной и той же
программе не может быть двух функций с именем sqrt. принимающих аргумент
типа double и возвращающих значения разных типов (int и double).
Ключевое слово extern, использованное во втором объявлении переменной х,
утверждает, что это объявление не является определением. Это редко бывает нуж-284
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ. ФУНКЦИИ И ПРОЧЕЕ
ным. Мы не рекомендуем делать это, но в принципе такие объявления можно встре-
тить в некоторых программах, особенно в программах, использующих слишком
много глобальных переменных (см. разделы 8.4 и 8.6.2).
Объявления:
»м1Н«1||'|^щ*_*|
double sqrt(double d)
Л..У ..^ -^W..
double sqrt(double d)
Определения:
double sqrt(double d)
{
// извлекает
// квадратный корень
. из числа d
intx = 7;
Г7Г Почему в языке C++ предусмотрены как объявления, так и определения?
1—1 Различие между ними отражает фундаментальное различие между тем, что
нам необходимо, чтобы использовать некую сущность (интерфейс), от того, что нам
необходимо, чтобы нечто делало то, для чего оно предназначено (реализация).
Объявление переменной устанавливает ее тип, но лишь определение создает реаль-
ный объект (выделяет память). Объявление функции также устанавливает ее тип
(типы аргументов и тип возвращаемого значения), но лишь определение создает те-
ло функции (выполняемые инструкции). Обратите внимание на то, что тело функ-
ции хранится в памяти как часть программы, поэтому правильно будет сказать,
что определения функций и переменных выделяют память, а объявления — нет.
Разница между объявлением и определением позволяет разделить программу на
части и компилировать их по отдельности. Объявления обеспечивают связь между
разными частями программы, не беспокоясь об определениях. Поскольку все объяв-
ления должны быть согласованы друг с другом и с единственным объявлением, ис-
пользование имен во всей программе должно быть непротиворечивым. Мы обсудим
этот вопрос в разделе 8.3. А здесь мы лишь напомним о грамматическом анализаторе
выражений из главы 6: функция expression () вызывает функцию term О, которая,
в свою очередь, вызывает функцию primary (), которая вызывает функцию expres-
sion (). Поскольку любое имя в программе на языке C++ должно быть объявлено
до того, как будет использовано, мы вынуждены объявить эти три функции.
double expression О ; // это лишь объявление, но не определение
double primary ()
{
// . . .
expression();
// . . .
}8.2 ОВШблЁНИЯ И ОПРЕДЕЛЕНИЯ 285
double term ()
{
а *
primary();
}
double expression()
{
// ...
term () ;
// ...
}
Мы можем расположить эти четыре функции в любом порядке, потому что вы-
зов одной из функций всегда будет предшествовать ее определению. Таким обра-
зом, необходимо предварительное объявление. По этой причине мы объявили
функцию expression () до определения функции primary О, и все было в поряд-
ке. Такие циклические вызовы весьма типичны.
Почему имя должно быть определено до его использования? Не могли бы мы
просто потребовать, чтобы компилятор читал программу (как это делаем мы), нахо-
дил определение и выяснял, какую функцию следует вызвать? Можно, но это при-
ведет к "интересным" техническим проблемам, поэтому мы решили этого не делать.
Спецификация языка C++ требует, чтобы определение предшествовало использова-
нию имени (за исключением членов класса; см. раздел 9.4.4).
Помимо всего прочего, существует обычная практика (не программирования):
когда вы читаете учебники, то ожидаете, что автор определит понятия и обозначе-
ния прежде, чем станет их использовать, в противном случае читатели будут выну-
ждены постоянно догадываться об их смысле. Правило "объявления для использо-
вания" упрощает чтение как для людей, так и для компилятора. В программирова-
нии существует и вторая причина, по которой это правило имеет большую важ-
ность. Программа может состоять из тысяч строк (а то и сотен тысяч), и большинст-
во функций, которые мы хотим вызвать, определены "где-то". Это "где-то" часто
является местом, куда мы даже не собираемся заглядывать. Объявления, которые
описывают только способ использования переменной или функции, позволяет нам
(и компилятору) не просматривать огромные тексты программ.
8.2.1. Виды объявлений
Программист может объявить множество сущностей в языке C++. Среди них
наиболее интересными являются следующие.
• Переменные. • Пространства имен (см. раздел 8.7).
• Константы. • Типы (классы и перечисления; см. главу 9).
• Функции (см. раздел 8.5). • Шаблоны (см. главу 19).28е ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
8.2.2. Объявления переменных и констант
Объявление переменной или константы задает ее имя, тип и (необязательно)
начальное значение. Рассмотрим пример.
int a; // без инициализации
double d = 7; // инициализация с помощью синтаксической конструкции =
vector<int> vi(10); // инициализация с помощью синтаксической
// конструкции ()
Полная грамматика языка описана в книге Язык программирования C++ Страуст-
рупа и в стандарте ISO C++.
Константы объявляются так же, как переменные, за исключением ключевого
слова const и требования инициализации.
const int x я 7; // инициализация с помощью синтаксической
// конструкции =
const int x2(9); // инициализация с помощью синтаксической
// конструкции ()
const int у; // ошибка: нет инициализации
Причина, по которой константа требует инициализации, очевидна: после объ-
явления константы она уже не может изменить свое значение. Как правило,
целесообразно инициализировать и переменные; переменная, не имеющая началь-
ного значения, способна вызвать недоразумения. Рассмотрим пример.
void f(int z)
{
int x; // неинициализированная переменная
// . . . здесь нет присваивания значений переменной х .
« •
х = 7; // присваивание значения переменной х
// . . .
}
Этот код выглядит вполне невинно, но что будет, если в первом пропущенном
фрагменте, отмеченном многоточием, будет использована переменная х? Рассмот-
рим пример.
void f(int z)
{
int x; // неинициализированная переменная
// . . . здесь нет присваивания значений переменной х . . .
if (z>x) {
// . . -
}
// . . -
х = 7; // присваивание значения переменной х
// . - .
}
Поскольку переменная х не инициализирована, выполнение оператора z>x может
привести к неопределенным последствиям. Сравнение z>x приведет к разным резуль-8 3. ЗАГбЛбвОЧНЫЕ ФАЙЛЫ 287
татам на разных компьютерах и даже на одном и том же компьютере в разных сеансах
работы В принципе оператор z>x может вызвать прекращение работы программы из-
за машинной ошибки, но чаще всего ничего не происходит, и мы получаем непредска-
зуемые результаты.
Естественно, такое непредсказуемое поведение программы нас не устраивает,
но если мы не проинициализируем переменные, то в итоге произойдет ошибка.
Напомним, что "глупые ошибки" (которые происходят при использовании
неинициализированных переменных) происходят из-за спешки или усталости.
Как правило, компиляторы пытаются предупредить программистов, но в сложных
программах — в которых такие ошибки и появляются чаще всего — они не могут
выловить все такие ошибки. Существуют люди, не привыкшие инициализировать
переменные. Часто это происходит потому, что они учили языки, в которых этого
не требовалось; вы можете встретить такие примеры в будущем. Пожалуйста, не ус-
ложняйте себе жизнь, забывая инициализировать переменные при их определении.
8.2.3. Инициализация по умолчанию
Возможно, вы заметили, что мы часто не инициализируем объекты классов
string, vector и т.д. Рассмотрим пример.
vector<string> v;
string s;
while (cin>>s) v.pushback(s);
Это не противоречит правилу, утверждающему, что переменные перед их ис-
пользованием должны быть проинициализированы. В данном случае, если мы зада-
ем начальные значения, происходит инициализация строк и векторов по умолча-
нию. Таким образом, вектор v пуст (т.е. не содержит элементов), и строка s перед
входом в цикл также пуста (ян). Механизм, гарантирующий инициализацию
по умолчанию, называется конструктором по умолчанию (default constructor).
К сожалению, язык C++ не предусматривает инициализацию по умолчанию для
встроенных типов. Лишь глобальные переменные по умолчанию инициализируются
нулем, но их использование следует ограничивать. Большинство полезных пере-
менных, к которым относятся локальные переменные и члены классов, не инициа-
лизируются, пока не указано их начальное значение (или не задан конструктор
по умолчанию).
Не говорите, что вас не предупреждали!
8.3. Заголовочные файлы
Как управлять объявлениями и определениями? Они должны быть согласован-
ными. В реальных программах могут быть десятки тысяч объявлений; программы
с сотнями тысяч объявлений тоже не редкость. Как правило, когда вы пишете про-
грамму, большинство используемых определений написано не вами. Например,
реализации потока cout и функции sqrt () были написаны много лет назад кем-то288
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Другим. Мы просто используем их. Главным средством управления сущностями,
определенными где-то в другом месте, в языке C++ являются заголовки. В принци-
пе заголовок (header) — это коллекция объявлений, записанных в файле, поэтому
заголовок часто называют заголовочным файлом (header file). Такие заголовки под-
ставляются в исходные файлы с помощью директивы #include. Например, вы мо-
жете решить улучшить организация исходного кода нашего калькулятора (см. главы
6 и 7), выделив объявления лексем в отдельный файл. Таким образом, можно опре-
делить заголовочный файл token. h, содержащий объявления, необходимые для ис-
пользования классов Token и Token_stream".
token.h:
//Объявления:
class Token {/*...*/};
class Token_stream {/*...*/);
token.cpp:
♦Include "token.h"
//Определения:
void Token_stream::|
{
buffer=t;
full=true;
}
_•»
Объявления классов Token и Tokenstream находятся в заголовке token.h
Их определения находятся в файле token.cpp. В языке C++ суффикс .h относите*
к заголовочным файлам, а суффикс .срр чаще всего используется для исходны?
файлов. На самом деле в языке C++ суффикс файла не важен, но некоторые компи
ляторы и большинство интегрированных сред разработки программ настаиваю!
на использовании определенных соглашений относительно суффиксов файлов.
В принципе директива #include "file.h" просто копирует объявления и:
файла file.h в ваш файл в точку, отмеченную директивой #include Например
мы можем написать заголовочный файл f. h.
// f-h
int f(int);
А затем можем включить его в файл f. срр,
// f.cpp
#include "f.h-
back(Token t)
calculator.cpp:
«include "token.h"
// использует:
■ • ■
Token_stream ts;
■ ■ ■
Token t = ts.get();
■ MM
ts.putback(t);8 3 ЗАГОЛОВОЧНЫЕ ФАЙЛЫ
289
int g(int i)
{
return f(i);
}
При компиляции файла f. cpp компилятор выполнит подстановку заголовочного
файла и скомпилирует следующий текст:
int f(int);
int g(int i)
{
return f(i);
}
Поскольку директива #include выполняется компилятором в самом начале,
выполняющая ее часть компилятора называется препроцессором (preprocessing)
(раздел А. 17).
=>| Для упрощения проверки согласованности заголовок следует включать как
=J в исходные файлы, использующие объявления, так и в исходные файлы, со-
держащие определения, соответствующие этим объявлениям. Это позволяет компи-
лятору находить ошибки на самых ранних этапах. Например, представьте себе,
что разработчик функции Tokenstream:: put back () сделал ошибки.
Token Tokenstrearn::putback(Token t)
{
buffer.push_back(t);
return t;
}
Этот фрагмент выглядит вполне невинно. К счастью, компилятор перехватывает
ошибки, потому что он видит (благодаря директиве #include) объявление функции
Tokenstream: :putback(). Сравнивая это объявление с соответствующим опре-
делением, компилятор выясняет, что функция putbackO не должна возвращать
объект класса Token, а переменная buffer имеет тип Token, а не vector<Token>,
так что мы не можем использовать функцию push_back (). Такие ошибки возника-
ют, когда мы работаем над улучшением кода и вносим изменения, забывая о необ-
ходимости согласовывать их с остальной частью программы.
Рассмотрим следующие ошибки:
Token t я ts.gettO; // ошибка: нет члена gett
// . . .
ts.putbackO; // ошибка: отсутствует аргумент
Компилятор немедленно выдаст ошибку; заголовок token.h предоставляет ему
всю информацию, необходимую для проверки.
Заголовочный файл std_lib_facilities.h содержит объявления стандартных
библиотечных средств, таких как cout, vector и sqrtO, а также множества про-
стых вспомогательных функций, таких как error О, не являющихся частью стан-
дартной библиотеки. В разделе 12.8 мы продемонстрируем непосредственное
использование заголовочных файлов стандартной библиотеки.290
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Заголовки обычно включаются во многие исходные файлы. Это значит, что заго-
ловок должен содержать лишь объявления, которые можно дублировать в несколь-
ких файлах (например, объявления функций, классов и числовых констант).
8.4. Область видимости
Область видимости (scope) — это часть текста программы. Каждое имя объяв-
ляется в своей области видимости и является действительным (т.е. находится в об-
ласти видимости), начиная с точки объявления и заканчивая концом данной облас-
ти. Рассмотрим пример.
void £()
g(); // ошибка: g() не принадлежит (пока) области видимости
void g()
f(); // OK: функция f() находится в области видимости
void h()
int х ■ у; // ошибка: переменная у не принадлежит (пока)
// области видимости
int у ж х; // ОК: переменная х находится в области видимости
g()j // ОК: функция д() находится в области видимости
>
Имена, принадлежащие области видимости, видны из вложенных в нее других
областей видимости. Например, вызов функции f () находится в области видимости
функции g (), которая является вложенной в глобальную область видимости. Гло-
бальная область видимости не вкладываются ни в какую другую. Правило, утвер-
ждающее, что имя должно быть объявлено до того, как будет использовано,
по-прежнему действует, поэтому функция f () не может вызывать функцию g ().
Существует несколько разновидностей областей видимости, которые можно ис-
пользовать для управления используемыми именами.
• Глобальная область видимости (global scope). Часть текста, не входящая ни
в одну другую область видимости.
• Пространство имен (namespace scope). Именованная область видимости,
вложенная в глобальную область видимости или другое пространство имен
(раздел 8.7).
• Область видимости класса (class scope). Часть текста, находящаяся в классе
(раздел 9.2).
• Локальная область видимости (local scope). Часть текста, заключенная в фи-
гурные скобки, {...}, в блоке или функции.
• Область видимости инструкции (например, в цикле for).8.4 ОБЛАСТЬ ВИДИМОСТИ
291
Основное предназначение области видимости — сохранить локальность имен,
чтобы они не пересекались с именами, объявленными в другом месте. Рассмотрим
пример.
int z = х+7;
void £(int x)
{
}
int g(int x)
{
}
int f = x+2;
return 2*f;
// функция f является глобальной;
// переменная х является локальной в функции f
// переменная z является локальной
// переменная g является глобальной;
// переменная х является локальной в функции g
// переменная f является локальной
Изобразим это графически.
Глобальная область видимости:
f:
0'-
X
z
X
f
Здесь переменная х, объявленная в функции f (), отличается от переменнойх,
объявленной в функции g (). Они не создают недоразумений, потому что принад-
лежат разным областям видимости: переменная х, объявленная в функции f О,
не видна извне функции £ (), а переменная х, объявленная в функции g (), не видна
извне функции g (). Два противоречащих друг другу объявления в одной и той же
области видимости создают коллизию (clash). Аналогично, переменная f объявлена
и используется в функции g () и (очевидно) не является функцией f ().
Рассмотрим логически эквивалентный, но более реальный пример использова-
ния локальной области видимости.
int max (int af int b) // переменная max является глобальной;
// а переменные а и b — локальными
{
return (a>=b) ? a : b;
}
int abs(int a) // переменная а, не имеющая отношения
//к функции max()
{
return (a<0) ? -а : а;
}292
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ- ФУНКЦИИ И ПРОЧЕЕ
Функции шах () и abs () принадлежат стандартной библиотеке, поэтому их не
нужно писать самому. Конструкция ?: называется арифметической инструкцией if
(arithmetic if), или условным выражением (conditional expression). Значение инструк-
ции (а>=Ь) ?а:Ь равно а, если а>=»Ь, и Ь — в противном случае. Условное выраже-
ние позволяет не писать длинный код наподобие следующего:
int max(int a, int b) // переменная max является глобальной;
// а переменные а и b — локальными
{
int m; // переменная m является локальной
if (а>=Ь)
m » а;
else
m в Ь;
return m;
}
Э| Итак, за исключением глобальной области видимости все остальные области
=1 видимости обеспечивают локальность имен. В большинстве случаев локаль-
ность имени является полезным свойством, поэтому к нему надо стремиться изо
всех сил. Когда мы объявляем свои переменные, функции и прочее в функциях,
классах, пространствах имен и так далее, то не хотим, чтобы они совпадали с име-
нами, объявленными кем-то другим. Помните: реальные программы содержат многие
тысячи именованных сущностей. Для того чтобы сохранить контроль над такими
программами, большинство имен должно быть локальными.
Рассмотрим более крупный технический пример, иллюстрирующий ситуацию,
в которой имена выходят за пределы области видимости в конце инструкции и бло-
ков (включая тела функций).
// здесь переменные г, i и v не видны
class My_vector {
vector<int> v; // переменная v принадлежит области
// видимости класса
public:
int largest()
{
int r ■ 0; // переменная г является локальной
// (минимальное неотрицательное целое число)
for (int i * 0; i<v.size(); ++i)
r * max(r,abs(v[i])) ; // переменная i принадлежит
// области видимости цикла
// здесь переменная i не видна
return r;
}
// здесь переменная г не видна
ъ
// здесь переменная v не видна
int xi // глобальная переменная — избегайте по возможности8.4 ОБЛАСТЬ ВИДИМОСТИ
293
int у;
int f()
{
int x; // локальная переменная
x = 7; // локальная переменная х
{
int х = у; // локальная переменная х инициализируется
// глобальной переменной у
++х; // переменная х из предыдущей строки
}
++х; // переменная х из первой строки функции f()
return x;
}
Если можете, избегайте ненужных вложений и сокрытий. Помните девиз:
"Будь проще!"
Чем больше область видимости имени, тем длиннее и информативнее должно
быть ее имя: хуже имен х, у и z для глобальных переменных не придумаешь.
Основная причина, по которой следует избегать глобальных переменных, заключа-
ется в том, что трудно понять, какие функции изменяют их значения. В больших
программах практически невозможно понять, какие функции изменяют глобальную
переменную. Представьте себе: вы пытаетесь отладить программу, и выясняется,
что глобальная переменная принимает неожиданное значение. Какая инструкция
присвоила ей это значение? Почему? В какой функции? Как это узнать?
Функция, присвоившая неправильное значение данной переменной, может нахо-
диться в исходном файле, который вы никогда не видели! В хорошей программе
может быть лишь несколько (скажем, одна или две) глобальных переменных.
Например, калькулятор, описанный в главах 6 и 7, содержит две глобальные пере-
менные: поток лексем ts и таблицу символов names.
Обратите внимание на то, что большинство конструкций в языке C++ создают
вложенные области видимости.
• Функции в классах: функции-члены (раздел 9.4.2).
class С {
public:
void f () ;
void g() // функция-член может быть определена в классе
{
}
};
void C::£() // определение функции-члена за пределами класса
{
// . • -
}1*4
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Это наиболее типичный и полезный вариант,
• Классы в других классах: члены-классы (или вложенные классы).
class С {
public:
struct М {
// . . .
}f
It . . .
ь
Это допустимо только в сложных классах; помните, что в идеале класс должен
быть маленьким и простым.
• Классы в функциях: локальные классы.
void fО
{
class L {
// . . .
b
// . . .
}
IvTl Избегайте таких конструкций; если вам нужен локальный класс, значит, ваша
^■^ функция слишком велика.
• Функции в других функциях: локальные функции (или вложенные функции).
void £()
{
void g() // незаконно
{
// . . .
>
// . . .
}
В языке C++ это не допускается; не поступайте так. Компилятор выдаст ошибку.
• Блоки в функциях и других блоках: вложенные блоки.
void f(int xf int у)
{
if (x>y) {
// ...
}
else {
// . . .
{
// . . .
}
// . . .
}8 5. ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
295
Вложенные блоки неизбежны, но они свидетельствуют о завышенной сложности
программы и уязвимы для ошибок.
В языке C++ существует еще одно средство — namespace, которое используется
исключительно для разграничения областей видимости (раздел 8.7).
==S| Следите за выравниванием фигурных скобок, обозначающих вложение.
= Если бы выравнивания не было, код было бы невозможно читать. Рассмотрим
пример.
// опасно уродливый код
struct X {
void f(int x) {
struct Y {
int f() { return 1; } int m; };
int m;
xn=x; Y m2;
return f (m2 .f()); }
int m; void g(int m) {
if (m) f(m+2); else {
g (m+2); } }
X() { } void m3() {
}
void main() {
X a; a.f(2);}
};
Неудобочитаемый код обычно скрывает ошибки. Если вы используете интегри-
рованные среды разработки программ, то они автоматически выравнивают фигур-
ные скобки (в соответствии со своими установками). Кроме того, существуют
"программы изящного форматирования", которые переформатируют исходный код
в файле (часто предлагая пользователю выбор). Однако окончательная ответствен-
ность за удобочитаемость кода лежит на его авторе.
8.5. Вызов функции и возврат значения
Функции позволяют нам выражать действия и вычисления. Если мы хотим
сделать что-то, заслуживающее названия, то пишем функцию. В языке C++
есть операторы (такие как + и *), с помощью которых можно вычислить новые зна-
чения по операндам, входящим в выражение, и инструкции (такие как for и if), по-
зволяющие управлять порядком вычислений. Для того чтобы организовать код из
этих примитивов, у нас есть функции.
Для выполнения своего предназначения функции принимают аргументы и, как
правило, возвращают результат. В этом разделе мы рассмотрим механизмы переда-
чи аргументов.
0296
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
8.5.1. Объявление аргументов и тип возвращаемого значения
Функции в языке C++ используются для названия и представления вычислений
и действий. Объявление функции состоит из типа возвращаемого значения, за кото-
рым следует имя функции и список формальных аргументов. Рассмотрим пример.
double fct(int a, double d) ; // объявление функции fct (без тела)
double fct(int a, double d) { return a*d; } // объявление функции fct
Определение состоит из тела функции (инструкций, выполняемых при ее вызове),
в то время как объявление, не являющееся определением, просто завершается точкой
с запятой. Формальные аргументы часто называют параметрами (parameters). Если
не хотите, чтобы функция имела аргументы, не указывайте параметры. Например:
int current_power() ; // функция current_power не имеет аргументов
Если хотите, чтобы функция не возвращала никаких значений, укажите вместо
типа возвращаемого значения ключевое слово void. Например:
void increase_power(int level); // функция increase_power
// ничего не возвращает
Здесь ключевое слово void означает "ничего не возвращает".
Параметры можно как именовать, так и не именовать. Главное, чтобы объявле-
ния и определения были согласованы друг с другом. Рассмотрим пример.
// поиск строки s в векторе vs;
// vs[hint] может быть подходящим местом для начала поиска
// возвращает индекс найденного совпадения; -1 означает "не найдена"
int my_find(vector<string> vsf string sf int hint); // именованные
// аргументы
int my_find(vector<string>f string, int) ; // неименованные аргументы
В объявлениях имена формальных аргументов не обязательны, просто они
очень полезны для создания хороших комментариев. С точки зрения компиля-
тора второе объявление функции myfindO так же правильно, как и первое: оно
содержит всю информацию, необходимую для ее вызова.
Как правило, все аргументы в объявлении имеют имена. Рассмотрим пример.
int my_find(vector<string> vs, string s, int hint)
// поиск строки s в векторе vs, начиная с позиции hint
{
if (hint<0 || vs.size()<=hint) hint = 0;
for (int i = hint; i<vs.size() ; ++i) // поиск, начиная
// с позиции hint
if (vs[i]==s) return i;
if (0<hint) { // если строка s не была найдена на позиции до hint
for (int i » 0; i<hint; ++i)
if (vs[i]==s) return i;
}
return -1;
}
08.5 ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
297
Переменная hint немного усложняет код, но она введена на основании предпо-
ложения, что пользователю может быть примерно известно, где в векторе находится
строка Однако представим себе, что мы использовали myf ind(), а затем выясни-
ли, что пользователи редко используют переменную hint, так что она лишь снижа-
ет производительность программы.. В таком случае переменная hint больше
не нужна, но за пределами нашего фрагмента есть множество вызовов функции
myf ind () с аргументом hint. Переписывать код мы не хотим (или не можем), по-
этому изменять объявления функции не будем myf ind О. Вместо этого мы просто
не будем использовать последний аргумент. Поскольку мы его не используем, оста-
вим его без имени.
int my_find(vector<string> vs, string s, int) // 3-й аргумент
// не используется
{
for (int i = 0; i<vs.size(); ++i)
if (vs[i]==s) return i;
return -1;
}
Полная грамматика объявлений функций изложена в книге Язык программиро-
вания C++ Страуструпа и в стандарте ISO C++.
8.5.2. Возврат значения
Функция возвращает вычисленное значение с помощью инструкции return.
Т f() // функция f() возвращает объект класса Т
{
V v;
// • • .
return v;
}
Т х = f ();
Здесь возвращаемое значение — это именно то значение, которые мы получили
бы при инициализации переменной типа Т значением типа V.
v v;
// • • .
Т t(v); // инициализируем переменную t значением v
Таким образом, возвращаемое значение — это форма инициализации. Функция,
объявившая возвращение значения, должна его возвращать. Например, в следую-
щем фрагменте возникает ошибка:
double my_abs(int х) // предупреждение: этот код содержит ошибки
{
if (x < 0)
return -x;
else if (x > 0)
return x;
} // ошибка: если х равно нулю, функция ничего не возвращает2*8
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
4fesfHa самом деле компилятор может не заметить, что вы "забыли" про вариант х=о.
Лишь некоторые компиляторы умеют это делать. Тем не менее, если функция
сложна, компилятор может не разобраться, возвращает ли она значение или нет, так
ТО> следует быть осторожным. Это значит, что программист сам должен убедиться,
что функция содержит инструкцию return или вызов функции error () как воз-
можный вариант выхода.
По историческим причинам функция main () представляет собой исключение из
правила. Выход из функции main О в ее последней точке эквивалентен инструкции
return 0, означающей успешное завершение программы.
В функции, не возвращающей никаких значений, инструкцию return можно
использовать для выхода из нее, не указывая возвращаемую переменную. Рассмот-
рим пример.
void print__until_s(const vector<atring> v, const string quit)
{
for(int i=0; i<v.eize(); ++i) {
if (v[i]==quit) return;
cout << v[i] « ' \n';
}
}
Как видим, достичь последней точки функции, перед именем которой стоит
ключевое слово void, вполне возможно. Это эквивалентно инструкции return;.
8.5.3. Передача параметров по значению
Г7[ Простейший способ передать аргумент функции заключается в пересылке ко-
■—■ пии его значения. Аргумент функции f () является локальной переменной, ко-
торая инициализируется при каждом ее вызове. Рассмотрим пример.
// передача по значению (функция получает копию передаваемого
// значения)
int f(int x)
{
х = х+1; // присваиваем локальной переменной х новое значение
return x;
}
int main()
{
int xx = 0;
cout « f(xx) << endl; // вывод: 1
cout « xx « endl; // вывод: 0; функция f () не изменяет хх
int yy в 7;
cout « f(yy) « endl; // вывод: 8
cout « yy « endl; // вывод: 7; функция f () не изменяет уу8.5. ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
299
Поскольку в функцию передается копия, инструкция х«х+1 в функции f () не из-
меняет значения переменных хх и уу, передаваемых ей при двух вызовах. Передачу
аргумента по значению можно проиллюстрировать следующим образом.
хх:
х:
Первый вызов:
Второй вызов:
УУ:
—,- -,
7
Копируем
значение
Копируем
значение
х:
0
7
Передача по значению представляет собой довольно простой механизм,
а ее стоимость определяется стоимостью копирования значения.
8.5.4. Передача параметров по константной ссылке
Передача по значению проста, понятна и эффективна, если передаются неболь-
шие значения, например переменные типа int, double или Token (см. раздел 6.3.2).
А что если передаваемое значение велико и представляет собой изображение
(занимающее несколько миллионов бит), большую таблицу чисел (например, не-
сколько тысяч целых чисел) или длинную строку (например, сотни символов)?
Тогда копирование оказывается очень затратным механизмом. Не стоит слишком
сильно беспокоиться о стоимости выполняемых операций, но делать ненужную
работу также не следует, так как это свидетельствует о плохом воплощении идеи,
которую мы хотим реализовать. Например, можно написать следующую функцию,
выводящую на экран вектор чисел с плавающей точкой:
void print (vector<double> v) // передача по значению; приемлемо?
{
cout << "{ ";
for (int i в 0; i<v.size(); ++i) {
cout « v[i] ;
if (i!=v.size()-l) cout « ", ";
}
cout << " }\n";
}
Функцию print О можно применять к векторам любых размеров. Рассмотрим
пример.
void f(int x)
{
vector<double> vdl(10); // небольшой вектор
vector<double> vd2(1000000); // большой вектор
vector<double> vd3 (x); // вектор неопределенного размера
If... заполняем векторы vdl, vd2, vd3 with значениями , . .
print(vdl);
print(vd2);
print(vd3);
}SOU
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Этот код работает, но при первом вызове функции print () будет скопирован
десяток чисел типа double (вероятно, 80 байт), при втором — миллионы чисел типа
double (вероятно, восемь мегабайт), а при третьем количество копируемых чисел
неизвестно. Возникает вопрос: "Зачем вообще что-то копировать?" Мы же хотим
распечатать вектор, а не скопировать его. Очевидно, нам нужен способ передачи
переменных функциям без их копирования. Например, если вы получили задание
составить список книг, находящихся в библиотеке, то совершенно не обязательно
приносить копии всех книг домой — достаточно взять адрес библиотеки, пойти ту-
да и просмотреть все книги на месте.
Итак, нам необходим способ передачи функции print () "адреса" вектора, а не
копии вектора. "Адрес" вектора называется ссылкой (reference) и используется сле-
дующим образом:
void print(const vector<double>& v) // передача по константной ссылке
{
cout « ■{ ■;
for (int i в 0; i<v.size(); ++i) {
cout << v[i] ;
if (il=v.size()-l) cout « ", ■;
}
cout « " }\n";
}
Символ & означает ссылку, а ключевое слово const предотвращает случайную
модификацию аргумента в функции print (). Кроме объявления аргумента, все ос-
тальное без изменений. Правда, теперь все операции будут производиться не над
копией, а над самим аргументом, полученным по ссылке. Такие аргументы называ-
ются ссылками, потому что они ссылаются на объекты, определенные вне функции.
Вызов функции print () остается точно таким же, как и раньше.
void f(int x)
{
vector<double> vdl(10); // небольшой вектор
vector<double> vd2(1000000); // большой вектор
vector<double> vd3 (x) ; // вектор неопределенного размера
II... заполняем векторы vdl, vd2, vd3 with значениями . . .
print (vdl);
print (vd2) ;
print(vd3);
}
Этот механизм можно проиллюстрировать графически.8 5 ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
301
v:
Ссылка на vd1 при первом вызове
Ссылка на vd2 при втором вызове
vd2:
Константная ссылка обладает полезным свойством: она не позволяет случайно
изменить объект, на который ссылается. Например, если мы сделаем глупую ошиб-
ку и попытаемся присвоить элементу вектора, полученного извне функции print О,
какое-то значение, то компилятор сразу выдаст сообщение об этом.
void print (const vector<double>& v) // передача по константной ссылке
{
// . . .
v[i] =7; // ошибка: v — константа (т.е. не может изменяться)
// . • •
}
Передача аргументов по константной ссылке — очень полезный и распростра-
ненный механизм. Вернемся к функции myf ind() (см. раздел 8.5.1), выполняющей
поиск строки в векторе строк. Передача по значению здесь была бы слишком неэф-
фективной.
int my_find(vector<string> vs, string s) ; // передача по значению:
// копия
Если вектор содержит тысячи строк, то поиск занял бы заметный объем времени
даже на быстром компьютере. Итак, мы можем улучшить функцию myfindO,
передавая ее аргументы по константной ссылке.
// передача по ссылке: без копирования, доступ только для чтения
int my_find(const vector<string>& vs, const string& s) ;
8.5.5. Передача параметров по ссылке
А что делать, если мы хотим, чтобы функция модифицировала свои аргументы?
Иногда это очень нужно. Например, мы можем написать функцию init(), которая
должна присваивать начальные значения элементам вектора.
void init(vector<double>& v) // передача по ссылке
{
for (int i = 0; i<v.size(); ++i) v[i] * i;
}
void g(int x)
{
vector<double> vdl(10); // небольшой вектор
vector<double> vd2(1000000); // большой вектор
vector<double> vd3 (x); // вектор неопределенного размера302
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
init(vdl);
lnit(vd2);
init(vd3);
}
Итак, мы хотим, чтобы функция init() изменяла вектор, являющийся ее аргу-
ментом. Иначе говоря, мы хотим не копировать его (т.е. передавать по значению),
не объявлять с помощью константной ссылки (т.е. передавать по константной ссыл-
ке), а просто передать обычную ссылку на вектор.
Рассмотрим ссылки более подробно. Ссылка — это конструкция, позволяющая
пользователю объявлять новое имя объекта. Например, int& — это ссылка на пере-
менную типа int. Это позволяет нам написать следующий код:
int i = 7;
int& r = i; //r — ссылка на переменную i i:
г = 9; // переменная i становится равной 9 г *
i = Ю;
cout « r « • ' « i « 'Xn1; // вывод: 10 10
Иначе говоря, любая операция над переменной г на самом деле означает опера-
цию над переменной i. Ссылки позволяют уменьшить размер выражений. Рассмот-
рим следующий пример:
vector< vector<double> > v; // вектор векторов чисел типа double
Допустим, нам необходимо сослаться на некоторый элемент v[f (х) ] [д(у)] не-
сколько раз. Очевидно, что выражение v[f (x)] [д(у)1 выглядит слишком гро-
моздко и повторять его несколько раз неудобно. Если бы оно было просто значени-
ем, то мы могли бы написать следующий код:
double val = v[f(x)] [g(y)l; // val — значение элемента v[f (x) ] [g(y)]
В таком случае можно было бы повторно использовать переменную val. А что,
если нам нужно и читать элемент v[f (х) ] [д(у)], и присваивать ему значения
v [f (х) ] [д (у) ] ? В этом случае может пригодиться ссылка.
doublefc var = v[f(x)] [g(y)]; // var — ссылка на элемент v[f (x) ] [g(y)]
Теперь можем как считывать, так и изменять элемент v[f (х) ] [д(у) ] с помо-
щью ссылки var. Рассмотрим пример.
var = var/2+sqrt(var);
Это ключевое свойство ссылок — оно может служить "аббревиатурой" объекта
и использоваться как удобный аргумент. Рассмотрим пример.
// передача по ссылке (функция ссылается на полученную переменную)
int f(lnt& x)
{
х в х+1;
return x;
}8.5 ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
303
int main()
{
int xx = 0;
cout << f(xx) << endl; // вывод: 1
cout << xx << endl; // вывод: 1; функция f () изменяет
// значение хх
int yy = 7;
cout << f(yy) << endl; // вывод: 8
cout << yy << endl; // вывод: 8; функция f () изменяет
// значение уу
}
Передачу аргументов по ссылке можно проиллюстрировать следующим образом.
Первый вызов (х ссылается на хх)
хх:
Второй вызов (х ссылается на уу)
Сравните этот пример с соответствующим примером из раздела 8.5.3.
\Г7\ Совершенно очевидно, что передача по ссылке — очень мощный механизм:
^—■" функции могут непосредственно оперировать с любым объектом, передавае-
мым по ссылке. Например, во многих алгоритмах сортировки перестановка двух
значений — весьма важная операция. Используя ссылки, можем написать функцию,
меняющую местами два числа типа double.
void swap(double& dl, doubles d2)
{
double temp = dl; // копируем значение dl в переменную temp
dl = d2; // копируем значение d2 в переменную d2
d2 = temp; // копируем старое значение dl в переменную d2
}
int main()
{
double x = 1;
double у s 2;
cout « "x == " « x << " y== " « у « '\n'; // вывод: х==1 y==2
swap(x,y);
cout « "x == " « x « " y== ■ « у « '\n'; // вывод: х==2 y==l
}
В стандартной библиотеке предусмотрена функция swap О для любого типа,
который можно скопировать, поэтому его можно применять к любому типу.304 ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПР(/ Е
8.5.6. Сравнение механизмов передачи параметров
по значению и по ссылке
Зачем нужны передачи по значению, по ссылке и по константной (|сьп
Для начала рассмотрим один формальный пример.
void f(int a, int& г, const int& cr)
{
++a; // изменяем локальную переменную а
++r; // изменяем объект, с которым связана ссылка г
++сг; // ошибка: ст — константная ссылка
}
Если хотите изменить значение передаваемого объекта, то должны использовать
неконстантную ссылку: передача по значению создаст копию, а передача по к н-
стантной ссылке предотвратит изменение передаваемого объекта. Итак, можно на
писать следующий код:
void g(int a, int& r, const int& cr)
{
++a; // изменяем локальную переменную а
++г; // изменяем объект, с которым связана ссылка г
int х * cr;// считываем объект, с которым связана ссылка сг
}
int main ()
{
int x = 0; •
int у щ 0;
int z ■ 0;
g(x,y,z); // х==0; у«1; Z==0
g(l,2,3); // ошибка: ссылочный аргумент г должен быть переменным
д(1#У#3); // ОК: поскольку ссылка сг является константной,
// можно передавать литерал
}
Итак, если хотите изменить значение объекта, передаваемого по ссылке, следует
передать объект. С формальной точки зрения целочисленный литерал 2 — это зна-
чение (а точнее, г-значение, т.е. значение в правой части оператора присваивания),
а не объект, хранящий значение. Для аргумента г функции f () требуется 1-значение
(т.е. значение, стоящее в левой части оператора присваивания).
Обратите внимание на то, что для константной ссылки 1-значение не требуется
С ней можно выполнять преобразования точно так же, как при инициализации или
при передаче по значению. При последнем вызове д(1,у,3) компилятор зарезер-
вирует переменную типа int для аргумента сг функции g ()
д(1#У#3); // означает: int compiler_generated = 3;
// g(l«y, compiler_generated)
Такой объект, создаваемый компилятором, называется временный о&ьекто\
(temporary object).8 5. ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ 305
Правило формулируется следующим образом.
1 Для передачи очень маленьких объектов следует использовать передачу аргу-
ментов по значению.
2. Для передачи больших объектов, которые нельзя изменять, следует использовать
передачу аргументов по константной ссылке.
3. Следует возвращать результат, а не модифицированный объект, передаваемый
по ссылке.
4 Передачу по ссылке следует использовать только в необходимых случаях.
Эти правила позволяют создавать очень простой, устойчивый к ошибкам
и очень эффективный код. Под очень маленькими объектами подразумевают-
ся одна или две переменных типа int, одна или две переменных типа double или
соразмерные им объекты. Если вы видите аргумент, передаваемый по обычной
ссылке, то должны предполагать существование функции, которая его модифициру-
ет. Третье правило отражает ситуацию, в которой требуется функция, изменяющая
значение переменной. Рассмотрим пример.
int incrl(int a) { return a+1; } // возвращает в качестве результата
// новое значение
void incr2 (int& a) { ++а; } // модифицирует объект,
// передаваемый по ссылке
int х = 7;
х = incrl(x); // совершенно очевидно
incr2(x); // совершенно непонятно
Почему же мы все-таки используем передачу аргументов по ссылке? Иногда это
оказывается важным в следующих ситуациях.
• Для манипуляций с контейнерами (например, векторами).
• Для функций, изменяющих сразу несколько объектов (в языке C++ функция
может возвращать с помощью оператора return только одно значение).
Рассмотрим пример.
void larger(vector<int>& vl, vector<int>& v2)
// каждый элемент вектора vl становится больше
// соответствующих элементов в векторах vl и v2;
// аналогично, каждый элемент вектора v2 становится меньше
{
if (vl.size()!=v2.size() error("largerО: different sizes");
for (int i=0; i<vl.size(); ++i)
if (vl[i]<v2[i])
swap(vl[i],v2[i]);
}306
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ. ФУНКЦИИ И ПРОЧЕЕ
void f()
{
vector<int> vx;
vector<int> vy;
// считываем vx и vy из входного потока
larger(vx#vy);
// . • .
}
Передача аргументов по ссылке — единственный разумный выбор для функции
larger().
Обычно следует избегать функций, модифицирующих несколько объектов одно-
временно. Теоретически есть несколько альтернатив, например возвращение объек-
та класса, хранящего несколько значений. Однако есть множество программ, до-
шедших до нас из прошлого, в которых функции модифицируют один или несколь-
ко аргументов, и этот факт следует учитывать. Например, в языке Fortran-—
основном языке программирования, используемом для математических вычислений
на протяжении более пятидесяти лет, — все аргументы передаются по ссылке. Мно-
гие программисты-вычислители копируют проекты, разработанные на языке Fortran,
и вызывают функции, написанные на нем.
Такие программы часто используют передачу по ссылке или по константной
ссылке. Если передача по ссылке используется только для того, чтобы избежать ко-
пирования, следует использовать константную ссылку. Следовательно, если мы ви-
дим аргумент, передаваемый по обычной ссылке, то это значит, что существует
функция, изменяющая этот аргумент. Иначе говоря, если мы видим аргумент, пере-
даваемый по ссылке, не являющейся константной, то должны прийти к выводу, что
эта функция не только может, но и обязана модифицировать этот аргумент. Таким
образом, мы обязаны тщательно проверить, действительно ли эта функция делает
то, для чего предназначена.
8.5.7. Проверка аргументов и преобразование типов
Передача аргумента представляет собой инициализацию формального аргумента
функции фактическим аргументом, указанным при ее вызове. Рассмотрим пример.
void f(T х);
f (у) ;
Т х=у; // инициализация переменной х значением переменной у
// (см раздел 8.2.2)
Вызов f (у) является корректным, если инициализация т х=у; произошла и есля
обе переменные с именем х могут принимать одно и то же значение. Рассмотрим
пример
void f(double);
void g(int у)8 5. ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
307
{
f (у) ;
double х (у) ;
}
Обратите внимание на то, что для инициализации переменной х значением пе-
ременной у необходимо преобразовать переменную типа int в переменную типа
double. To же самое происходит при вызове функции f (). Значение типа double,
полученное функцией f (), совпадает со значением, хранящимся в переменной х.
Iwl Преобразования часто оказываются полезными, но иногда преподносят сюр-
I—' призы (см. раздел 3.9.2). Следовательно, работая с преобразованиями, следует
проявлять осторожность. Передача переменной типа double в качестве аргумента
функции, ожидающей переменную типа int, редко можно оправдать.
void ff(int);
void gg(double x)
{
£f(x); // как понять, имеет ли это смысл?
}
Если вы действительно хотите усечь значение типа double до значения типа
int, то сделайте это явно.
void ggg(double x)
{
int xl = x; // усечение х
int x2 = int(x);
ff(xl);
ff(x2);
ff(x); // усечение х
ff(int(x));
}
Таким образом, следующий программист, просматривая этот код, сможет уви-
деть, что вы действительно думали об этой проблеме.
8.5.8. Реализация вызова функции
Как же на самом деле компилятор выполняет вызов функции? Функции expres-
sion О, term () и primary О, описанные в главах 6 и 7, прекрасно подходят для
иллюстрации этой концепции за исключением одной детали: они не принимают ни-
каких аргументов, поэтому на их примере невозможно объяснить механизм переда-
чи параметров. Однако погодите! Они должны принимать некую входную инфор-
мацию; если бы это было не так, то они не смогли бы делать ничего полезного'.
Они принимают неявный аргумент, используя объект ts класса Tokenstream для
получения входной информации; объект ts является глобальной переменной*
Это несколько снижает прозрачность работы программы. Мы можем улучшить эти
функции, позволив им принять аргумент типа Tokenetreams. Благодаря этому нам
не придется переделывать ни один вызов функции.308
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Во-первых, функция expression () совершенно очевидна; она имеет один аргу-
мент (ts) и две локальные переменные (left and t).
double expression(Token_stream& ts)
{
double left = term(ts);
Token t = ts.getO;
// . . .
}
Во-вторых, функция term О очень похожа на функцию expression(), за ис-
ключением того, что имеет дополнительную локальную переменную (d), которая
используется для хранения результата деления (раздел case ■ / •).
double term(Token_etream& ts)
{
double left = primary(ts);
Token t = ts.getO;
// . • •
case '/':
{
double d s primary(ts);
// . . .
}
// . . •
}
В-третьих, функция primary () очень похожа на функцию term(), за исключе-
нием того, что у нее нет локальной переменной left.
double primary(Token_stream& ts)
{
Token t = ts.get ();
switch (t.kind) {
case '(':
{ double d a expression(ts);
// . . .
}
// . . .
}
}
Теперь у этих функций нет скрытых глобальных переменных, и они превосходно
подходят для иллюстрации: у них есть аргумент и локальные переменные, и они вы-
зывают друг друга. Возможно, вы захотите освежить память и еще раз посмотреть,
как выглядят эти функции в законченном виде, но все их основные свойства, отно-
сящиеся к механизму вызова функций, уже перечислены.
\77\ При вызове функции реализация языка программирования создает структуру
I——' данных, содержащую копии всех ее параметров и локальных переменных»
Например, при первом вызове функции expression () компилятор создает струк-
туру напоминающую показанную на рисунке.8 5 ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
309
Вызов функции expression():
ts
left
Детали
реализации
Детали зависят от реализации, но в принципе к ним относится информация
о том, что функция должна вернуть управление и некое значение в точку вызова.
Такую структуру данных называют записью активации функции (function activation
record), или просто активационной записью. Каждая функция имеет свою собствен-
ную запись активации. Обратите внимание на то, что с точки зрения реализации па-
раметр представляет собой всего лишь локальную переменную.
Теперь функция expression() вызывает term(), поэтому компилятор создает
активационную запись для вызова функции term ().
Вызов функции expression():
Вызов функции term():
ts
lefe
t
Детали
реализации
ts
left
t
d
Детали
реализации
Направление
расширения
стека
1
Обратите внимание на то, что функция term () имеет дополнительную перемен-
ную d, которую необходимо хранить в памяти, поэтому при вызове мы резервируем
для нее место, даже если в коде она нигде не используется. Все в порядке. Для кор-
ректных функций (а именно такие функции мы явно или неявно используем в на-
шей книге) затраты на создание активизационных записей не зависят от их размера.
Локальная переменная d будет инициализирована только в том случае, если будет
выполнен раздел case ' /'.
Теперь функция term О вызывает функцию primary О, и мы получаем сле-
дующую картину.310
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Вызов функции expression!):
Ь#Ы ЬЩ |||^^КГ^*пЦ**4#»»^*"И*Т"
Детали
реализации
Вызов функции term():
Вызов функции primary():
,;, .fi.lfffl!',, ,i«,1 n-tf .j'l.i. ,'ili in mi.».
toft
» lnW iff nili- иЩпО» in H >)FiiC'i nlifmi ti
left
Детали
реализации
Детали
реализации
Направление
расширения
стека
Все это становится довольно скучным, но теперь функция primary () вызывает
функцию expression ().
Вызов функции expression!):
Вызов функции term():
Вызов функции primary!):
Вызов функции expression!):
ts
left
Детали
реализации
ts
left
t_
d
ts
left
Направление
расширения
стека8 5 ВЫЗОВ ФУНКЦИИ И ВОЗВРАТ ЗНАЧЕНИЯ
311
Г7[ Этот вызов функции expression () также имеет свою собственную активаци-
'■—' онную запись, отличающуюся от активационной записи первого вызова функ-
ции expression(). Хорошо это или плохо, но мы теперь попадаем в очень запу-
танную ситуацию, поскольку переменные left и t при двух разных вызовах будут
разными. Функция, которая прямо или (как в данном случае) косвенно вызывает се-
бя, называется рекурсивной (recursive). Как видим, рекурсивные функции являются
естественным следствием метода реализации, который мы используем для вызова
функции и возврата управления (и наоборот).
Итак, каждый раз, когда мы вызываем функцию стек активационных записей
(stack of activation records), которую часто называют просто стеком (stack), увели-
чивается на одну запись. И наоборот, кода функция возвращает управление, ее за-
пись активации больше не используется. Например, когда при последнем вызове
функции expression () управление возвращается функции primary О, стек воз-
вращается в предыдущее состояние.
Вызов функции expressionQ:
Вызов функции term():
Вызов функции primary():
ts
left
t
Детали
реализации
ts
left
t
d
Детали
реализации
ts
t
d
Детали
реализации
Направление
расширения
стека
.
Когда функция primary() возвращает управление функции term(), стек воз-
вращается в состояние, показанное ниже.
И так далее. Этот стек, который часто называют стеком вызовов (call stack), —
структура данных, которая увеличивается и уменьшается с одного конца в соответ-
ствии с правилом: первым вошел — первым вышел.
Запомните, что детали реализации стека зависят от реализации языка C++,
но в принципе соответствуют схеме, описанной выше. Надо ли вам знать, как pea-312
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Вызов функции expressionQ:
Вызов функции term():
left
Детали *^
реализации
t *»»>*■■ ^■■■МЕИИ"'
left
Детали
реализации
Направление
расширения
стека
лизованы вызовы функции? Разумеется, нет; мы и до этого прекрасно обходились,
но многие программисты любят использовать термины "активационная запись"
и "стек вызовов", поэтому лучше понимать, о чем они говорят.
8.6. Порядок вычислений
Выполнение программы происходит инструкция за инструкцией в соответствии
с правилами языка. Когда поток выполнения достигает определения переменной,
происходит ее создание, т.е. в памяти выделяется память для объекта, и этот объект
инициализируется. Когда переменная выходит из области видимости, она уничто-
жается, т.е. объект, на который она ссылалась, удаляется из памяти, и компилятор
может использовать ранее занимаемый им участок памяти для других целей. Рас-
смотрим пример.
string programname = "silly";
vector<string> v; // v — глобальная переменная
void f()
{
string s; // s — локальная переменная в функции f
while (cin>>s && sl=nquit") {
string stripped; // stripped — локальная переменная в цикле
string not_letters;
for (int i=0; i<s.size(); ++i) // i находится в области
// видимости инструкции
if (isalpha(s[i]))
stripped += s[i];
else
not_letters += s[i];
v.push_back(stripped);
}
//
//8.6 ПОРЯДОК ВЫЧИСЛЕНИЙ
313
Глобальные переменные, такие как programname и v, инициализируются до
выполнения первой инструкции функции main (). Они существуют, пока программа
не закончит работу, а потом уничтожаются. Они создаются в порядке следования
своих определений (т.е. переменная programname создается до переменной v),
а уничтожаются — в обратном порядке (т.е. переменная v уничтожается до пере-
менной programname).
Когда какая-нибудь функция вызывает функцию f (), сначала создается перемен-
ная s; иначе говоря, переменная s инициализируется пустой строкой. Она будет суще-
ствовать, пока функция f () не вернет управление. Каждый раз, когда мы входим
в тело цикла while, создаются переменные stripped и notletters. Поскольку пе-
ременная stripped определена до переменной notletters, сначала создается пе-
ременная stripped. Они существуют до выхода из тела цикла. В этот момент они
уничтожаются в обратном порядке (иначе говоря, переменная notletters уничто-
жается до переменной stripped) и до того, как произойдет проверка условия выхода
из цикла. Итак, если, до того, как мы обнаружим строку quit, мы выполним цикл де-
сять раз, переменные stripped и not_letters будут созданы и уничтожены десять раз.
Каждый раз, когда мы входим в цикл for, создается переменная i. Каждый раз,
когда мы выходим из цикла for, переменная i уничтожается до того, как мы дос-
тигнем инструкции v.pushback (stripped);.
Обратите внимание на то, что компиляторы (и редакторы связей) — довольно
разумны и способны оптимизировать код. В частности, компиляторы не выделяют
и не освобождают память чаще, чем это действительно требуется.
8.6.1. Вычисление выражения
Порядок вычисления подвыражений управляется правилами, которые больше
ориентируются на оптимизацию кода, чем на удобство работы программиста.
Это неудобно, но в любом случае следует избегать чрезмерно сложных выражений.
Помните простое правило: если изменяете значение переменной в выражении, то не
используйте его дважды в одном и том же выражении. Рассмотрим пример.
v[i] в ++i; // неопределенный порядок вычислений
v[++i] = i; // неопределенный порядок вычислений
int х = ++i + ++i; // неопределенный порядок вычислений
cout << ++i << ' ■ << i « '\n'; // неопределенный порядок вычислений
f(++i,++i); // неопределенный порядок вычислений
К сожалению, не все компиляторы выдают предупреждение о таких ошибках;
это плохо, потому что нельзя рассчитывать на то, что результаты будут одинаковы-
ми при выполнении вычислений на другом компьютере, при использовании других
компиляторов или при других установках оптимизатора.
Компиляторы действительно по-разному обрабатывают этот код; избегайте
таких ситуаций.
0314
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Обратите внимание на то, что оператор = (присваивание) в выражениях исполь-
зуется наряду с остальными, поэтому нет никакой гарантии того, что левая часть
оператора будет вычислена раньше правой части. По этой причине выражение
v [++i] = i имеет неопределенный результат.
8.6.2. Глобальная инициализация
Глобальные переменные (и переменные из пространства имен; раздел 8.7) в от-
дельной единице трансляции инициализируются в том порядке, в котором они по-
являются. Рассмотрим пример.
// файл fl.cpp
int xl = 1;
int yl = xl+2; // переменная yl становится равной З
Эта инициализация логически происходит до выполнения кода в функции
main (). Использование глобальной переменной, за исключением редких ситуаций,
нецелесообразно. Мы уже говорили, что не существует эффективного способа, по-
зволяющего программисту определить, какие части программы считывают или за-
писывают переменную (см. раздел 8.4). Другая проблема заключается в том, что по-
рядок инициализации глобальных переменных не определен. Рассмотрим пример.
// файл f2.cpp
extern int yl;
int y2 = yl+2; // переменная у2 становится равной 2 или 5
Такой код нежелателен по нескольким причинам: в нем используются глобаль-
ные переменные, которые имеют слишком короткие имена, и сложная инициализа-
ция глобальных переменных. Если глобальные переменные в файле fl.cpp ини-
циализируются до глобальных переменных в файле f 2. срр, то переменная у2 будет
инициализирована числом 5 (как наивно ожидает программист).
Однако, если глобальные переменные в файле f 2. срр инициализируются до гло-
бальных переменных в файле f 1. срр, переменная у2 будет инициализирована числом
2 (поскольку память, используемая для глобальных переменных, инициализируется
нулем до попытки сложной инициализации). Избегайте этого и старайтесь не исполь-
зовать нетривиальную инициализацию глобальных переменных; любой инициализа-
тор, отличающийся от константного выражения, следует считать сложным.
Но что же делать, если нам действительно нужна глобальная переменная (или
константа) со сложной инициализацией? Например, мы можем предусмотреть зна-
чение по умолчанию для переменных типа Date.
const Date default_date(1970# 1,1) ; // дата по умолчанию: 1 января 1970
Как узнать, что переменная def aultdate никогда не использовалась до своей
инициализации? В принципе мы не можем этого знать, поэтому не должны писать
это определение. Чаще всего для проверки используется вызов функции, возвра-
щающей некое значение. Рассмотрим пример.8.7. ПРОСТРАНСТВА ИМЕН
315
const Date defaultdate() // возвращает дату по умолчанию
{
return Date(1970,1,1);
}
Эта функция создает объект типа Date каждый раз, когда вызывается функция de-
fault_date(). Часто этого вполне достаточно, но если функция defaultdateO
вызывается часто, а создание объекта класса Date связано с большими затратами,
предпочтительнее было бы конструировать его только один раз. В таком случае код
мог бы выглядеть так:
const Datefc defaultdate()
{
static const Date dd(1970,l,l) ; // инициализируем dd
// только при первом вызове
return dd;
}
Статическая локальная переменная инициализируется (создается) только при
первом вызове функции, в которой она объявлена. Обратите внимание на то, что мы
вернули ссылку, чтобы исключить ненужное копирование, и, в частности, вернули
константную ссылку, чтобы предотвратить несанкционированное изменение значе-
ния аргумента при вызове функции. Рассуждения о передаче аргумента (см. раз-
дел 8.5.6) относятся и к возвращаемому значению.
8.7. Пространства имен
Для организации кода в рамках функции используются блоки (см. раздел 8.4).
Для организации функций, данных и типов в рамках типа используется класс
(глава 9). Предназначение функций и классов заключается в следующем.
• Они позволяют определить множество сущностей без опасения, что их имена
совпадут с другими именами в программе.
• Позволяют именовать то, что мы определили.
Нам нужно иметь средство для организации классов, функций, данных и типов
в виде идентифицируемой и именованной части программы, не прибегая к определе-
нию типа. Языковый механизм, позволяющий осуществить такую группировку объ-
явлений, называют пространством имей (namespace). Например, мы можем создать
графическую библиотеку с классами Color, Shape, Line, Function и Text (глава 13).
namespace Graph_lib {
struct Color {/*...*/};
struct Shape { /* . . . */ };
struct Line : Shape {/*...*/};
struct Function : Shape { /* . . . */ }i
struct Text : Shape { /* . . . */ };
// . . .
int gui_main() {/*...*/}316
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
Очень вероятно, что вы также захотите использовать эти имена, но теперь это
уже не имеет значения. Вы можете определить сущность с именем Text, но ее уже
невозможно перепутать с нашим классом, имеющим то же имя. Наш класс называ-
ется Graphlib: :Text, а ваш класс— просто Text. Проблема возникнет только
втом случае, если в вашей программе есть класс или пространство имен
Graphlib, в которое входит класс Text. Имя Graphlib довольно неудачное; мы
выбрали его потому, что "прекрасное и очевидное'* имя Graphics имеет больше
шансов встретиться где-нибудь еще.
Допустим, ваш класс Text является частью библиотеки для обработки текстов.
Та же логика, которая заставила нас разместить графические средства в пространст-
ве имен Graphlib, подсказывает, что средства для обработки текстов следует
поместить в пространстве имен, скажем, с именем TextLib.
namespace TextLib {
class Text { /* . . . */ };
class Glyph { /* . . . */ };
class Line {/*...*/};
// . . .
}
Если бы мы использовали оба пространства имен одновременно, то столкнулись
бы с реальной проблемой. В этом случае действительно возникла бы коллизия меж-
ду именами классов Text и Line. И что еще хуже, если бы мы были не создателями,
а пользователями библиотеки, то не никак не смогли бы изменить эти имена и ре-
шить проблему. Использование пространств имен позволяет избежать проблем;
иначе говоря, наш класс Text— это класс Graphlib: :Text, а ваш— Tex-
tLib :: Text. Имя, составленное из имени пространства имен (или имени класса)
и имени члена с помощью двух двоеточий, ::, называют полностью определенным
именем (fully qualified name).
8.7.1. Объявления using и директивы using
Писать полностью определенные имена довольно утомительно. Например, сред-
ства стандартной библиотеки языка C++ определены в пространстве имен std
и могут использоваться примерно так:
#include<string> // доступ к библиотеке string
#include<iostream> // доступ к библиотеке iostream
int main()
{
std::string name;
std::cout << "Пожалуйста, введите имя\п";
std::cin >> name;
std::cout << "Привет, " << name << '\n';
}8 7. ПРОСТРАНСТВА ИМЕН
317
Тысячи раз обращаясь к элементам стандартной библиотеки string и cout, мы
на самом деле вовсе не хотим каждый раз указывать их полностью определенные
имена— std:: string и std: :cout. Напрашивается решение: один раз и навсегда
указать, что под классом string мы имеем в виду класс std:: string, а под пото-
ком cout — ПОТОК std: : cout И Т.Д.
using std::string; // string означает std::string
using std::cout; // cout означает std::cout
// • . .
Эта конструкция называется объявлением using. Она эквивалентна обращению
"Грэг", которое относится к Грэгу Хансену при условии, что никаких других Грэгов
в комнате нет.
Иногда мы предпочитаем ссылаться на пространство имен еще "короче": "Если
вы не видите объявления имени в области видимости, ищите в пространстве имен
std". Для того чтобы сделать это, используется директива using,
using namespace std; // открывает доступ к именам из пространства std
Эта конструкция стала общепринятой.
#include<string> // доступ к библиотеке string
#include<iostream> // доступ к библиотеке iostream
using namespace std; // открывает доступ к именам из пространства std
int main()
{
string name;
cout << "Пожалуйста, введите имя\п";
cin >> name;
cout << "Привет, " << name << ' \n';
}
Здесь поток cin— это поток std: :cin, класс string— это класс std::string
и т.д. Поскольку мы используем заголовочный файл std_lib_facilities.h, не сто-
ит беспокоиться о стандартных заголовках и пространстве имен std. Мы рекоменду-
ем избегать использования директивы using для любых пространств имен, за исклю-
чением тех из них, которые широко известны в конкретной области приложения, на-
пример пространства имен std. Проблема, связанная с чрезмерным использованием
директивы using, заключается в том, что мы теряем след имен и рискуем создать
коллизию. Явная квалификация с помощью соответствующих имен пространств имен
и объявлений using не решает эту проблему. Итак, размещение директивы using
в заголовочный файл (куда пользователю нет доступа) — плохая привычка. Однако,
для того чтобы упростить первоначальный код, мы разместили директиву using для
пространства имен std в заголовочном файле std_lib_facilities.h. Это позволи-
ло нам написать следующий код:318
ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
«include "std_lib_facilities.h"
int main ()
{
string name;
cout « "Пожалуйста, введите иия\п";
cin » name;
cout << "Привет, ■ << name << '\n';
}
Мы обещаем больше никогда так не делать, если речь не идет о пространстве
имен std.
Задание
1. Создайте три файла: my.h, my.cpp и use.cpp. Заголовочный файл my.h содер-
жит следующий код:
extern int foo;
void print_foo();
void print(int);
Исходный файл my.cpp содержит директивы «include для вставки файлов
my.h и std_lib_f acilities ,h, определение функции printf oo О для вывода
значения переменной foo в поток cout и определение функции print(int i) для вы-
вода в поток cout значения переменной i.
Исходный файл use.cpp содержит директивы #include для вставки файла myJi,
определение функции main() для присвоения переменной foo значения 7 и выво-
да ее на печать с помощью функции print_foo(), а также для вывода значения 99
с помощью функции print(). Обратите внимание на то, что файл use.cpp не со-
держит директивы #include std_lib_facilities.h, поскольку он не использует явно
ни одну из его сущностей.
Скомпилируйте эти файлы и запустите их. Для того чтобы увидеть результаты вы-
вода на печать в системе Windows, в проект следует включить функции use.cpp
и my.cpp и использовать в файле use.cpp код { char cc; cin»cc; }.
2. Напишите три функции: swapv (int, int), swap_r (int&, int&) и swap_cr (conet
int&, const int&). Каждая из них должна иметь тело
{ int temp; temp = а, а=Ь; b=temp; }
где а и Ь — имена аргументов.
Попробуйте вызвать каждую из этих функций, как показано ниже.
int х = 7;
int у = 9;
swap?(x,у); // замените знак ? буквами v, r или сг
swap?(7,9);
const int ex = 7;
const int cy = 9;
swap?(cx.cy);КОНТРОЛЬНЫЕ ВОПРОСЫ
319
swap?(7.7,9.9);
double dx » 7.7;
double dy ■ 9.9;
swap_?(dx,dy);
swap_? (dx, dy) ;
Какие вызовы будут скомпилированы и почему? После каждой скомпилирован-
ной перестановки выведите на экран значения аргументов, чтобы убедиться, что
они действительно поменялись местами. Если результат вас удивит, обратитесь
к разделу 8.6.
3. Напишите программу, использующую единственный файл, содержащий про-
странства имен х, Y и Z, так, чтобы функция main (), приведенная ниже, работа-
ла правильно,
int main()
{
X::var = 7;
X::print(); // выводим переменную var из пространства имен X
using namespace Y;
var =9;
print(); // выводим переменную var из пространства имен Y
{ using Z::var;
using Z::print;
var =11;
print О; // выводим переменную var из пространства имен Z
}
print(); // выводим переменную var из пространства имен Y
X::print(); // выводим переменную var из пространства имен X
}
Каждое пространство имен должно содержать определение переменной var
и функции print (), выводящей соответствующую переменную var в поток cout.
Контрольные вопросы
1. В чем заключается разница между объявлением и определением?
2. Как синтаксически отличить объявление функции от определения функции?
3. Как синтаксически различить объявление переменной от определения пере-
менной?
4. Почему функции из программы, имитирующей работу калькулятора в главе 6,
нельзя использовать, не объявив их заблаговременно?
5. Чем является инструкция int a; — определением или просто объявлением?
6. Почему следует инициализировать переменные при их объявлении?
7. Из каких элементов состоит объявление функции?
8. Какую пользу приносит включение файлов?
9. Для чего используются заголовочные файлы?320 ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
10. Какую область видимости имеет объявление?
11. Перечислите разновидности областей видимости. Приведите пример каждой из них.
12. В чем заключается разница между областью видимости класса и локальной
областью видимости?
13. Почему программист должен минимизировать количество глобальных пере-
менных?
14. В чем заключается разница между передачей аргумента по значению и переда-
чей аргумента по ссылке?
15. В чем заключается разница между передачей аргумента по значению и переда-
чей по константной ссылке?
16. Что делает функция swap () ?
17. Следует ли определять функцию с параметром типа vector<double>, переда-
ваемым по значению?
18. Приведите пример неопределенного порядка выполнения вычислений. Какие
проблемы создает неопределенный порядок вычислений?
19. Что означают выражения х&&у и х | | у?
20. Соответствуют ли стандарту языка C++ следующие конструкции: функции
внутри функций, функции внутри классов, классы внутри классов, классы внут-
ри функций?
21. Что входит в активационную запись?
22. Что такое стек вызовов и зачем он нужен?
23. Для чего нужны пространства имен?
24. Чем пространство имен отличается от класса?
25. Объясните смысл объявления using.
26. Почему следует избегать директив using в заголовочных файлах?
27. Опишите пространство имен std.
Термины
const заголовочный файл
extern инициализация
namespace локальная область
видимости
return необъявленный
идентификатор
активационная запись области видимости
пространства имен
аргумент область видимости
вложенный блок область видимости класса
определение функции
параметр
передача аргумента
передача по значению
передача по константной
ссылке
передача по ссылке
рекурсияУПРАЖНЕНИЯ
321
возвращаемое значение область видимости стек вызовов
инструкции
глобальная область вида- объявление технические детали
мости
директива using объявление using функция
заблаговременное определение
объявление
Упражнения
1. Модифицируйте программу-калькулятор из главы 7, чтобы поток ввода стал яв-
ным параметром (как показано в разделе 8.5.8). Кроме того, напишите конст-
руктор класса Tokenstream и создайте параметр типа istream&, так, чтобы,
когда вы поймете, как создать свои собственные потоки ввода и вывода (напри-
мер, с помощью файлов), смогли использовать калькулятор, использующий их.
2. Напишите функцию print (), которая выводит в поток cout вектор целых чи-
сел. Пусть у нее будет два аргумента: строка для комментария результатов
и объект класса vector.
3. Создайте вектор чисел Фибоначчи и выведите их на печать с помощью функции
из упр. 2. Для того чтобы создать вектор, напишите функцию f ibonacci (х,
у, v,n), в которой аргументы х и у имеют тип int, аргумент v является пустой
переменной типа vector<int>, а аргумент п - это количество элементов, подле-
жащих записи в вектор v; элемент v [0] равен х, a v [1] — у. Число Фибоначчи —
это элемент последовательности, в которой каждый элемент является суммой двух
предьщущих. Например, последовательность начинается с чисел 1 и 2, за ними
следуют числа 1,2,3,6,9,15,24 Функция f ibonacci О должна генерировать
такую последовательность, начинающуюся с чисел х и у.
4. Переменная типа int может хранить целые числа, не превышающие некоторого
максимального числа. Вычислите приближение этого максимального числа
с помощью функции £ ibonacci О.
5. Напишите две функции, изменяющие порядок следования элементов в объекте
типа vector<int>. Например, вектор 1, 3, 5, 7, 9 становится вектором 9, 7, 5,
3,1. Первая функция, изменяющая порядок следования элементов на проти-
воположный, должна создавать новый объект класса vector, а исходный объект
класса vector должен оставаться неизменным. Другая функция должна изме-
нять порядок следования элементов без использования других векторов.
(Подсказка: как функция swap.)
6. Напишите варианты функций из упражнения 5 для класса vector<string>.
7. Запишите пять имен в вектор vector<string> name, затем предложите поль-
зователю указать возраст названных людей и запишите их в вектор vec-ГЛАВА 8 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: ФУНКЦИИ И ПРОЧЕЕ
tor<double> age. Затем выведите на печать пять пар (name [i], age [13). Упоря-
дочьте имена (sort (name.begin О , name, end ())) и выведите на печать пары
(name [i], age [i]). Сложность здесь заключается в том, чтобы получить вектор
age, в котором порядок следования элементов соответствовал бы порядку следо-
вания элементов вектора name. (Подсказка: перед сортировкой вектора
age создайте его копию и используйте ее для получения упорядоченного векто-
ра age. Затем выполните упражнение снова, разрешив использование произволь-
ного количества имен.)
8. Напишите простую функцию randintO, генерирующую псевдослучайные
числа в диапазоне [0:MAXINT]. (Подсказка: Д. Кнут Искусство программи-
рования, том 2.)
9. Напишите функцию, которая с помощью функции randint () из предыдущего
упражнения вычисляет псевдослучайное целое число в диапазоне [a:b): rand_
in_range(int a, int b). Примечание: эта функция очень полезна для созда-
ния простых игр.
10. Напишите функцию, которая по двум объектам, price и weight, класса
vector<double> вычисляет значение ("индекс"), равное сумме всех произведе-
ний price [i] *weight [i]. Заметьте, что должно выполняться условие weight,
size()<=price.size ().
11. Напишите функцию maxv (), возвращающую наибольший элемент вектора.
12. Напишите функцию, которая находит наименьший и наибольший элементы век-
тора, являющегося ее аргументом, а также вычисляющую их среднее и медиану.
Результаты можно вернуть либо в виде структуры struct, либо с помощью ме-
ханизма передачи аргументов по ссылке. Какой из этих двух способов следует
предпочесть и почему?
13. Усовершенствуйте функцию print_until_s () из раздела 8.5.2. Протестируйте
ее. Какие наборы данных лучше всего подходят для тестирования? Укажите
причины. Затем напишите функцию print_until_ss О, которая выводит
на печать сроки, пока не обнаружит строку аргумента quit.
14. Напишите функцию, принимающую аргумент типа vector<string> и возвра-
щающую объект типа vector<int>, содержащий количество символов в каж-
дой строке. Кроме того, найдите самую короткую и самую длинную строки,
а также первую и последнюю строки в соответствии с лексикографическим по-
рядком Сколько отдельных функций вы использовали бы для решения этой за-
дачи? Почему?
15. Можно ли объявить константный аргумент функции, который передается не по
ссылке (например, void f (const int);)? Что это значит? Зачем это нужно?
Почему эта конструкция применяется редко? Испытайте ее; напишите несколь-
ко маленьких программ, чтобы увидеть, как она работает.
т
322ПОСЛЕСЛОВИЕ
323
Послесловие
Большую часть этой (и следующей) главы можно было бы вынести в приложе-
ние. Однако в части II нам потребуются многие средства, описанные здесь. Кроме
того, очень скоро мы столкнемся с проблемами, для решения которых эти средства
были изобретены. При написании простых программ вы неизбежно должны будете
решать такие проблемы. Итак, для того чтобы сэкономить время и минимизировать
недоразумения, необходим систематический подход, а не серия "случайных" ссылок
на справочное руководство и приложения.Технические детали:
классы и прочее
"Помните, все требует времени".
Пит Хейн (Piet Hein)
В этой главе мы сосредоточим внимание на основном инструменте про-
граммирования: языке C++. Мы опишем технические подробности это-
го языка, связанные в основном с типами, определенными пользователем,
иначе говоря, с классами и перечислениями. Описание свойств языка излага-
ется на примере постепенной разработки типа Date. Кроме того, это позволя-
ет продемонстрировать некоторые полезные приемы разработки классов.326
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
В этой главе...
9.1. Типы, определенные пользователем 9.5. Перечисления
9.2. Классы и члены класса 9.6. Перегрузка операторов
9.3. Интерфейс и реализация 9.7. Интерфейсы классов
9.4. Разработка класса 9-7-1 •Типы аргументов
9.4.1. Структуры и функции 97,2- Копирование
9.4.2. Функции-члены и конструкторы 9J-3' Конструкторы по умолчанию
9.4.3. Скрываем детали 9-7-4- Константные функции-члены
9.4.4. Определение функций-членов 9J'5- Члены и вспомогательные функции
9.4.5. Ссылка на текущий объект 9.8. Класс Date
9.4.6. Сообщения об ошибках
9.1. Типы, определенные пользователем
Г7[ В языке C++ есть встроенные типы, такие как char, int и double (подробнее
*—' они описаны в разделе А.8). Тип называется встроенным, если компилятор
знает, как представить объекты такого типа и какие операторы к нему можно при-
менять (такие как + и -) без уточнений в виде объявлений, которые создает про-
граммист в исходном коде.
Г7Г Типы, не относящиеся к встроенным, называют типами, определенными поль-
*—■ зователем (user-defined types — UDT). Они могут быть частью стандартной
библиотеки, доступной в любой реализации языка C++ (например, классы string,
vector и ostream, описанные в главе 10), или типами, самостоятельно созданными
программистом, как классы Token и Token_stream (см. разделы 6.5 и 6.6). Как
только мы освоим необходимые технические детали, мы создадим графические ти-
пы, такие как Shape, Line и Text (речь о них пойдет в главе 13). Стандартные биб-
лиотечные типы являются такой же частью языка, как и встроенные типы, но мы
все же рассматриваем их как определенные пользователем, поскольку они созданы
из таких же элементарных конструкций и с помощью тех же приемов, как и типы,
разработанные нами; разработчики стандартных библиотек не имеют особых при-
вилегий и средств, которых нет у нас. Как и встроенные типы, большинство типов,
определенных пользователем, описывают операции. Например, класс vector со-
держит операции [] и size О (см. разделы 4.6.1 и В.4.8), класс ostream — опера-
цию <<, класс Tokenstream— операцию get О (см. раздел 6.8), а класс Shape —
операции add(Point) и setcolor () (см. раздел 14.2).
Ш Зачем мы создаем типы? Компилятор не знает всех типов, на основе которых
мы хотим создавать свои программы. Это в принципе невозможно, поскольку
существует слишком много полезных типов — ни один разработчик языка про-
граммирования или компиляторов не может знать обо всех. Каждый день мы разра-
батываем новый тип. Почему? Какие типы можно признать хорошими? Типы явля-
ются хорошими, если они позволяют прямо отразить идею в коде. Когда мы пишем
программу, нам хотелось бы непосредственно воплощать идеи в коде так, чтобы мы9 2 КЛАССЫ И ЧЛЕНЫ КЛАССА
327
сами, наши коллеги и компилятор могли понять, что мы написали. Когда мы хотим
выполнять арифметические операции над целыми числами, нам отлично подойдет
тип int, когда хотим манипулировать текстом, класс string —хороший выбор; ко-
гда хотим манипулировать входной информацией для калькулятора, нам нужны
классы Token и Tokenstream. Необходимость этих классов имеет два аспекта.
• Представление. Тип "знает", как представить данные, необходимые в объекте.
• Операции. Тип знает, какие операции можно применить к объектам.
Эту концепцию, лежащую в основе многих идей, можно выразить так: "нечто"
имеет данные для представления своего текущего значения — которое иногда назы-
вают текущим состоянием, — и набор операций, которые к ним можно применить.
Подумайте о компьютерном файле, веб-странице, CD-плеере, чашке кофе, телефо-
не, телефонном справочнике; все они характеризуются определенными данными
и имеют более или менее фиксированный набор операций, которые можно выпол-
нить. В каждом случае результат операции зависит от данных — текущего состоя-
ния объекта.
Итак, мы хотим выразить "идею" или "понятие" в коде в виде структуры данных
и набора функций. Возникает вопрос: "Как именно?" Ответ на этот вопрос изложен
в данной главе, содержащей технические детали этого процесса в языке C++.
В языке C++ есть два вида типов, определенных пользователем: классы и пе-
речисления. Классы носят намного более общий характер и играют более важ-
ную роль в программировании, поэтому мы сосредоточим свое внимание в первую
очередь на них. Класс непосредственно выражает некое понятие в программе.
Класс (class) — это тип, определенный пользователем. Он определяет, как пред-
ставляются объекты этого класса, как они создаются, используются и уничтожаются
(раздел 17.5). Если вы размышляете о чем-то как об отдельной сущности, то, вполне
возможно, должны определить класс, представляющий эту "вещь" в вашей про-
грамме. Примерами являются вектор, матрица, поток ввода, строка, быстрое преоб-
разование Фурье, клапанный регулятор, рука робота, драйвер устройства, рисунок
на экране, диалоговое окно, график, окно, термометр и часы.
В языке C++ (как и в большинстве современных языков) класс является основ-
ной строительной конструкцией в крупных программах, которая также весьма по-
лезна для разработки небольших программ, как мы могли убедиться на примере
калькулятора (см. главы 6 и 7).
9.2. Классы и члены класса
Класс — это тип, определенный пользователем. Он состоит из встроенных ти-
пов, других типов, определенных пользователем, и функций. Компоненты, ис-
пользованные при определении класса, называются его членами (members). Класс
может содержать несколько членов, а может и не иметь ни одного члена. Рассмот-
рим пример.
0
0328
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
Class X {
public:
int m; // данные-члены
int mf (int v) { int old = m; m=v; return old; } // функция-член
};
Члены класса могут иметь разные типы. Большинство из них являются либо
данными-членами, определяющими представление объекта класса, либо функция-
ми-членами, описывающими операции над такими объектами. Для доступа к чле-
нам класса используется синтаксическая конструкция вида объект, член. Например:
X var; // var — переменная типа X
var.m =7; // присваиваем значение члену m объекта var
int x = var.mf(9); // вызываем функцию-член mf () объекта var
Тип члена определяет, какие операции с ним можно выполнять. Например, мож-
но считывать и записывать член типа int, вызывать функцию-член и т.д.
9.3. Интерфейс и реализация
Как правило, класс имеет интерфейс и реализацию. Интерфейс — это часть
объявления класса, к которой пользователь имеет прямой доступ. Реализа-
ция — это часть объявления класса, доступ к которой пользователь может получить
только с помощью интерфейса. Открытый интерфейс идентифицируется меткой
public:, а реализация— меткой private:. Итак, объявление класса можно пред-
ставить следующим образом:
class X { // класс имеет имя X
public:
// открытые члены:
// - пользовательский интерфейс (доступный всем)
// функции
// типы
// данные (лучше всего поместить в раздел private)
private:
// закрытые члены:
// - детали реализации (используется только членами
// данного класса)
// функции
// типы
// данные
};
Члены класса по умолчанию являются закрытыми. Иначе говоря, фрагмент
class X {
int mf(int);
// . . .
};
означает
class X {
09.3. ИНТЕРФЕЙС И РЕАЛИЗАЦИЯ
329
private:
int mf (int) ;
// . . .
}i
поэтому
X x; // переменная х типа Х
int у = x.mf(); // ошибка: переменная mf является закрытой
// (т.е. недоступной)
Пользователь не может непосредственно ссылаться на закрытый член класса.
Вместо этого он должен обратиться к открытой функции-члену, имеющей доступ
к закрытым данным. Например:
class X {
int m;
int mf(int);
public:
int f(int i) { m=i; return mf(i); }
};
X x;
int у = x.f(2);
Различие между закрытыми и открытыми данными отражает важное различие
между интерфейсом (точка зрения пользователя класс) и деталями реализации
(точка зрения разработчика класса). По мере изложения мы опишем эту концепцию
более подробно и рассмотрим множество примеров. А пока просто укажем, что для
обычных структур данных это различие не имеет значения. По этой причине для
простоты будем рассматривать класс, не имеющий закрытых деталей реализации,
т.е. структуру, в которой все члены по умолчанию являются открытыми. Рассмот-
рим пример.
struct X {
int m;
// . . .
};
Он эквивалентен следующему коду:
class X {
public:
int m;
// . - .
};
Структуры (struct) в основном используются для организации данных, члены
которых могут принимать любые значения; иначе говоря, мы не можем определить
для них никакого осмысленного инварианта (раздел 9.4.3).330
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ЛРОЧЕ&
9.4. Разработка класса
Проиллюстрируем языковые свойства, поддерживающие классы и основные мето-
ды их использования, на примере того, как — и почему — простую структуру данных
можно преобразовать в класс с закрытыми деталями реализации и операциями.
Рассмотрим вполне тривиальную задачу: представить календарную дату (напри-
мер, 14 августа 1954 года) в программе. Даты нужны во многих программах (для
проведения коммерческих операций, описания погодных данных, календаря, рабо-
чих записей, ведомостей и т.д.). Остается только вопрос: как это сделать?
9.4.1. Структуры и функции
Как можно представить дату? На этот вопрос большинство людей отвечают:
"Указать год, месяц и день месяца". Это не единственный и далеко не лучший
ответ, но для наших целей он вполне подходит. Для начала попробуем создать про-
стую структуру.
// простая структура Date (слишком просто?)
struct Date {
int у; // год
int m; // месяц года
int d; // день месяца
}i
Date today; // переменная типа Date (именованный объект)
Объект типа Date, например today, может просто состоять из трех чисел типа int.
Date:
у: 2005 ~
т: 12
d: 24
В данном случае нет необходимости скрывать данные, на которых основана
структура Date, — это предположение будет использовано во всех вариантах этой
структуры на протяжении всей главы. Итак, теперь у нас есть объекты типа Date;
что с ними можно делать? Все что угодно, в том смысле, что мы можем получить
доступ ко всем членам объекта today (и другим объектам типа Date), а также чи-
тать и записывать их по своему усмотрению. Загвоздка заключается в том, что все
это не совсем удобно. Все, что мы хотим делать с объектами типа Date, можно вы-
разить через чтение и запись их членов. Рассмотрим пример.
// установить текущую дату 24 декабря 2005 года
today.у = 2005;
today.m = 24;
today.d = 12;9 4 РАЗРАБОТКА КЛАССА
331
Этот способ утомителен и уязвим для ошибок. Вы заметили ошибку? Все, что
является утомительным, уязвимо для ошибок! Например, ответьте, имеет ли смысл
следующий код?
Date x;
х.у = -3
х.т = 13
x.d = 32
Вероятно нет, и никто не стал бы писать такую чушь — или стал? А что вы ска-
жете о таком коде?
Date у;
у.у = 2000;
у.т = 2;
y.d = 29;
Был ли двухтысячный год високосным? Вы уверены?
Итак, нам нужны вспомогательные функции, которые выполняли бы для нас са-
мые общие операции. В этом случае нам не придется повторять один и тот же код,
а также находить и исправлять одни и те же ошибки снова и снова. Практически для
любого типа самыми общими операциями являются инициализация и присваивание.
Для типа Date к общим операциям относится также увеличение значения объекта
Date. Итак, напишем следующий код:
// вспомогательные функции:
void initday(Date& dd, int у, int m, int d)
{
// проверяет, является ли (y,m,d) правильной датой
// если да, то инициализирует объект dd
}
void addday(Date& dd, int n)
{
// увеличивает объект dd на п дней
}
Попробуем использовать объект типа Date.
void f()
{
Date today;
init_day(today, 12, 24, 2005); // Ой! (в 12-м году не было
// 2005-го дня)
add_day(today,l);
}
Ш Во-первых, отметим полезность таких "операций" — здесь они реализованы
в виде вспомогательных функций. Проверка корректности даты довольно
сложна и утомительна, поэтому, если бы мы не написали соответствующую функ-
цию раз и навсегда, то скорее всего пропустили бы этот код и получили неправиль-332
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ.
ную программу. Если мы определяем тип, то всегда хотим вьшолнять над его объ*
ектами какие-то операции. Точное количество и вид этих операций может изме-
няться. Точный вид реализации этих операций (в виде функций, функций-членов
или операторов) также изменяется, но как только мы решили создать собственный
тип, мы должны спросить себя: "Какие операции с этим типом можно выполнять?"
9.4.2. Функции-члены и конструкторы
Мы предусмотрели функцию инициализации для типа Date, которая проверяет
корректность его объектов. Однако функции проверки приносят мало пользы, если
мы не можем их использовать. Например, допустим, что мы определили для типа
Date оператор вывода << (раздел 9.8):
void fО
{
Date today;
// • . .
cout << today << 'Xn1; // использовать объект today
// - . •
initday(today,2008,3,30);
// . . .
Date tomorrow;
tomorrow.у = today.у;
tomorrow.m = today.m;
tomorrow.d = today.d+1; // добавляем единицу к объекту today
cout << tomorrow << '\n'; // используем объект tomorrow
}
Здесь мы "забыли" немедленно инициализировать объект today, и до вызова
функции initday О этот объект будет иметь неопределенное значение. Кроме то-
го, "кто-то" решил, что вызывать функцию add_day () — лишняя потеря времени
(или просто не знал о ее существовании), и создал объект tomorrow вручную.
Это плохой и даже очень плохой код. Вероятно, в большинстве случае эта програм-
ма будет работать, но даже самые небольшие изменения приведут к серьезным
ошибкам. Например, отсутствие инициализации объекта типа Date приведет к вы-
воду на экран так называемого "мусора", а прибавление единицы к члену d вообще
представляет собой мину с часовым механизмом: когда объект today окажется по-
следним днем месяца, его увеличение на единицу приведет к появлению непра-
вильной даты. Хуже всего в этом очень плохом коде то, что он не выглядит плохим.
Такие размышления приводят нас к мысли о необходимости функции инициали-
зации, которую нельзя забыть, и об операциях, которые невозможно пропустить.
Основным инструментом в этом механизме являются функции-члены, т.е. функций»
объявленные как члены класса внутри его тела. Рассмотрим пример.
// простая структура Date,
// гарантирующая инициализацию с помощью конструктора
// и обеспечивающая удобство обозначений
struct Date {334
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ.' КЛАССЫ И ПРОЧЕЕ
++birthday.d; // ой! Неправильная дата
Date today(1970,2,3);
today.m =14; // ойI Неправильная дата
[vTl Поскольку мы хотим сделать представление типа Date доступным для всех,
*■"■ кто-нибудь — вольно или невольно — может сделать ошибку; иначе говоря,
сделать нечто, что приведет к созданию неправильной даты. В данном случае мы
создали объект типа Date со значением, которое не соответствует календарю. Такие
неправильные объекты являются минами с часовым механизмом; через какое-то
время кто-нибудь, не ведая того, обязательно воспользуется некорректным значени-
ем и получит сообщение об ошибке на этапе выполнения программы или — что еще
хуже —получит неверные результаты. Все это лишь вопрос времени.
Такие размышления приводят к выводу, что представление типа Date, за исклю-
чением открытых функций-членов, должно быть недоступным для пользователей.
Итак, получаем первое сокращение.
// простой типа Date (управление доступом)
class Date {
int у, m, d; // год, месяц, день
public:
Date (int у, int m, int d) ; // проверка и инициализация даты
void add_day(int n) ; // увеличение объекта типа Date на п дней
int month() { return m; }
int day() { return d; }
int year() { return y; }
Этот класс можно использовать следующим образом:
Date birthday(1970, 12, 30); // OK
birthday.m = 14; // ошибка: Date::m — закрытый член
cout << birthday.month() << endl; // доступ к переменной m
Понятие "правильный объект типа Date"— важная разновидность идеи
о корректном значении. Мы пытаемся разработать наши типы так, чтобы их
значения гарантированно были корректными; иначе говоря, скрываем представле-
ние, предусматриваем конструктор, создающий только корректные объекты, и раз-
рабатываем все функции-члены так, чтобы они получали и возвращали только кор-
ректные значения. Значение объекта часто называют состоянием (state), а коррект-
ное значение — корректным состоянием объекта.
В качестве альтернативы можно проверять корректность объекта при каждой
попытке его использования или просто надеяться на то, что никто никогда не соз-
даст ни одного некорректного значения. Опыт показывает, что такие надежды могут
привести к "очень хорошим" программам. Однако создание таких программ, кото-
рые иногда выдают ошибочные результаты, а порой вообще приводят к аварийному
отказу, не принесет вам профессионального признания. Мы предпочитаем писать
программы корректность которых можно продемонстрировать.9 4 РАЗРАБОТКА КЛАССА
335
Правило, регламентирующее смысл корректного значения, называют инвариан-
том (invariant). Инвариант для класса Date ("Объект класса Date должен пред-
ставлять дату в прошлом, настоящем и будущем времени") необычайно трудно сфор-
мулировать точно: вспомните о високосных годах, григорианском календаре, часовых
поясах и т.п. Однако для простых и реалистичных ситуаций можно написать класс
Date. Например, если мы инициализируем интернет-протоколы, нас не должны бес-
покоить ни григорианский, ни юлианский календари, ни календарь племени майя.
Если мы не можем придумать хороший инвариант, то, вероятно, имеют место простые
данные. В таких случаях следует использовать обычные структуры struct.
9.4.4. Определение функций-членов
До сих пор мы смотрели на класс Date с точки зрения разработчика интерфейса
и пользователя. Однако рано или поздно нам придется реализовать его функции-
члены. Во-первых, выделим подмножество класса Date, чтобы согласовать его
с общепринятым стилем организации открытого интерфейса.
// простой класс Date (детали реализации будут рассмотрены позднее)
class Date {
public:
Date(int у, int mf int d) ; // проверка и инициализация даты
void add_day(int n) ; // увеличивает объект класса Date на п дней
int month();
// . . .
private:
int y, m, d; // лет, месяцев, дней
};
Открытый интерфейс разрабатывают в первую очередь, поскольку именно он
интересует большинство людей. В принципе пользователю не обязательно знать де-
тали реализации. На самом же деле люди, как правило, любопытны и хотят знать,
насколько разумна реализация класса и какие приемы использовал ее автор, чтобы
научиться у него чему-нибудь. И все же, если реализацию класса создавали не мы,
то большую часть времени будем работать с его открытым интерфейсом. Компиля-
тору безразличен порядок следования членов класса; он обрабатывает объявления
в любом порядке, в котором мы их укажем.
Определяя члены за пределами класса, мы должны указать, какому классу они
принадлежат. Для этого используется обозначение имя класса: г имя члена.
Date::Date(int yyf int mm, int dd)// конструктор
:y(yy)f m(mm), d(dd) // примечание: инициализация члена
{
}
void Date::add day(int n)
{
// . . .
}
0336
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
int month() // ой: мы забыли про класс Date:;
{
return m; // не функция-член, к переменной m доступа нет
}
Обозначение :у(уу), m(mm), d(dd) указывает на то, как инициализируются
члены. Мы могли бы написать эквивалентный фрагмент кода.
Date: :Date(int yy, int mm, int dd) // конструктор
{
у = yy;
m = mm;
d = dd;
}
Однако сначала нам следовало бы инициализировать члены их значениями, задан-
ными по умолчанию, и лишь потом присваивать им новые значения. Кроме того,
в этом случае не исключена возможность того, что мы случайно используем член
класса до его инициализации. Обозначение :у(уу) / m(mm), d(dd) точнее отра-
жает наши намерения. Разница между этими фрагментами точно такая же, как меж-
ду двумя примерами, приведенными ниже. Рассмотрим первый из них.
int х; // сначала определяем переменную х
// . . .
х = 2; // потом присваиваем ей значение
Второй пример выглядит так:
int х = 2; // определяем и немедленно инициализируем двойкой
Для полноты картины укажем еще один способ инициализации с помощью син-
таксической конструкции, напоминающей аргументы функции в скобках.
int x(2); // инициализируем двойкой
Date sunday(2009,8,29) ; // инициализируем объект Sunday
// триадой (2009,8,29)
Функцию-член класса можно также определить в определении класса.
// простой класс Date (детали реализации будут рассмотрены позднее)
class Date {
public:
Date(int yy, int mm, int dd)
:у(УУ)> m(mm), d(dd)
{
// . . .
}
void add_day(int n)
{
// • ■ •
}
int month() { return m; }9 4. РАЗРАБОТКА КЛАССА
337
// • ■ •
private:
int у, m, d; // год, месяц, день
};
Во-первых, отметим, что теперь объявление класса стало больше и запутаннее.
В данном примере код конструктора и функции add_day () могут содержать десят-
ки строк. Это в несколько раз увеличивает размер объявления класса и затрудняет
поиск интерфейса среди деталей реализации. Итак, мы не рекомендуем определять
большие функции в объявлении класса. Тем не менее посмотрите на определение
функции month(). Оно проще и короче, чем определение Date: :month(), разме-
щенное за пределами объявления класса. Определения коротких и простых функций
можно размещать в объявлении класса.
Обратите внимание на то, что функция month () может обращаться к переменной
т, даже несмотря на то, что переменная m определена позже (ниже) функции month ().
Член класса может ссылаться на другой член класса независимо от того, в каком месте
класса он определен. Правило, утверждающее, что имя переменной должно быть объ-
явлено до ее использования, внутри класса ослабляется.
0
Определение функции-члена в классе приводит к следующим последствиям.
Функция становится подставляемой (inlined), т.е. компилятор попытается сге-
нерировать код подставляемой функции вместо ее вызова. Это может дать зна-
чительное преимущество часто вызываемым функциям, таким как month ().
При изменении тела подставляемой функции-члена класса придется скомпи-
лировать заново все модули, в которых он используется. Если тело функции
определено за пределами объявления класса, то потребуется перекомпилиро-
вать только само определение класса. Отсутствие необходимости повторного
компилирования при изменении тела функции может оказаться огромным
преимуществом в больших программах.
Очевидное правило гласит: не помещайте тела функций-членов в объявление
класса, если вам не нужна повышенная эффективность программы за счет ис-
пользования небольших подставляемых функций. Большие функции, скажем, со-
стоящие из пяти строк, ничего не выиграют от подстановки. Не следует делать под-
ставляемыми функции, содержащие более одного-двух выражений.
9.4.5. Ссылка на текущий объект
Рассмотрим простой пример использования класса Date.
class Date {
// • • •
int month() { return m; }
// • • •
private:338
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
int у, т, d; // год, месяц, день
void f(Date dl, Date d2)
{
cout << dl.month() <<•'<< d2.month() << '\n*;
}
Откуда функции Date: :month() известно, что при первом вызове следует вывес-
ти на печать переменную dl.m, а при втором— d2.m? Посмотрите на функцию
Date::month() еще раз; ее объявление не имеет аргумента! Как функция Date:
: month () "узнает", для какого объекта она вызывается? Функции-члены класса, такие
как Date: :month(), имеют неявный аргумент, позволяющий идентифицировать объ-
ект, для которого они вызываются. Итак, при первом вызове переменная m правильно
ссылается на dl .m, а при втором — на d2 .m. Другие варианты использования неявно-
го аргумента описаны в разделе 17.10.
9.4.6. Сообщения об ошибках
Что делать при обнаружении некорректной даты? В каком месте кода проис-
ходит поиск некорректных дат? В разделе 5.6 мы узнали, что в этом случае
следует сгенерировать исключение, и самым очевидным местом для этого является
место первого создания объекта класса Date. Если мы создали правильные объекты
класса Date и все функции-члены написаны правильно, то мы никогда не получим
объект класса Date с неверным значением. Итак, следует предотвратить создание
неправильных объектов класса Date.
// простой класс Date (предотвращаем неверные даты)
class Date {
public:
class Invalid { }; // используется как исключение
Date (int у, int m, int d) ; // проверка и инициализация даты
// . . .
private:
int y, m, d; // год, месяц, день
bool check(); // если дата правильная, возвращает true
};
Мы поместили проверку корректности даты в отдельную функцию check О,
потому что с логической точки зрения эта проверка отличается от инициализации,
а также потому, что нам может потребоваться несколько конструкторов. Легко
видеть, что закрытыми могут быть не только данные, но и функции.
Date::Date(int уу, int mm, int dd)
: y(yy)# m(mm), d(dd) // инициализация данных - членов класса
{
if (J check О) throw Invalid О; // проверка корректности
}
bool Date::check О // возвращает true, если дата корректна
09.5 ПЕРЕЧИСЛЕНИЯ
339
{
if (m<l || 12<m) return false;
}
Имея это определение класса Date, можно написать следующий код:
void f(int x# int у)
try {
Date dxy(2009,x,y);
cout << dxy << '\n'; // объявление оператора «см. в разделе 9.8
dxy.addday(2) ;
}
catch(Date::Invalid) {
error("invalid date"); // функция error() определена
// в разделе 5.6.3
}
Теперь мы знаем, что оператор << и функция adddate О всегда будут работать
с корректными объектами класса Date. До завершения разработки класса Date,
описанной в разделе 9.7, опишем некоторые свойства языка, которые потребуются
нам для того, чтобы сделать это хорошо: перечисления и перегрузку операторов
9.5. Перечисления
Перечисление enum (enumeration) — это очень простой тип, определенный
пользователем, который задает множество значений (элементов перечисления)
как символические константы. Рассмотрим пример.
епшп Month {
jan=l, feb, mar, apr, may, jun, Jul, aug, sep, oct, nov, dec
};
"Тело" перечисления — это просто список его элементов. Каждому элементу пе-
речисления можно задать конкретное значение, как это сделано выше с элементом
jan, или предоставить компилятору подобрать подходящее значение. Если поло-
житься на компилятор, то он присвоит каждому элементу перечисления число,
на единицу превышающее значение предыдущего. Таким образом, наше определе-
ние перечисления Month присваивает каждому месяцу последовательные значения,
начиная с единицы. Это эквивалентно следующему коду:
enum Month {
jan=l, feb=2, mar=3, apr=4, may=5, jun=6,
jul=7, aug=8, sep=9, oct=10, nov=ll, dec=12
};
Однако это утомительно и открывает много возможностей для ошибок. Факти-
чески мы сделали две опечатки, пока не получили правильный вариант; лучше все
же предоставить компилятору делать простую, повторяющуюся, "механическую"
работу. Компилятор такие задачи решает лучше, чем люди, и при этом не устает.
0340
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
Если не инициализировать первый элемент перечисления, то счетчик начнет
отсчет с нуля. Рассмотрим такой пример:
enum Day {
monday, tuesday, Wednesday, thursday, friday, Saturday, Sunday
}>
где monday=s0 и sunday==6. На практике лучше всего выбирать начальное значе-
ние счетчика, равным нулю.
Перечисление Month можно использовать следующим образом:
Month m = feb;
ш ■ 7; // ошибка: нельзя присвоить целое число перечислению
int n = ш; // ОК: целочисленной переменной можно присвоить
// значение Month
Month mm = Month(7); // преобразование типа int в тип Month
// (без проверки)
Обратите внимание на то, что Month — это отдельный тип. Он может быть не-
явно преобразован в тип int, но неявного преобразования типа Month в тип
int не существует. Это имеет смысл, поскольку каждый объект класса Month имеет
эквивалентное целое значение, но большинство целых чисел не имеет эквивалент-
ного значения типа Month. Например, мы преднамеренно написали неправильную
инициализацию.
Month bad = 9999; // ошибка: целое число невозможно преобразовать
// объект типа Month
Если вы настаиваете на использовании обозначения Month (9999), то сами бу-
дете виноваты! Во многих ситуациях язык C++ не пытается останавливать
программиста от потенциально опасных действий, если программист явно на этом
настаивает; в конце концов, программисту, действительно, виднее.
К сожалению, мы не можем определить конструктор для перечисления, чтобы
проверить начальные значения, но написать простую функцию для проверки не со-
ставляет труда.
Month int_to_month(int x)
{
if (x<jan | | dec<x) error ("неправильный месяц");
return Month(x);
}
Теперь можно написать следующий код:
void f(int m)
{
Month mm = int_to_month(m);
// . . .
}
m
m9.6. ПЕРЕГРУЗКА ОПЕРАТОРОВ
341
Для чего нужны перечисления? В основном перечисление полезно, когда нам
нужно множество связанных друг с другом именованных целочисленных констант.
Как правило, с помощью перечислений представляют наборы альтернатив (up,
down; yes, no, maybe; on, off; n, ne, e, se, s, sw, w, nw) или отличительных призна-
ков (red, blue, green, yellow, maroon, crimson, black).
Обратите внимание на то, что элементы перечисления не входят в отдельную
область видимости своего перечисления; они находятся в той же самой области ви-
димости, что и имя их перечисления. Рассмотрим пример.
enum Trafficsign { red, yellow, green };
int var = red; // примечание: правильно Traffic_sign: .-red
Этот код вызывает проблемы. Представьте себе, что в вашей программе в каче-
стве глобальных используются такие распространенные имена, как red, on, ne
и dec. Например, что значит пе: "северо-восток" (northeast) или "не равно" (nor
equal)? Что значит dec: "десятичный" (decimal) или "декабрь" (December)? Именно
о таким проблемах мы предупреждали в разделе 3.7. Они легко возникнут, если оп-
ределить перечисление с короткими и общепринятыми именами элементов в гло-
бальном пространстве имен. Фактически мы сразу сталкиваемся с этой проблемой,
когда пытаемся использовать перечисление Month вместе с потоками iostream, по-
скольку для десятичных чисел существует манипулятор с именем dec (см. раз-
дел 11.2.1). Для того чтобы избежать возникновения этих проблем, мы часто предпо-
читаем определять перечисления в более ограниченных областях видимости, напри-
мер в классе. Это также позволяет нам явно указать, на что ссылаются значения
элементов перечисления, такие как Month: :jan и Color::red. Приемы работы
с перечислениями описываются в разделе 9.7.1. Если нам очень нужны глобальные
имена, то необходимо минимизировать вероятность коллизий, используя более длин-
ные или необычные имена, а также прописные буквы. Тем не менее мы считаем более
разумным использовать имена перечислений в локальных областях видимости.
9.6. Перегрузка операторов
Для класса или перечисления можно определить практически все операторы,
существующие в языке C++. Этот процесс называют перегрузкой операторов
(operator overloading). Он применяется, когда требуется сохранить привычные обо-
значения для разрабатываемого нами типа. Рассмотрим пример.
enum Month {
Jan=l, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
};
Month operator++(Month& m) // префиксный инкрементный оператор
m = (m==Dec) ? Jan : Month(m+1); // "циклический переход"
return m;342 ГЛАВА 9 . ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
Конструкция ? s представляет собой арифметический оператор "если"; пере-
менная m становится равной Jan, если (m==Dec), и Month (m-fl) в противном
случае. Это довольно элегантный способ, отражающий цикличность календаря.
Тип Month теперь можно написать следующим образом:
Month m = sep;
++m; // m становится равным Oct
++m; // m становится равным Nov
++m; // m становится равным Dec
++m; // m становится равным Jan ("циклический переход")
Можно не соглашаться с тем, что инкрементация перечисления Month является
широко распространенным способом, заслуживающим реализации в виде отдельно-
го оператора. Однако что вы скажете об операторе вывода? Его можно описать так:
vector<string> month_tbl;
ostream& operator« (ostream& os, Month m)
{
return os << month_tbl[m];
}
Это значит, что объект monthtbl был инициализирован где-то, так что, напри-
мер, monthtbl [Mar] представляет собой строку "March" или какое-то другое
подходящее название месяца (см. раздел 10.11.3).
Разрабатывая собственный тип, можно перегрузить практически любой опера-
тор, предусмотренный в языке C++, например +, -,*,/,%, [], О, *\ !, &, <, <*, >
и >=. Невозможно определить свой собственный оператор; можно себе представить,
что программист захочет иметь операторы ** или $=, но язык C++ этого не допус-
кает. Операторы можно определить только для установленного количества операн-
дов; например, можно определить унарный оператор -, но невозможно перегрузить
как унарный оператор <= ("меньше или равно"). Аналогично можно перегрузить
бинарный оператор +, но нельзя перегрузить оператор 1 ("нет") как бинарный. Итак,
язык позволяет использовать для определенных программистом типов существую-
щие синтаксические выражения, но не позволяет расширять этот синтаксис.
Перегруженный оператор должен иметь хотя бы один операнд, имеющий тип,
определенный пользователем.
int operator* (int,int); // ошибка: нельзя перегрузить встроенный
// оператор +
Vector operator+(const Vectors, const Vector &) ; // OK
Vector operator+=(const Vectors, int); // OK
Мы рекомендуем не определять оператор для типа, если вы не уверены ДОДг
ностью, что это значительно улучшит ваш код. Кроме того, операторы слвД^
определять, сохраняя их общепринятый смысл: оператор + должен обозначать #Кг
жение; бинарный оператор * — умножение; оператор [] — доступ; оператор {jyjra
вызов функции и т д. Это просто совет, а не правило языка, но это хороший <Х*5|$9.7. ИНТЕРФЕЙСЫ КЛАССОВ
343
общепринятое использование операторов, такое как символ + для сложения, значи-
тельно облегчает понимание программы. Помимо всего прочего, этот совет являет-
ся результатом сотен лет опыта использования математических обозначений.
Малопонятные операторы и необычное использование операторов могут запу-
тать программу и стать источником ошибок. Более на эту тему мы распространяться
не будем. Просто в следующих главах применим перегрузку операторов в соответ-
ствующих местах.
Интересно, что чаще всего для перегрузки выбирают не операторы +, -, *, и /,
как можно было бы предположить, а =, ==, ! =, <, [] и О.
9.7. Интерфейсы классов
Ранее мы уже указывали, что открытый интерфейс и реализация класса долж-
ны быть отделены друг от друга. Поскольку в языке C++ остается возмож-
ность использовать простые структуры struct, некоторые профессионалы могут
не согласиться с этим утверждением. Однако как разработать хороший интерфейс?
Чем хороший интерфейс отличается от плохого? Частично на эти вопросы можно
ответить только с помощью примеров, но существует несколько общих принципов,
которые поддерживаются в языке C++.
• Интерфейс должен быть полным.
• Интерфейс должен быть минимальным.
• Класс должен иметь конструкторы.
• Класс доложен поддерживать копирование (или явно запрещать его) (см. раз-
дел 14.2.4).
• Следует предусмотреть тщательную проверку типов аргументов.
• Необходимо идентифицировать немодифицирующие функции-члены (см. раз-
дел 9.7.4).
• Деструктор должен освобождать все ресурсы (см. раздел 17.5).
См. также раздел 5.5, в котором описано, как выявлять ошибки и сообщать о них
на этапе выполнения программы.
Первые два принципа можно подытожить так: "Интерфейс должен быть как
можно более маленьким, не меньше необходимого". Интерфейс должен быть ма-
леньким, потому что его легче изучить и запомнить, а программист, занимающийся
реализацией класса, не будет терять время на реализацию излишних или редко ис-
пользуемых функций. Кроме того, небольшой интерфейс означает, что если что-то
пойдет не так, как задумано, для поиска причины потребуется проверить лишь не-
сколько функций. В среднем чем больше открытых функций, тем труднее найти
ошибку, — пожалуйста, не усложняйте себе жизнь, создавая классы с открытыми
данными. Но. разумеется, интерфейс должен быть полным, в противном случае он
0344 ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛ14: КЛАССЫ И ПРОЧЕЕ
будет бесполезным. Нам не нужен интерфейс, который не позволяет нам делать f0,
что действительно необходимо.
Перейдем к изучению менее абстрактных и более реалистичных понятий, подг
держиваемых в языке C++.
9.7.1. Типы аргументов
Определяя конструктор класса Date в разделе 9.4.3, мы использовали в качестве
аргументов три переменные типа int. Это породило несколько проблем.
Date (11(4,5,2005); // Ой! Год 4, день 2005
Date (12(2005,4,5); // 5 апреля или 4 мая?
Первая проблема (недопустимый день месяца) легко решается путем проверки
в конструкторе. Однако вторую проблему (путаницу между месяцем и днем месяца)
невозможно выявить с помощью кода, написанного пользователем. Она возникает
из-за того, что существуют разные соглашения о записи дат; например, 4/5 в США
означает 5 апреля, а в Англии — 4 мая. Поскольку эту проблему невозможно устра-
нить с помощью вычислений, мы должны придумать что-то еще. Очевидно, следует
использовать систему типов.
// простой класс Date (использует тип Month)
class Date {
public:
enum Month {
jazisl, feb, mar, apr, may, jun, Jul, aug, sep, oct, nov, dec
};
Date(int y. Month m, int d) ; // проверка даты и инициализация
// . . .
private:
int у; // год
Month m;
int d; // день
};
Когда мы используем тип Month, компилятор выдаст ошибку, если мы поменяем
местами месяц и день. Кроме того, перечисление Month позволяет использовать
символические имена. Такие имена, как правило, легче читать и записывать, чем
работать с числами, подвергаясь риску ошибиться.
Date dxl(1998, 4, 3); // ошибка: 2-й аргумент не имеет
// тип Month
Date dx2(1998, 4, Date::mar); // ошибка: 2-й аргумент не имеет
// тип Month
Date dx2(4, Date::mar, 1998); // ой: ошибка на этапе выполнения;
// день 1998
Date dx2 (Date: :mar, 4, 1998); // ошибка: 2-й аргумент не имеет
// тип Month
Date dx3(1998, Date::mar, 30);// OK9.7. ИНТЕРФЕЙСЫ КЛАССОВ
345
Этот код решает много проблем. Обратите внимание на квалификатор Date
перечисления mar: Date: :mar. Тем самым мы указываем, что это перечисление шаг
из класса Date. Это не эквивалентно обозначению Date.шаг, поскольку Date —
это не объект, а тип, а шаг — не член класса, а символическая константа из пере-
числения, объявленного в классе. Обозначение :: используется после имени класса
(или пространства имен; см. раздел 8.7), а . (точка) — после имени объекта.
Когда есть выбор, ошибки следует выявлять на этапе компиляции, а не на
этапе выполнения программы. Мы предпочитаем, чтобы ошибки вылавливал
компилятор, а не искать, в каком месте кода возникла ошибка. Кроме того, для вы-
явления ошибок на этапе компиляции не требуется писать и выполнять специаль-
ный код для проверки.
А нельзя ли подобным образом выявить путаницу между днем месяца и годом?
Можно, но решение этой проблемы будет не таким элегантным, как для типа Month;
помимо всего прочего, возможно, что мы имели в виду именно четвертый год. Даже
если мы ограничимся современной эпохой, в перечисление придется включать
слишком много лет.
Вероятно, было бы лучше всего (не вникая в предназначение класса Date) напи-
сать следующий код:
class Year { // год в диапазоне [min.-max)
static const int min = 1800;
static const int max = 2200;
public:
class Invalid { };
Year(int x) : y(x) { if (x<min || max<x) throw Invalid(); }
int year() { return y; }
private:
int y;
};
class Date {
public:
enum Month {
jan=l, feb, mar, apr, may, jun, Jul, aug, sep, oct, nov, dec
};
Date (Year y, Month m, int d) ; // проверка даты и инициализация
// • • .
private:
Year у;
Month m;
int d; // день
};
Теперь получаем фрагмент кода.
Date dxl (Year (1998), 4, 3); // ошибка: 2-й аргумент - не Month
Date dx2(Year(1998), 4, Date::mar); // ошибка: 2-й аргумент - не Month346
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕС
Date dx2(4, Date;:mar, Year(1998)); // ошибка: 1-й аргумент — не Year
Date dx2 (Date: :mar, 4, Year (1998)); // ошибка: 2-й аргумент — не Month
Date dx3(Year(1998), Date::mar, 30); // OK
Следующая фатальная и неожиданная ошибка выявится только на этапе выпол-
нения программы.
Date dx2 (Year(4), Date::mar, 1998); // ошибка на этапе выполнения:
// Year:;Invalid
Стоило ли выполнять дополнительную работу и вводить обозначения для лет?
Естественно, это зависит от того, какие задачи вы собираетесь решать с помощью
типа Date, но в данном случае мы сомневаемся в этом и не хотели бы создавать от-
дельный класс Year.
Когда мы программируем, то всегда устанавливаем критерии качества для
данного приложения. Как правило, мы не можем позволить себе роскошь
очень долго искать идеальное решение, если уже нашли достаточно хорошее. Втя-
гиваясь в поиски наилучшего решения, мы настолько запутаем программу, что она
станет хуже, чем первоначальный вариант. Как сказал Вольтер: "Лучшее — враг
хорошего".
Обратите внимание на слова static const в определениях переменных min
и max. Они позволяют нам определить символические константы для целых типов
в классах. Использование модификатора static по отношению к члену класса
гарантирует, что в программе существует только одна копия его значения, а не по
одной копии на каждый объект данного класса.
9.7.2. Копирование
Мы всегда должны создавать объекты, иначе говоря, всегда предусматривать
инициализацию и конструкторы. Вероятно, это самые важные члены класса: для то-
го чтобы написать их, необходимо решить, как инициализировать объект и что зна-
чит корректность его значений (т.е. определить инвариант). Уже даже размышления
об инициализации помогут вам избежать ошибок.
Затем необходимо решить, можно ли копировать объекты и как это делать?
Для класса Date или перечисления Month ответ очевиден: копирование необходимо,
и его смысл тривиален: просто копируются все члены класса. Фактически это преду-
смотрено по умолчанию. Если не указано ничего другого, компьютер сделает именно
это. Например, если перечисление Month используется для инициализации или стоит
в правой части оператора присваивания, то все его члены будут скопированы.
Date holiday(1978, Date::jul, 4); // инициализация
Date d2 = holiday;
Date d3 = Date(197 8, Date::Jul, 4);
holiday = Date(1978, Date::dec, 24); // присваивание
d3 = holiday;9.7. ИНТЕРФЕЙСЫ КЛАССОВ
34?
Обозначение Date (1978, Date:: dec, 24) означает создание соответствующе-
го неименованного объекта класса Date, которое затем можно соответствующим
образом использовать. Рассмотрим пример.
cout << Date(1978, Date::dec, 24);
В данном случае конструктор класса действует почти как литерал. Это часто
удобнее, чем сначала создавать переменную или константу, а затем использовать ее
лишь один раз.
А если нас не устраивает копирование по умолчанию? В таком случае мы можем
либо определить свое собственное копирование (см. раздел 18.2), либо создать кон-
структор копирования и закрытый оператор копирующего присваивания (см. раздел
14.2.4).
9.7.3. Конструкторы по умолчанию
Неинициализированные переменные могут быть источником серьезных ошибок.
Для того чтобы решить эту проблему, в языке C++ предусмотрено понятие конст-
руктора, гарантирующее, что каждый объект класса будет инициализирован.
Например, мы объявили конструктор Date::Date (int,Month, int), чтобы гаран-
тировать, что каждый объект класса Date будет правильно проинициализирован.
В данном случае это значит, что программист должен предоставить три аргумента
соответствующих типов. Рассмотрим пример.
Date dl; // ошибка: нет инициализации
Date d2(1998); // ошибка: слишком мало аргументов
Date d3(1,2,3,4); // ошибка: слишком много аргументов
Date d4(1,"jan",2); // ошибка: неправильный тип аргумента
Date d5(1,Date::jan,2); // OK: используется конструктор с тремя
// аргументами
Date d6 = d5; // OK: используется копирующий конструктор
Обратите внимание на то, что, даже несмотря на то, что мы определили конст-
руктор для класса Date, мы по-прежнему можем копировать объекты класса Date.
Многие классы имеют вполне разумные значения по умолчанию; иначе говоря, для
них существует очевидный ответ на вопрос: какое значение следует использовать,
если инициализация не выполнена? Рассмотрим пример.
string si; // значение по умолчанию: пустая строка ""
vector<string> vl; // значение по умолчанию: вектор без элементов
vector<string> v2(10); // вектор, по умолчанию содержащий 10 строк
Все это выглядит вполне разумно и работает в соответствии с указанными коммен-
тариями. Это достигается за счет того, что классы vector и string имеют конструк-
торы по умолчанию, которые неявно выполняют желательную инициализацию.
Для типа т обозначение т () — значение по умолчанию, определенное конструк-
тором, заданным по умолчанию. Итак, можно написать следующий код:348
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
string el в string(); // значение по умолчанию: пустая строка н*
vector<string> vl = vector<string>(); // значение по умолчанию:
// пустой вектор; без элементов
vector<string> v2 (10,string()) ; // вектор, по умолчанию содержащий
// 10 строк
Однако мы предпочитаем эквивалентный и более краткий стиль.
string si; // значение по умолчанию: пустая строка ""
vector<string> vl; // значение по умолчанию: пустой вектор;
// без элементов
vector<string> v2(10); // вектор, по умолчанию содержащий 10 строк
Для встроенных типов, таких как int и double, конструктор по умолчанию под-
разумевает значение о, так что запись int О — это просто усложненное представ-
ление нуля, a double () — долгий способ записать число 0.0.
Опасайтесь ужасных синтаксических проблем, связанных с обозначением ()
при инициализации.
string slClke"); // объект, инициализированный строкой "Ike"
string s2(); // функция, не получающая аргументов и возвращающая
// строку
Использование конструктора, заданного по умолчанию, — это не просто вопрос
стиля. Представьте себе, что отказались от инициализации объектов класса
string и vector.
string s;
for (int i=0f i<s.size(), ++i) // ой: цикл выполняется неопределенное
// количество раз
toupper(s[i]) ; // ой: изменяется содержание
// случайной ячейки памяти
vector<string> v;
v.push_back(nbad") ; // ой: запись по случайному адресу
Если значения переменных s и v действительно не определены, то непонятно,
сколько элементов они содержат или (при общепринятом способе реализации;
см. раздел 17.5) неясно, где эти элементы должны храниться. В результате будут
использованы случайные адреса — и это худшее, что может произойти. В принципе
без конструктора мы не можем установить инвариант, поскольку не можем гаран-
тировать, что его объекты будут корректными (см. раздел 9.4.3). Мы настаиваем
на том, что такие переменные должны быть проинициализированы. В таком случае
фрагмент можно было бы переписать следующим образом:
string si = n";
vector<string> vl(0);
vector<string> v2(10fnn); // вектор, содержащий 10 пустых строк
Однако этот код не кажется нам таким уж хорошим. Для объекта класса string
строка n n является очевидным обозначением пустой строки, а для объекта класса
vector легко догадаться, что число 0 означает пустой вектор. Однако для многих
09.7. ИНТЕРФЕЙСЫ КЛАССОВ
349
типов правильно интерпретировать значение, заданное по умолчанию, совсем не так
легко. В таких случаях лучше было бы определить конструктор, создающий объект
без использования явной инициализации. Такие конструкторы не имеют аргументов
и называются конструкторами по умолчанию.
Для дат не существует очевидного значения, заданного по умолчанию. По этой
причине мы до сих пор не определяли для класса Date конструктор по умолчанию,
но сейчас сделаем это (просто, чтобы показать, что мы можем это сделать).
class Date {
public:
// . . .
Date О; // конструктор по умолчанию
// . . .
private:
int у;
Month m;
int d;
};
Теперь мы должны выбрать дату, заданную по умолчанию. Для этого вполне
подходит первый день XXI столетия.
Date::Date ()
:у(2001), m(Date: : jan) , d(l)
{
}
Если не хотите встраивать значение, заданное по умолчанию, в код конструк-
тора, то можете использовать константу (или переменную). Для того чтобы
избежать использования глобальных переменных и связанных с ними проблем ини-
циализации, можно использовать прием, описанный в разделе 8.6.2.
Datefc default_date()
{
static Date dd(2001,Date::jan,1);
return dd;
}
Здесь использовано ключевое слово static, чтобы переменная dd создавалась
только один раз, а не каждый раз при очередном вызове функции def ault_date О.
Инициализация этой переменной происходит при первом вызове функции de-
faultdate (). С помощью функции default_date() легко определить конструк-
тор, заданный по умолчанию, для класса Date.
Date::Date ()
:y(default_date().year()),
m(default_date().month()),
d(default_date() .dayO)
{
}350
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
Обратите внимание на то, что конструктор по умолчанию не обязан проверять
Значение, заданное по умолчанию; конструктор, создавший объект, вызвавший
функцию defaultdate, уже сделал это. Имея конструктор для класса Date по
умолчанию, мы можем создать векторы объектов класса Date.
vector<Date> birthdays(10);
Без конструктора по умолчанию мы были бы вынуждены сделать это явно.
vector<Date> birthdays(10,default_dateО);
9.7.4. Константные функции-члены
Некоторые переменные должны изменяться, потому они так и называются, а не-
которые— нет; иначе говоря, существуют переменные, которые не изменяются.
Обычно их называют константами, и для них используется ключевое слово const.
Рассмотрим пример.
void some_function (Date& d, const Date& start_of_term)
{
int a = d.dayO; // OK
int b = start_of_term.day () ; // должно бы правильно (почему?)
d.add_day(3) ; // отлично
start_of_term.add_day(3); // ошибка
}
Здесь подразумевается, что переменная d будет изменяться, а переменная
startofterm— нет; другими словами, функция some_f unction О не может из-
менить переменную startofterm. Откуда компилятору это известно? Дело в том,
что мы сообщили ему об этом, объявив переменную start_of_term константой
(const). Однако почему же с помощью функции day () можно прочитать переменную
day из объекта start_of_term? В соответствии с предыдущим определением класса
Date функция start_of_term.day () считается ошибкой, поскольку компилятор не
знает, что функция day () не изменяет свой объект класса Date. Об этом в программе
нигде не сказано, поэтому компилятор предполагает, что функция day () может мо-
дифицировать свой объект класса Date, и выдаст сообщение об ошибке.
Решить эту проблему можно, разделив операции над классом, на модифици-
рующие и немодифицирующие. Это не только помогает понять суть класса,
но и имеет очень важное практическое значение: операции, которые не модифици-
руют объект, можно применять к константным объектам. Рассмотрим пример.
class Date {
public:
// . . .
int day() const; // константный член: не может изменять
// объект
Month month() const; // константный член: не может изменять
// объект9.7. ИНТЕРФЕЙСЫ КЛАССОВ
351
int year() const;
void add_day(int n);
void add_month(int n)
void add_year(int n);
// константный член: не может изменять
// объект
// неконстантный член: может изменять
// объект
// неконстантный член: может изменять
// объект
// неконстантный член: может изменять
// объект
private:
int у;
Month m;
int d;
};
// год
// день месяца
Date d(2000, Date::jan, 20);
const Date cd(2001, Date::feb, 21);
cout << d.dayO << " - " << cd.dayO << endl; // OK
d.addday(l); // OK
cd.addday(1); // ошибка: cd — константа
Ключевое слово const в объявлении функции-члена стоит сразу после списка
аргументов, чтобы обозначить, что эту функцию-член можно вызывать для кон-
стантных объектов. Как только мы объявили функцию-член константной, компиля-
тор берет с нас обещание не модифицировать объект. Рассмотрим пример.
int Date::day() const
{
++d; // ошибка: попытка изменить объект в константной
// функции-члене
return d;
}
Естественно, как правило, мы не собираемся мошенничать. В основном компи-
лятор обеспечивает защиту от несчастных случаев, что очень полезно при разработ-
ке сложных программ.
9.7.5. Члены и вспомогательные функции
Разрабатывая минимальный (хотя и полный) интерфейс, мы вынуждены ос-
тавлять за бортом много полезных операций. Функцию, которая могла бы
быть просто, элегантно и эффективно реализована как самостоятельная функция
(т.е. не функция-член), следует реализовать за пределами класса. Таким образом,
функция не сможет повредить данные, хранящиеся в объекте класса. Предотвраще-
ние доступа к данным является важным фактором, поскольку обычные методы по-
иска ошибок "вращаются вокруг типичных подозрительных мест"; иначе говоря.
если с классом что-то не так, мы в первую очередь проверяем функции, имеющие
прямой доступ к его представлению: одна из них обязательно является причиной
ошибки. Если таких функций десяток, нам будет намного проще работать, чем если
их будет пятьдесят.352
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
Пятьдесят функций для класса Date! Возможно, вы думаете, что мы шутим.
Вовсе нет: несколько лет назад я делал обзор нескольких коммерческих библиотек
для работы с календарем и обнаружил в них множество функций вроде
next_Sunday(), next_workday() и т.д. Пятьдесят— это совсем не невероятное
число для класса, разработанного для удобства пользователей, а не для удобства его
проектирования, реализации и сопровождения.
Отметим также, что если представление изменяется, то переписать достаточно
только функции, которые имеют к ней прямой доступ. Это вторая важная практиче-
ская причина для минимизации интерфейса. Разрабатывая класс Date, мы могли
решить, что дату лучше представлять в виде целого числа дней, прошедших с 1 ян-
варя 1900 года, а не в виде тройки (год,месяц,день). В этом случае нам придется из-
менить только функции-члены.
Рассмотрим несколько примеров вспомогательных функций (helper functions).
Date next_Sunday(const Datefc d)
{
// имеет доступ к объекту d, используя d.dayO , d.month()
// и d.year()
// создает и возвращает новый объект класса Date
}
Date next_weekday(const Date& d) { /* . . . */ }
bool leapyear(int y) { /* . . . */ }
bool operator==(const Datefc a, const Date& b)
{
return a.year()==b.year()
&& a.month()==b.month()
&& a.day()==b.day();
}
bool operator!=(const Date& a, const Date& b)
{
return I(a==b);
}
Вспомогательные функции также называют функциями-помощниками. Разли-
чие между этими и другими функциями, не являющимися членами класса, за-
ключается в логике работы; иначе говоря, вспомогательная функция представляет
собой концепцию проектирования, а не концепцию языка программирования.
Вспомогательная функция часто получает в качестве аргументов объекты класса,
для которого они играют вспомогательную роль. Хотя существуют исключения, на-
пример функция leapyear О. Часто для идентификации вспомогательных функций
используются пространства имен (см. раздел 8.7).
namespace Chrono {
class Date { /* . . . */ };
09.8. КЛАСС DATE
353
bool is_date(int у. Date: :Month m, int d) ; // true для
// корректных данных
Date nextSunday(const Date& d) {/*...*/ }
Date next_weekday(const Date& d) { /* . . . */ }
bool leapyear(int y) { /* . . .*/}// см. пример 10
bool operator»(const Date& a, const Date& b) { /* . . . */ }
// . • •
}
Обратите внимание на функции == и l=. Это типичные вспомогательные функ-
ции. Для многих классов функции == и 1 = имеют очевидный смысл, но, поскольку
это не распространяется на все классы, компилятор не может создать их вместо
программиста, как копирующий конструктор или копирующее присваивание.
Отметьте также, что мы ввели вспомогательную функцию is_date(), которая
заменяет функцию Date:: check (), поскольку проверка корректности даты во мно-
гом не зависит от представления класса Date. Например, нам не нужно знать, как
представлены объекты класса Date для того, чтобы узнать, что дата "30 января 2008
года" является корректной, а "30 февраля 2008 года" — нет. Возможно, существуют
аспекты даты, которые зависят от ее представления (например, корректна ли дата
"30 января 1066 года"), но (при необходимости) конструктор Date может позабо-
титься и об этом.
9.8. Класс Date
Итак, соединим все идеи и понятия вместе и посмотрим, как будет выглядеть
класс Date. Там, где тело функции содержит лишь комментарий ..., фактическая
реализация слишком сложна (пожалуйста, не пытайтесь пока ее написать). Сначала
разместим объявления в заголовочном файле chrono. h.
// файл Chrono.h
namespace Chrono {
class Date {
public:
enum Month {
jan=l, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
};
class Invalid { }; // для генерации в виде исключения
Date(int у, Month m, int d); // проверка и инициализация даты
Date(); // конструктор по умолчанию
// операции копирования по умолчанию
// в порядке
// немодифицирующие операции:
int day() const { return d; }
Month month О const { return m; }
int year() const { return y; }354 ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ ИПВДЗДЩ
*
II модифицирующие операции: *»&,
void add_day(int n);
void add_month(int n);
void add_year(int n);
private:
int y;
Month m;
int d;
};
bool is_date(int y. Date::Month mf int d); // true для корректных дат?
bool leapyear(int у); // true, если у — високосный год
bool operator==(const Dateb a, const Date& b);
bool operator!=(const Dateb a, const Dateb b);
ostreamb operator<<(ostreamb os, const Dateb d)i
istreamfc operator>>(istreamfc is, Date& dd);
} // Chrono
Определения находятся в файле chrono. срр.
// Chrono.cpp
namespace Chrono {
// определения функций-членов:
Date::Date (int yy. Month mm, int dd)
'• У(УУ)# m(mm)f d(dd)
{
if (!is_date (yyfmmf dd)) throw Invalid О ;
}
Dateb default_date()
{
static Date dd(2001,Date::jan,l); // начало XXI века
return dd;
}
Date::Date()
:y(default_date().year О),
m(defaultdate().month О),
d(default_date().day())
{
} i
void Date:: add_day(int n)
{
}9.8. КЛАСС DATE лтт
355
void Date::add_month(int n)
{
// • . .
}
void Date::add_year(int n)
{
if (m==feb && d==29 && 1leapyear(y+n)) { // помните о високос-
// ных годах!
m = mar; // ^ марта вместо
// 29 февраля
d = 1;
}
у+=п;
}
// вспомогательные функции:
bool is_date(int у, Date::Month m, int d)
{
// допустим, что у — корректный объект
if (d<=0) return false; // d должна быть положительной
int days_in_month = 31; // большинство месяцев состоит из 31 дня
switch (m) {
case Date::feb: // продолжительность февраля варьирует
daysinmonth = (leapyear(у))?29:28;
break;
case Date::apr: case Date::jun: case Date::sep: case
Date::nov:
days in_month = 30; // остальные месяцы состоят из 30 дней
break;
}
if (days_in_month<d) return false;
return true;
}
bool leapyear(int y)
{
// см. упражнение 10
}
bool operator==(const Date& a, const Date& b)
{
return a.year()==b.year()
&& a.month()==b.month()
&& a.day()==b.day();
}
bool operator!=(const Date& a, const Date& b)
{356
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЩ*
return 1(a»»b);
>
OBtreamfi operator<<(ostream& os, const Date& d)
{
return os « '(' << d.yearO
<< ', ' « d.monthO
« ',' « d.dayO « ') ';
}
istream& operator>>(istreamb is, Date& dd)
{
int y, m, d;
char chl, ch2, ch3, ch4;
is » chl >> у >> ch2 » m >> ch3 >> d >> ch4;
if (lis) return is;
if (chl!=,(' || сЬг!-',1 || ch31=,/' || ch4!-,),> { // ошибка
// формата
is.clear(ios_base:tfailbit); // установлен неправильный
// бит
return is;
}
return is;
}
enum Day {
sunday, monday, tuesday, Wednesday, thursday, friday, Saturday
Day day_of_week(const Date& d)
{
// . . .
}
Date nextSunday(const Date& d)
{
// ...
}
Date next_weekday(const Date& d)
{
// • . .
}
} // Chrono
Функции, реализующие операции >> и << для класса Date, будут подробно рас-
смотрены в разделах 10.7 и 10.8.КОНТРОЛЬНЫЕ ВОПРОСЫ
357
Задание
Это задание сводится к запуску последовательности версий класса Date. Для ка-
ждой версии определите объект класса Date с именем today, инициализированный
датой 25 июня 1978 года. Затем определите объект класса Date с именем tomorrow
и присвойте ему значение, скопировав в него объект today и увеличив его день на
единицу с помощью функции add_day О. Выведите на печать объекты today и to-
morrow, используя оператор <<, определенный так, как показано в разделе 9.8.
Проверка корректности даты может быть очень простой. В любом случае не до-
пускайте, чтобы месяц выходил за пределы диапазона [1,12], а день месяца —
за пределы диапазона [1,31]. Проверьте каждую версию хотя бы на одной некор-
ректной дате, например (2009, 13, -5).
1. Версия из раздела 9.4.1.
2. Версия из раздела 9.4.2.
3. Версия из раздела 9.4.3.
4. Версия из раздела 9.7.1.
5. Версия из раздела 9.7.4.
Контрольные вопросы
1. Какие две части класса описаны в главе?
2. В чем заключается разница между интерфейсом и реализацией класса? ,
3. Какие ограничения и проблемы, связанные со структурой Date, описаны в этой
главе?
4. Почему в классе Date используется конструктор, а не фyнкцияinit_day()?
5. Что такое инвариант? Приведите примеры.
6. Когда функции следует размещать в определении класса, а когда — за его пре-
делами? Почему?
7. Когда следует применять перегрузку оператора? Перечислите операторы, кото-
рые вы хотели бы перегрузить (укажите причину).
8. Почему открытый интерфейс класса должен быть минимальным?
9. Что изменится, если к объявлению функции-члена добавить ключевое слово
const?
10. Почему вспомогательные функции лучше всего размещать за пределами класса?
Термины
class деструктор подставляемая функция
const инвариант представление
епшп интерфейс реализация358
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
struct конструктор структура
вспомогательная функция корректное состояние типы, используемые
пользователем
встроенные типы перечисление элемент перечисления
Упражнения
1. Перечислите разумные операторы для реальных объектов, указанных в разде-
ле 9.1 (например, для тостера).
2. Разработайте и реализуйте класс Namejpairs, содержащий пару (имя,возраст), где
имя— объект класса string, а возраст— переменная типа double. Представьте
эти члены класса в виде объектов классов vector<string> (с именем name) и
vector<double> (с именем age). Предусмотрите операцию ввода read_namesО,
считывающую ряд имен. Предусмотрите операцию read__ages О, предлагающую
пользователю ввести возраст для каждого имени. Предусмотрите операцию
print (), которая выводит на печать пары (name [i], age [i]) (по одной на строке)
в порядке, определенном вектором name. Предусмотрите операцию sort (), упо-
рядочивающую вектор name в алфавитном порядке и сортирующую вектор age
соответствующим образом. Реализуйте все "операции" как функции-члены. Про-
верьте этот класс (конечно, проверять надо как можно раньше и чаще).
3. Замените функцию Name_pair::print () (глобальным) оператором
operator<< и определите операции == и 1 = для объектов класса Name_pair.
4. Посмотрите на головоломный пример из раздела 8.4. Вставьте его в программу
и объясните смысл каждой конструкции. Обратите внимание на то, что этот код
не делает никаких осмысленных операций; он используется только для услож-
нения примера.
5. Для выполнения этого и нескольких следующих упражнений необходимо разра-
ботать и реализовать класс Book, который является частью программного обес-
печения библиотеки. Класс Book должен иметь члены для хранения шифра
ISBN, названия, фамилии автора и даты регистрации авторских прав. Кроме то-
го, он должен хранить данные о том, выдана книга на руки или нет. Создайте
функции, возвращающие эти данные. Создайте функции, проверяющие, выдана
ли книга на руки или нет. Предусмотрите простую проверку данных, которые
вводятся в объект класса Book; например, шифр ISBN допускается только
в форме n-n-n-x, где п — целое число; х — цифра или буква.
6. Добавьте операторы в класс Book. Пусть оператор == проверяет, совпадают ли
шифры ISBN у двух книг. Пусть также оператор ! = сравнивает цифры ISBN,
а оператор << выводит на печать название, фамилию автора и шифр ISBN
в отдельных строках.УПРАЖНЕНИЯ
359
7. Создайте перечисление для класса Book с именем Genre, Предусмотрите типы
для фантастики, прозы, периодических изданий, биографии и детской литера-
туры. Отнесите каждую книгу к определенному жанру Genre и внесите соответ-
ствующие изменения в конструктор класса Book и его функции-члены.
8. Создайте класс Patron для библиотеки. Этот класс должен содержать имя поль-
зователя, номер библиотечной карточки, а также размер членского взноса. Пре-
дусмотрите функции, имеющие доступ к этим членам, а также функцию, уста-
навливающую размер членского взноса. Предусмотрите вспомогательный ме-
тод, возвращающий булево значение (bool) в зависимости от того, заплатил
пользователь членские взносы или нет.
9. Создайте класс Library. Включите в него векторы классов Book и Patron.
Включите также структуру Transaction и предусмотрите в ней члены классов
Book, Patron и Date. Создайте вектор объектов класса Transaction. Создайте
функции, добавляющие записи о книгах и клиентах библиотеки, а также о сос-
тоянии книг. Если пользователь взял книгу, библиотека должна быть уверена,
что пользователь является ее клиентом, а книга принадлежит ее фондам. Если
эти условия не выполняются, выдайте сообщение об ошибке. Проверьте, есть ли
у пользователя задолженность по уплате членских взносов. Если задолженность
есть, выдайте сообщение об ошибке. Если нет, создайте объект класса Transac-
tion и замените его в векторе объектов класса Transaction. Кроме того, соз-
дайте метод, возвращающий вектор, содержащий имена всех клиентов, имею-
щих задолженность.
10. Реализуйте функцию leapyear () из раздела 9.8.
11. Разработайте и реализуйте набор полезных вспомогательных функций для клас-
са Date, включая такие функции, как nextworkday () (в предположении, что
любой день, кроме субботы и воскресенья, является рабочим) и week_of_
year О (в предположении, что первая неделя начинается 1 января, а первый
день недели — воскресенье).
12. Измените представление класса Date и пронумеруйте дни, прошедшие с 1 янва-
ря 1970 года (так называемый нулевой день), с помощью переменной типа long
и переработайте функции из раздела 9.8. Предусмотрите идентификацию дат,
выходящих за пределы допустимого диапазона (отбрасывайте все даты, пред-
шествующие нулевому дню, т.е. не допускайте отрицательных дней).
13. Разработайте и реализуйте класс для представления рациональных чисел Ra-
tional. Рациональное число состоит из двух частей: числителя и знаменателя,
например 5/6 (пять шестых, или .83333). При необходимости еще раз проверьте
определение класса. Предусмотрите операторы присваивания, сложения, вычи-
тания, умножения, деления и проверки равенства. Кроме того, предусмотрите
преобразование в тип double. Зачем нужен класс Rational?360
ГЛАВА 9 • ТЕХНИЧЕСКИЕ ДЕТАЛИ: КЛАССЫ И ПРОЧЕЕ
14. Разработайте и реализуйте класс Money для вычислений, связанных с долларами
и центами, точность которых определяется по правилу округления 4/5 (0,5 цента
округляется вверх, все, что меньше 0,5, округляется вниз). Денежные суммы
должны представляться в центах с помощью переменной типа long, но ввод
и вывод должны использовать доллары и центы, например $123.45. Не беспо-
койтесь о суммах, выходящих за пределы диапазона типа long.
15. Уточните класс Money, добавив валюту (как аргумент конструктора). Начальное
значение в виде десятичного числа допускается, поскольку такое число можно пред-
ставить в виде переменной типа long. Не допускайте некорректных операций.
Например, выражение Мопеу*Мопеу не имеет смысла, a USD1.23+DKK5.00 имеет
смысл, только если существует таблица преобразования, определяющая обменный
курс между американскими долларами (USD) и датскими кронами (DKK).
16. Приведите пример вычислений, в котором класс Rational позволяет получить
более точные результаты, чем класс Money.
17. Приведите пример вычислений, в котором класс Rational позволяет получить
более точные результаты, чем тип double.
Послесловие
Существует много типов, определенных пользователем. Их гораздо больше, чем
представлено здесь. Типы, определенные пользователем, особенно классы, образу-
ют ядро языка C++ и являются ключом ко многим эффективным методам проекти-
рования. Большая часть оставшихся глав посвящена проектированию и использова-
нию классов. Класс — или набор классов — это механизм, позволяющий выразить
наши концепции в виде кода. В этой главе мы изложили в основном языковые
аспекты классов, в последующих главах мы сосредоточимся на том, как элегантно
выразить полезные идеи в виде классов.Часть II
Ввод и выводПотоки ввода и вывода
"Наука — это знания о том, как не дать себя одурачить".
Ричард Фейнман (Richard P. Feynman)
В этой и следующих главах описываются стандартные средства ввода
и вывода в языке C++: потоки ввода-вывода. Показано, как читать и за-
писывать файлы, как обрабатывать ошибки, а также применять операторы
ввода-вывода к типам, определенным пользователем. В центре внимания
данной главы находится базовая модель: как читать и записывать отдельные
значения, как открывать, читать и записывать целые файлы. В заключитель-
ном примере приводится большой фрагмент кода, иллюстрирующий эти ас-
пекты программирования. Детали описываются в следующей главе.364
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
10.8. Операторы вывода, определенные
пользователем
10.9. Операторы ввода, определенные
пользователем
10.10. Стандартный цикл ввода
10.11. Чтение структурированного файла
10.11.1. Представление в памяти
10.11.2. Считывание структурирован-
ных значений
10.11.3. Изменение представления
В этой главе...
10.1. Ввод и вывод
10.2. Модель потока ввода-вывода
10.3. Файлы
10.4. Открытие файла
10.5. Чтение и запись файла
10.6. Обработка ошибок ввода-вывода
10.7. Считывание отдельного значения
10.7.1. Разделение задачи на управляе-
мые части
10.7.2. Отделение диалога от функции
10.1. Ввод и вывод
Г7[ Без данных вычисления бессмысленны. Для выполнения интересующих нас
I—' вычислений мы должны ввести в программу данные и получить результаты.
В разделе 4.1 мы уже упоминали о чрезвычайном разнообразии источников данных
и адресатов для вывода. Если мы не проявим осторожность, то будем писать про-
граммы, получающие входные данных только из конкретного источника и выдаю-
щие результаты только на конкретное устройство вывода. В определенных прило-
жениях, например цифровых фотоаппаратах или сенсорах топливного инжектора,
это может быть приемлемым (а иногда даже необходимым), но при решении задач
более общего характера нам необходимо разделять способы, с помощью которых
программа читает и записывает данные, от реальных устройств ввода и вывода.
Если бы мы были вынуждены непосредственно обращаться к устройствам разных
видов, то каждый раз, когда на рынке появляется новый экран или диск, должны
были бы изменять свою программу или ограничивать пользователей лишь теми эк-
ранами и дисками, которые нам нравятся. Разумеется, это абсурд.
Большинство современных операционных систем поручают управление устройст-
вами ввода-вывода специализированным драйверам, а затем обращаются к ним с по-
мощью средств библиотеки ввода-вывода, обеспечивающих максимально единооб-
разную связь с разными источниками и адресатами данных. В общем, драйверы уст-
ройств глубоко внедрены в операционную систему и недоступны для большинства
пользователей, а библиотечные средства ввода-вывода обеспечивают абстракцию
ввода-вывода, так что программист не должен думать об устройствах и их драйверах.
Когда используется такая модель, вся входная и выходная информация может
рассматриваться как потоки байтов (символы), обрабатываемые средствами биб-
лиотеки ввода-вывода. Наша работа как программистов, создающих приложения,
сводится к следующему.
1. Настроить потоки ввода-вывода на соответствующие источники и адресаты
данных
2. Прочитать и записать их потоки.10.1. ВВОДИ ВЫВОД
365
Источник данных:
Устройство ввода
■*■ " *~ ■*- *-~- ■ ■ -- ■•* ■■'■ - ••
Адреса данных:
Драйвер устройства
"UPWfi'WV ■««■щ.м
Л
~ Наша программа
Би6^1(тв1нвв0/да'^
Библиотека вывода
1 , i
/Драйвер устройства
4 JJ
Устройство вывода
Практические детали передачи символов с устройства и на устройство находятся
в компетенции библиотеки ввода-вывода и драйверов устройств. В этой и следую-
щей главах мы увидим, как создать систему ввода-вывода, состоящую из потоков
форматированных данных, с помощью стандартной библиотеки языка C++.
0
С точки зрения программиста существует много разных видов ввода и вывода.
• Потоки (многих) единиц данных (как правило, связанных с файлами, сетевы-
ми соединениями, записывающими устройствами или дисплеями).
• Взаимодействие с пользователем посредством клавиатуры.
• Взаимодействие с пользователем посредством графического интерфейса
(вывод объектов, обработка щелчков мыши и т.д.).
Эта классификация не является единственно возможной, а различия между тремя
видами ввода-вывода не так отчетливы, как может показаться. Например, если по-
ток вывода символов представляет собой HTTP-документ, адресуемый браузеру,
то в результате возникает нечто, очень напоминающее взаимодействие с пользова-
телем и способное содержать графические элементы. И наоборот, результаты взаи-
модействия посредством пользовательского графического интерфейса можно пред-
ставить в программе в виде последовательности символов. Однако эта классифика-
ция соответствует нашим средствам: первые две разновидности ввода-вывода обес-
печиваются стандартными библиотечными потоками ввода-вывода и непосредст-
венно поддерживаются большинством операционных систем. Начиная с главы 1 мы
использовали библиотеку iostream и будем использовать ее в данной и следующей
главах. Графический вывод и взаимодействие с пользователем посредством графи-
ческого интерфейса обеспечиваются разнообразными библиотеками. Этот вид вво-
да-вывода мы рассмотрим в главах 12-16.366
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
10.2. Модель потока ввода-вывода
Стандартная библиотека языка C++ содержит определение типов istream для
потоков ввода и ostream— для потоков вывода. В наших программах мы исполь-
зовали стандартный поток istream с именем с in и стандартный поток ostream
с именем cout, поэтому эта часть стандартной библиотеки (которую часто называ-
ют библиотекой iostream) нам уже в принципе знакома.
|у | Поток ostream делает следующее.
• Превращает значения разных типов в последовательности символов.
• Посылает эти символы "куда-то" (например, на консоль, в файл, основную
память или на другой компьютер).
Поток ostream можно изобразить следующим образом.
Значения разных типов Последовательности символов
•с'
Vi*iO*t/
ostream
"Куда-то"
Буфер — это структура данных, которую поток ostream использует для хране-
ния информации, полученной от вас в ходе взаимодействия с операционной систе-
мой. Задержка между записью в поток ostream и появлением символов в пункте
назначения обычно объясняется тем, что эти символы находятся в буфере. Буфери-
зация важна для производительности программы, а производительность программы
важна при обработке больших объемов данных.
0
Поток istream делает следующее.
• Превращает последовательности символов в значения разных типов.
• Получает эти символы "откуда-то" (например, с консоли, из файла, из основ-
ной памяти или от другого компьютера).
Поток istream можно изобразить следующим образом.
Как и поток ostream, для взаимодействия с операционной системой поток
istream использует буфер. При этом буферизация может оказаться визуально за-
метной для пользователя. Когда вы используете поток istream, связанный с кла-
виатурой все, что вы введете, останется в буфере, пока вы не нажмете клавишуЮ.З. ФАЙЛЫ
Значения разных типов
V
(12,34)
123
<Enter> (ввести и перейти на новую строку), и если вы передумали, то можете сте-
реть символы с помощью клавиши <Backspace> (пока не нажали клавишу <Enter>).
Одно из основных применений вывода — организация данных для чтения, дос-
тупного людям. Вспомните о сообщениях электронной почты, академических
статьях, веб-страницах, счетах, деловых отчетах, списках контактов, оглавлениях,
показаниях датчиков состояния устройств и т.д. Потоки ostream предоставляют
много возможностей для форматирования текста по вкусу пользователей. Анало-
гично, большая часть входной информации записывается людьми или форматирует-
ся так, чтоб люди могли ее прочитать. Потоки istream обеспечивают возможности
для чтения данных, созданных потоками ostream. Вопросы, связанные с формати-
рованием, будут рассмотрены в разделе 11.2, а ввод информации, отличающейся
от символов,— в разделе 11.3.2. В основном сложность, связанная с вводом дан-
ных, обусловлена обработкой ошибок. Для того чтобы привести более реалистич-
ные примеры, начнем с обсуждения того, как модель потоков ввода-вывода связы-
вает файлы с данными.
10.3. Файлы
Обычно мы имеем намного больше данных, чем способна вместить основная
память нашего компьютера, поэтому большая часть информации хранится на
дисках или других средствах хранения данных высокой емкости. Такие устройства
также предотвращают исчезновение данных при выключении компьютера — такие
данные являются персистентными. На самом нижнем уровне файл просто представ-
ляет собой последовательность байтов, пронумерованных начиная с нуля.
0: 1: 2:
Файл имеет формат; иначе говоря, набор правил, определяющих смысл байтов.
Например, если файл является текстовым, то первые четыре байта представляют
собой первые четыре символа. С другой стороны, если файл хранит бинарное пред-
ставление целых чисел, то первые четыре байта используются для бинарного пред-
367
Последовательности символов
\
■Откуда-то'
0368
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
ставления первого целого числа (раздел 11.3.2). Формат по отношению к файлам на
диске играет ту же роль, что и типы по отношению к объектам в основной памяти.
Мы можем приписать битам, записанным в файле, определенный смысл тогда
и только тогда, когда известен его формат (разделы 11.2 и11.3).
[™7[ При работе с файлами поток ostream преобразует объекты, хранящиеся
*-—' в основной памяти, в потоки байтов и записывает их на диск. Поток istream
действует наоборот; иначе говоря, он считывает поток байтов с диска и составляет
из них объект.
Основная
память
Файлы Потоки iostream Объекты
(последовательности байтов) (разных типов)
Чаще всего мы предполагаем, что байты на диске являются символами из обыч-
ного набора символов. Это не всегда так, но, поскольку другие представления обра-
ботать несложно, мы, как правило, будем придерживаться этого предположения.
Кроме того, будем считать, что все файлы находятся на дисках (т.е. на вращающих-
ся магнитных устройствах хранения данных). И опять-таки это не всегда так
(вспомните о флэш-памяти), но на данном уровне программирования фактическое
устройство хранения не имеет значения. Это одно из главных преимущество абст-
ракций файла и потока.
Для того чтобы прочитать файл, мы должны
• знать его имя;
• открыть его (для чтения);
• считать символы;
• закрыть файл (хотя это обычно выполняется неявно).
Для того чтобы записать файл, мы должны
• назвать его;
• открыть файл (для записи) или создать новый файл с таким именем;
• записать наши объекты;
• закрыть файл (хотя это обычно выполняется неявно).
Мы уже знаем основы чтения и записи, поскольку во всех рассмотренных нами си-
туациях поток ostream, связанный с файлом, ведет себя точно так же, как поток cout,
а поток istream, связанный с файлом, ведет себя точно так же, как объект cin. Опе-
рации, характерные только для файлов, мы рассмотрим позднее (в разделе 113.ЗХ
а пока посмотрим, как открыть файлы, и сосредоточим свое внимание на операциях
и приемах, которые можно применить ко всем потокам ostream и istream,Ю.4. ОТКРЫТИЕ ФАЙЛА 36в
10.4. Открытие файла
Если хотите считать данные из файла или записать их в файл, то должны
открыть поток специально для этого файла. Поток if stream — это поток
istream для чтения из файла, поток of stream — это поток ostream для записи
в файл, а поток f stream— это поток iostream, который можно использовать как
для чтения, так и для записи. Перед использованием файлового потока его следует
связать с файлом. Рассмотрим пример.
cout << "Пожалуйста, введите имя файла: ";
string name;
cin >> name;
ifstream ist(name.cstr()); // ist — это поток ввода для файла,
// имя которого задано строкой name
if (list) error("невозможно открыть файл для ввода ",name);
Определение потока ifstream с именем, заданным строкой name, открывает
файл с этим именем для чтения. Функция c_str () — это член класса string,
создающий низкоуровневую строку в стиле языка С из объекта класса string.
Такие строки в стиле языка С требуются во многих системных интерфейсах. Про-
верка list позволяет выяснить, был ли файл открыт корректно. После этого можно
считывать данные из файла точно так же, как из любого другого потока istream.
Например, предположим, что оператор ввода >> определен для типа Point. Тогда
мы могли бы написать следующий фрагмент программы:
vector<Point> points;
Point p;
while (ist>>p) points.pushback(p);
Вывод в файлы аналогичным образом можно выполнить с помощью потоков
of stream. Рассмотрим пример.
cout << "Пожалуйста, введите имя файла для вывода: ";
string oname;
cin >> oname;
ofstream ost(oname.cstr()); // ost — это поток вывода для файла,
// имя которого задано строкой name
if (lost) error("can't open output file ",oname);
Определение потока ofstream с именем, заданным строкой name, открывает
файл с этим именем для чтения. Проверка lost позволяет выяснить, был ли файл
открыт корректно. После этого можно записывать данные в файл точно так же, как
в любой другой поток ostream. Рассмотрим пример.
for (int i=0; i<points.size(); ++i)
ost << '(' << points [i] .x << ',' << points[i].у << ")\n";
Когда файловый поток выходит из пределов видимости, связанный с ним файл
закрывается. Когда файл закрывается, связанный с ним буфер "очищается" ("flushed");
иначе говоря, символы из буфера записываются в файл.370
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
Как правило, файлы в программе лучше всего открывать как можно раньше, до
выполнения каких-либо серьезных вычислений. Помимо всего прочего, было бы
слишком расточительным выполнить большую часть работы и обнаружить, что вы
не можете ее завершить, потому что вам некуда записать результаты.
Открытие файла неявно является частью процесса создания потоков oetream
и istream. В идеале при закрытии файла следует полагаться на его область видимости.
Рассмотрим пример.
void £ill_£rom_£ile(vector<Point>& points, strings name)
{
ifstream ist(name.c_str()); // открываем файл для чтения
if (list) error ("невозможно открыть файл для ввода "«name);
II... используем поток ist . . .
// файл неявно закроется, когда мы выйдем из функции
}
Кроме того, можно явно выполнить операции open () и close () (раздел В.7.1).
Однако ориентация на область видимости минимизирует шансы того, что вы по-
пытаетесь использовать файловый поток до того, как файл будет связан с потоком,
или после того, как он был закрыт. Рассмотрим пример.
ifstream ifs;
// . . .
ifs >> foo; // не выполнено: для потока its не открыт ни один файл
// . . .
i fs. open (name, iosbase:: in) ; // открываем файл, имя которого задано
// строкой name
// • . •
ifs.closeO; // закрываем файл
// • • •
ifs >> bar; // не выполнено: файл, связанный с потоком ifs, закрыт
// . . .
В реальной программе возникающие проблемы, как правило, намного труднее.
К счастью, мы не можем открыть файловый поток во второй раз, предварительно
его не закрыв. Рассмотрим пример.
fstream fs;
fs.open("fooп, iosbase::in) ; // открываем файл для ввода
// пропущена функция close ()
fs.open(иfoo", ios_base::out); // не выполнено: поток ifs уже открыт
if (fs) error("невозможно");
He забывайте проверять поток после его открытия.
Почему допускается явное использование функций ореп() и close О? Дело
в том, что иногда время жизни соединения с файлом не ограничивается его обла-
стью видимости. Однако это событие происходит так редко, что о нем можно
не беспокоиться. Более важно то, что такой код можно встретить в программах,
в которых используются стили и идиомы языков и библиотек, отличающихся
010.5. ЧТЕНИЕ И ЗАПИСЬ ФАЙЛА
371
от стилей и идиом, используемых в потоках iostream (и в остальной части стан-
дартной библиотеки C++).
Как будет показано в главе 11, о файлах можно сказать намного больше, но сей-
час нам достаточно того, что их можно использовать в качестве источников и адре-
сатов данных. Это позволяет нам писать программы, которые были бы нереали-
стичными, если бы предложили пользователю непосредственно вводить с клавиату-
ры всю входную информацию. С точки зрения программиста большое преиму-
щество файла заключается в том, что мы можем снова прочитать его в процессе
отладки, пока программа не заработает правильно.
10.5. Чтение и запись файла
Посмотрим, как можно было бы считать результаты некоторых измерений
из файла и представить их в памяти. Допустим, в файле записана температура воз-
духа, измеренная на метеостанции.
0 60.7
1 60.6
2 60.3
3 59.22
• • •
Этот файл содержит последовательность пар (время суток, температура). Часы
пронумерованы от о до 23, а температура измерена по шкале Фаренгейта. Дальней-
шее форматирование не предусмотрено; иначе говоря, файл не содержит никаких
заголовков (например, информации об источнике данных), единиц измерений, зна-
ков пунктуации (например, скобок вокруг каждой пары значений) или признак кон-
ца файла. Это простейший вариант.
Представим информацию в виде структуры Reading.
struct Reading { // данные о температуре воздуха
int hour; // часы после полуночи [0:23]
double temperature; // по Фаренгейту
Reading(int h, double t) :hour(h), temperature(t) { }
};
В таком случае данные можно считать следующим образом:
vector<Reading> temps; // здесь хранится считанная информация
int hour;
double temperature;
while (ist >> hour >> temperature) {
if (hour < 0 || 23 <hour) error("некорректное время");
temps.pushback(Reading(hour,temperature) ) ;
}
Это типичный цикл ввода. Поток istream с именем ist мог бы быть файловым
потоком ввода (if stream), как в предыдущем разделе, стандартным потоком ввода372
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
(сin) или любым другим потоком istream. Для кода, подобного приведенному
выше, не имеет значения, откуда поток istream получает данные. Все» что требу*
ется знать нашей программе, — это то, что поток ist относится к классу £ stream
и что данные имеют ожидаемый формат. Следующий раздел посвящен интересному
вопросу: как выявлять ошибки в наборе входных данных и что можно сделать после
выявления ошибки форматирования.
Записать данные в файл обычно проще, чем считать их оттуда. Как и прежде, как
только поток проинициализирован, мы не обязаны знать, что именно он собой
представляет. В частности, мы можем использовать выходной файловый поток
(of stream) из предыдущего раздела наравне с любым другим потоком ost ream.
Например, мы могли бы пожелать, чтобы на выходе каждая пара была заключена
в скобки.
for (int i=0; i<temps.size(); ++i)
ost « '(' « temps [i] .hour « ',' « temps [i] . temperature « n)\n";
Затем итоговая программа прочитала бы исходные данные из файла и создала
новый файл в формате (час, температура).
Поскольку файловые потоки автоматически закрывают свои файлы при выхо-
де из области видимости, полная программ принимает следующий вид:
#include "std_lib_facilities.h"
struct Reading { // данные о температуре воздуха
int hour; // часы после полуночи [0:23]
double temperature; //по Фаренгейту
Reading(int h, double t) :hour(h), temperature(t) { }
}i
int main()
{
cout << "Пожалуйста, введите имя файла для ввода: ";
string name;
cin >> name;
ifstream ist(name.cstr() ) ; // поток ist считывает данные
//из файла,
// имя которого задано строкой name
if (list) error ("невозможно открыть файл для ввода ",name);
cout << "Пожалуйста, введите имя файла для вывода: ";
cin >> name;
ofstream ost(name.cstrО ) ; // поток ost записывает данные
//в файл, имя которого задано
// строкой name
if (lost) error ("невозможно открыть файл для вывода ",name);
vector<Reading> temps; // здесь хранится считанная информация
int hour;
double temperature;10.6. ОБРАБОТКА ОШИБОК ВВОДА-ВЫВОДА
373
while (let >> hour >> temperature) {
if (hour < 0 || 23 <hour) error("некорректное время");
temps .pushback (Reading (hour, temperature) );
}
for (int i=0; i<temps.size(); ++i)
ost << '(' << temps[i].hour « ','
<< temps[i].temperature << n)\nn;
}
10.6. Обработка ошибок ввода-вывода
Вводя данные, мы должны предвидеть ошибки и обрабатывать их. Какими бы-
вают ошибки? Как их обрабатывать? Ошибки возникают из-за того, что их совер-
шают люди (неправильно поняли инструкцию, сделали опечатку, по клавиатуре
прошлась кошка и т.д.), из-за того, что файлы не соответствуют спецификациям, из-
за того, что программисты имеют неправильное представление об ожидаемых дан-
ных, и т.д. Возможности для совершения ошибок при вводе данных ничем не огра-
ничены! Однако поток istream сводит их все к четырем возможным классам,
которые называют состояниями потока (stream state)
Состояния потока
good () Операции выполнены успешно
eof () Достигнут конец ввода (конец файла)
fail () Произошло неожиданное событие
bad () Произошло неожиданное и серьезное событие
К сожалению, различия между состояниями fail () и bad О определены неточ-
но и зависят от точки зрения программистов на определение операций ввода-
вывода для новых типов. Однако основная идея проста: если операция ввода обнару-
живает простую ошибку форматирования, она позволяет потоку вызвать функцию
fail (), предполагая, что вы (пользователь операции ввода) способны ее исправить.
Если же, с другой стороны, произошло нечто совершенно ужасное, например непра-
вильное чтение с диска, то операция ввода позволяет потоку вызвать функцию bad (),
предполагая, что вам ничего не остается делать, кроме как отказаться от попытки счи-
тать данные из потока. Это приводит нас к следующей общей логике:
int i = 0;
cin >> i;
if (!cin) { // мы окажемся здесь (и только здесь),
// если операция ввода не выполнена
if (cin.badO) error(ncin испорчен"); // поток поврежден: стоп!
if (cin.eof О) {
// входных данных больше нет
// именно так мы хотели бы завершить ввод данных
}
0374
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
if (cin.failO) { //с потоком что-то случилось
cin.clear(); // приготовиться к дальнейшему вводу
// исправление ситуации
}
}
Выражение lcin можно прочитать как "поток cin в плохом состоянии*', или
"с потоком cin что-то случилось", или "поток cin не находится в состоянии
good О". Это выражение противоположно по смыслу выражению "операция ус-
пешно завершена". Обратите внимание на инструкцию с in. clear О, в которой об-
рабатывается состояние fail (). Если поток поврежден, то мы, вероятно, можем его
восстановить. Для того чтобы сделать это, мы явно выводим поток из состояния
fail () и можем снова просматривать последовательность символов, находящихся
в этом потоке; функция clear О гарантирует, что после выполнения вызова
cin. clear () поток cin перейдет в состояние good ().
Рассмотрим пример использования состояния потока. Представим себе, что счи-
тываем в вектор последовательность целых чисел, которые могут завершаться сим-
волом * или признаком конца файла (<Ctrl+Z> в системе Windows или <Ctrl+D>
в системе Unix). Например, пусть в файле записаны следующие числа:
1 2 3 4 5 *
Ввести их можно с помощью такой функции:
void filljvector(istream& ist, vector<int>& v, char terminator)
// считывает целые числа из потока ist в вектор V,
// пока не будет достигнут признак eof () или символ завершения
{
int i = 0;
while (ist >> i) v.pushback(i);
if (ist.eof()) return; // отлично: мы достигли конца файла
if (ist.badO) error("поток ist поврежден"); // поток поврежден;
// стоп!
if (ist.failO) { // очищаем путаницу как можем и сообщаем
// об ошибке
ist.clear(); // очищаем состояние потока
// и теперь снова можем искать признак
// завершения
char с;
ist>>c; // считываем символ, возможно, признак
// завершения
if (с != terminator) { // неожиданный символ
ist.ungetO; // возвращаем этот символ назад
ist.clear(iosbase:rfailbit) ; // переводим поток
// в состояние fail()
}
}
}10.6. ОБРАБОТКА ОШИБОК ВВОДА-ВЫВОДА
375
Обратите внимание на то, что пока мы не найдем признак конца файла, мы
не выйдем из цикла. Кроме того, мы можем собрать некоторые данные, и функция,
вызвавшая функцию fillvectorO, может попытаться вывести поток из состоя-
ния fail (). Поскольку мы очистили состояние, то, для того чтобы проверить сим-
вол, должны вернуть поток обратно в состояние fail О. Для этого выполняется
инструкция ist.clear (ios_base: :failbit). Обратите внимание на потенциаль-
но опасное использование функции clear(): на самом деле функция clear()
с аргументом устанавливает указанные флаги (биты) состояния потока iostream,
сбрасывая (только) не указанные. Переводя поток в состояние fail О, мы указыва-
ем, что обнаружили ошибку форматирования, а не нечто более серьезное. Мы воз-
вращаем символ обратно в поток ist, используя функцию imgetO; функция, вы-
зывающая функцию fillvector (), может использовать его по своему усмотре-
нию. Функция ungetO представляет собой более короткий вариант функции
putback (), который основывается на предположении, что поток помнит, какой
символ был последним, и поэтому его не обязательно указывать явно.
Если вы вызвали функцию f illvector О и хотите знать, что вызвало прекраще-
ние ввода, то можно проверить состояния fail О и eof (). Кроме того, можно пере-
хватить исключение runtimeerror, сгенерированное функцией error (), но понят-
но, что маловероятно получить больше данных из потока istream, находящегося
в состоянии bad (). Большинство вызывающих функций не предусматривает сложной
обработки ошибок. По этой причине практически во всех случаях единственное, чего
мы хотим сделать, обнаружив состояние bad (), — сгенерировать исключение.
Для того чтобы облегчить себе жизнь, можем поручить потоку i stream сде-
лать это за нас.
// поток ist генерирует исключение, если попадает в состояние bad
ist.exceptions(ist.exceptions()|ios_base::badbit);
Эти обозначения могут показаться странными, но результат простой: если поток
ist окажется в состоянии bad О, он сгенерирует стандартное библиотечное исклю-
чение iosbase: : failure. Вызвать функцию exceptions () можно только один
раз. Все это позволяет упростить циклы ввода, игнорируя состояние bad ().
void fillvector(istreamb ist, vector<int>& vf char terminator)
// считываем целые числа из потока ist в вектор v, пока не
// достигнем конца файла eofО или признака завершения
{
int i = 0;
while (ist >> i) v.push_back(i);
if (ist.eofO) return; // отлично: обнаружен конец файла
// не goodO, не bad () и не eof О,
// поток ist должен быть переведен в состояние fail()
iet.clearO; // сбрасываем состояние потока376
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
char с;
ist>>c; // считываем символ в поисках признака завершения ввода
if (с != terminator) { // ох: это не признак завершения ввода,
// значит, нужно вызывать функцию fail О
ist.unget() ; // может быть, вызывающая функция
// может использовать этот символ
ist.clear(iosbase::failbit); // установить состояние fail()
}
}
Класс iosbase является частью потока iostream, в котором хранятся констан-
ты, такие как badbit, исключения, такие как failure, и другие полезные вещи.
Для обращения к нему необходим оператор ::, например iosbase:: badbit
(разделы 10.6 и В.7.2). Мы не планируем подробно описывать библиотеку
iostream; для этого понадобился бы отдельный курс лекций. Например, потоки
iostream могут обрабатывать разные наборы символов, реализовывать разные
стратегии буферизации, а также содержат средства форматирования представлений
денежных средств на разных языках (однажды мы даже получили сообщение об
ошибке, связанной с форматированием представления украинской валюты). Все,
что вам необходимо знать о потоках iostream, можно найти в книгах Страуструп
(Stroustrup), The C++ Programming Language Страуструпа и Лангер (Langer), Stan-
dard C++ IOStreams and Locales.
Поток ostream имеет точно такие же состояния, как и поток i stream: good О,
fail (), eof () и bad(). Однако в таких программах, которые мы описываем в этой
книге, ошибки при выводе встречаются намного реже, чем при вводе, поэтому мы
редко их проверяем. Если вероятность того, что устройство вывода недоступно, пе-
реполнено или сломано, является значительной, то в программе следует предусмот-
реть проверку состояния потока вывода после каждой операции вывода, так как мы
сделали выше по отношению к операции ввода.
10.7. Считывание отдельного значения
Итак, мы знаем, как считать последовательность значений, завершающихся при-
знаком конца файла или завершения ввода. Впоследствии мы рассмотрим еще не-
сколько примеров, а сейчас обсудим все еще популярную идею о том, чтобы не-
сколько раз запрашивать значение, пока не будет введен его приемлемый вариант.
Это позволит нам проверить несколько распространенных проектных решений.
Мы обсудим эти альтернативы на примерах нескольких решений простой пробле-
мы — как получить от пользователя приемлемое значение. Начнем с очевидного,
но скучного и запутанного варианта под названием "сначала попытайся", а затем
станем его постепенно совершенствовать. Наше основное предположение заключа-
ется в том, что мы имеем дело с интерактивным вводом, в ходе которого человек
набирает на клавиатуре входные данные и читает сообщения, поступающие от про-10.7. СЧИТЫВАНИЕ ОТДЕЛЬНОГО ЗНАЧЕНИЯ
377
граммы. Давайте предложим пользователю ввести целое число от 1 до 10 (включи-
тельно).
cout << "Пожалуйста, введите целое число от 1 до 10
(включительно) :\п";
int n = 0;
while (cin>>n) { // читаем
if (1<=п && n<=10) break; // проверяем диапазон
cout << "Извините " << п
<< " выходит за пределы интервала [1:10]; попробуйте еще\п";
}
Этот код довольно уродлив, но отчасти работоспособен. Если вы не любите
использовать оператор break (раздел А.6), то можете объединить считывание
и проверку диапазона.
cout << "Пожалуйста, введите целое число от 1 до 10
(включительно):\п";
int n = 0;
while (cin>>n && ! (1<=п && п< = 10) ) // read and check range
cout << "Извините, "
<< n << "выходит за пределы интервала [1:10];
попробуйте еще\п";
Тем не менее эти изменения носят всего лишь "косметический" характер.
Почему мы утверждаем, что этот код работоспособен только отчасти? Дело
в том, что он будет работать, если пользователь аккуратно вводит целые числа. Если
же пользователь небрежен и наберет букву t вместо цифры б (на большинстве кла-
виатур буква t расположена прямо под цифрой б), то программа выйдет из цикла,
не изменив значения переменной п, поэтому это число окажется за пределами до-
пустимого диапазона. Такой код нельзя назвать качественным. Шутник (или усерд-
ный испытатель) также может ввести с клавиатуры признак конца файла (нажав
комбинацию клавиш <Ctrl+Z> в системе Windows или <Ctrl+D> в системе Unix).
И снова программа выйдет из цикла со значением п, лежащим за пределами допус-
тимого диапазона. Иначе говоря, для того чтобы обеспечить надежный ввод,
мы должны решить три проблемы.
1. Что делать, если пользователь вводит число, находящееся за пределами допус-
тимого диапазона?
2. Что делать, если пользователь не вводит никакого числа (признак конца файла)?
3. Что делать, если пользователь вводит неправильные данные (в данном случае
не целое число)?
Что же делать во всех этих ситуациях? При создании программ часто возникает
вопрос: чего мы на самом деле хотим? В данном случае для каждой из трех ошибок
у нас есть три альтернативы.
1. Решить проблему в коде при вводе данных.
0378 ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
2. Сгенерировать исключение, чтобы кто-то другой решил проблему (возможно,
прекратив выполнение программы).
3. Игнорировать проблему.
Между прочим, эти три альтернативы являются очень распространенными
при обработке ошибок. Таким образом, это хороший пример рассуждений об
ошибках.
Заманчиво сказать, что третья альтернатива, т.е. игнорировать проблему,
ни в коем случае не является приемлемой, но это было бы преувеличением. Если я
пишу простую программу для своего собственного использования, то могу делать
все, что захочу, даже забыть о проверке ошибок, которые могут привести к ужас-
ным результатам. Однако если я пишу программу, которую буду использовать через
несколько часов после ее создания, то было бы глупо оставлять такие ошибки. Если
же я планирую передать свою программу другим людям, то не стану оставлять та-
кие дыры в системе проверки ошибок. Пожалуйста, обратите внимание на то, что
местоимение "я" здесь использовано намеренно; местоимение "мы" могло бы вве-
сти в заблуждение. Мы не считаем третью альтернативу приемлемой, даже если
в проекте участвуют только два человека.
Выбор между первой и второй альтернативами является настоящим; иначе гово-
ря, в программе могут быть веские причины выбрать любой из них. Сначала отме-
тим, что в большинстве программ нет локального и элегантного способа обработать
ситуацию, когда пользователь не вводит данные, сидя за клавиатурой: после того,
как поток ввода был закрыт, нет большого смысла предлагать пользователю ввести
число. Мы могли бы заново открыть поток с in (используя функцию с in. clear ()),
но пользователь вряд ли закрыл этот поток непреднамеренно (как можно случайно
нажать комбинацию клавиш <Ctrl+Z>?). Если программа ждет ввода целого числа
и обнаруживает конец файла, то часть программы, пытающаяся прочитать это чис-
ло, должна прекратить свои попытки и надеяться, что какая-то другая часть про-
граммы справится с этой проблемой; иначе говоря, наш код, требующий ввода от
пользователя, должен сгенерировать исключение. Это значит, что выбор происхо-
дит не между локальным генерированием исключений и решением проблемы, а ме-
жду задачами, которые следует решить локально (если они возникают).
10.7.1. Разделение задачи на управляемые части
Попробуем решить проблемы, связанные с выходом за пределы допустимого
диапазона при вводе и при вводе данных неправильного типа.
cout << "Пожалуйста, введите целое число от 1 до 10
(включительно):\п";
int n = 0;
while (true) {
cin » n;
if (cin) { // мы ввели целое число; теперь проверим его10.7. СЧИТЫВАНИЕ ОТДЕЛЬНОГО ЗНАЧЕНИЯ 370
if (1<*п && n<=10) break;
cout « "Извините, ■
<< п << "выходит за пределы интервала [1:10];
попробуйте еще\п";
}
else if (cin.failO) { // обнаружено нечто, что является
// целым числом
cin.clearO; // возвращаем поток в состояние good() ;
// мы хотим взглянуть на символы
cout « "Извините, это не число; попробуйте еще раэ\п";
char ch;
while (cin»ch && 1 isdigit (ch)) ; // отбрасываем не цифры
if (Icin) error("ввода нет"); // цифры не обнаружены:
// прекратить
cin.unget (); // возвращаем цифру назад,
// чтобы можно было считать число
}
else {
error("ввода нет"); // состояние eof или bad: прекратить
}
}
// если мы добрались до этой точки, значит, число п лежит
// в диапазоне [1:10]
IvTl Этот код запутан и многословен. На самом деле мы бы не рекомендовали лю-
1~' дям писать такие программы каждый раз, когда они ждут от пользователя вво-
да целого числа. С другой стороны, мы должны предусматривать потенциальные
ошибки, поскольку людям свойственно ошибаться. Так что же делать? Причина то-
го, что этот код так запутан, заключается в том, что в нем перемешано сразу
несколько проблем.
• Считывание значения.
• Предложение к вводу.
• Вывод сообщений об ошибках.
• Пропуск "плохих" входных символов.
• Проверка диапазона входных чисел.
=Ь| Для того чтобы сделать код яснее, часто достаточно просто логически разде-
=1 лить задачи среди нескольких функций. Например, мы можем выделить код,
восстанавливающий ввод после обнаружения "плохого" (т.е. неожиданного) символа.
void skip to int()
{
if (cin.failO) { // обнаружено нечто, что является целым числом
cin.clearO; // возвращаем поток в состояние good О ;
// мы хотим взглянуть на символы
char ch;
while (cin>>ch){ ; // отбрасываем не цифры
if (isdigit(ch));380
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
cin.ungetO; // возвращаем цифру назад,
// чтобы можно была считать число
}
}
}
error ("ввода нет"); // состояние eof или bad: прекратить
>
Имея вспомогательную функцию skip_to_int(), можем написать следую-
щий код:
cout « "Пожалуйста, введите целое число от 1 до 10
(включительно) : \п";
int n = 0;
while (true) {
if (cin>>n) { // мы ввели целое число; теперь проверим его
if (1<=п && n<=10) break;
cout << "Извините, " « п
« "выходит за пределы интервала [1:10]; попробуйте еще\п";
}
else {
cout « "Извините, это не число; попробуйте еще раэ\п";
skip_to_int();
}
}
// если мы добрались до этой точки, значит, число п лежит
// в диапазоне [1:10]
Этот код лучше, но остается слишком длинным и запутанным для того, чтобы
много раз применять его в программе. Мы никогда не добьемся желаемого резуль-
тата, разве что после (слишком) долгой проверки. Какие операции мы бы хотели
иметь на самом деле? Один из разумных ответов звучит так: "Нам нужны две функ-
ции: одна должна считывать любое число типа int, а другая — целое число из за-
данного диапазона".
int get_int(); // считывает число типа int из потока cin
int get_int(int low, int high); // считывает из потока cin число int,
// находящееся в диапазоне [low:high]
Если бы у нас были эти функции, то мы могли бы, по крайней мере, использо-
вать их просто и правильно. Их несложно написать.
int get_int()
{
int n = 0;
while (true) {
if (cin >> n) return n;
cout << "Извините, это не число; попробуйте еще раз\па;
skip_to_int();
}
}10.7. СЧИТЫВАНИЕ ОТДЕЛЬНОГО ЗНАЧЕНИЯ
381
В принципе функция getint () упорно считывает данные, пока не найдет циф-
ры, которые можно интерпретировать как целое число. Если требуется прекратить
работу функции getint (), то следует ввести целое число или признак конца фай-
ла (во втором случае функция getint () сгенерирует исключение).
Используя такую общую функцию get_int О, можем написать проверку выхода
за пределы диапазона get_int ():
int get_int(int low, int high)
{
cout << "Пожалуйста, введите целое число из от "
<< low << " до " « high « " (включительно) :\п";
while (true) {
int n = get_int();
if (low<=n && n<=high) return n;
cout << "Извините, " « n
<< "выходит за пределы интервала ["« low « ':' « high
<< "]; попробуйте еще\п";
}
}
Этот вариант функции get_int() работает также упорно, как и остальные.
Она продолжает ввод целых чисел, выходящих за пределы диапазона, пока не най-
дет число, лежащее в указанных пределах.
Теперь можем написать код для ввода целых чисел.
int n = get_int(1,10);
cout << "n: " << n << endl;
int m = getint (2,300);
cout << "m: " << m << endl;
He забудьте предусмотреть перехват исключения, если не хотите получить сооб-
щения об ошибках в (возможно, редкой) ситуации, когда функция get_int()
на самом деле не может ввести ни одного числа.
10.7.2. Отделение диалога от функции
Разные варианты функции get_int () по-прежнему смешивают ввод данных с вы-
водом сообщений, адресованных пользователю. Для простых программ это вполне
допустимо, но в большой программе мы можем пожелать, чтобы сообщения были
разными. Для этого понадобится функция get_int (), похожая на следующую:
int strength = get_int(1,10,"введите силу",
"Вне диапазона, попробуйте еще");
cout << "сила: " << strength << endl;
int altitude = get_int(0,50000,
"Пожалуйста, введите высоту в футах",
"Вне диапазона, пожалуйста, попробуйте еще");
cout << "высота: " << altitude << "футов над уровнем моря\п";382
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫ80ДА
Эту задачу можно решить так:
int get_int(int low, int high, const stringfc greeting,
const strings sorry)
{
cout << greeting << ": [" << low << ':' << high << и]\п";
while (true) {
int n ■ get_int()?
if (low<=n && n<=high) return n;
cout << sorry « ": [" << low << ':• << high << "]\пи;
}
}
Довольно трудно составить произвольные сообщения из заготовок, поэтому
необходимо выработать стиль сообщений. Часто это оказывается полезным и по-
зволяет составлять действительно гибкие сообщения, необходимые для поддержки
многих естественных языков (например, арабского, бенгальского, китайского,
датского, английского и французского). Однако эта задача не для новичков.
Обратите внимание на то, что наше решение осталось незавершенным: функция
get_int () без указания диапазона осталась "болтушкой". Более тонкий аспект этой
проблемы заключается в том, что вспомогательные функции, используемые в раз-
ных частях программы, не должны содержать "вшитых" сообщений. Далее, библио-
течные функции, которые по своей сути предназначены для использования во мно-
гих программах, вообще не должны выдавать никаких сообщений для пользова-
теля, — помимо всего прочего, автор библиотеки может даже не предполагать, что
программа, в которой используется его библиотека, будет выполняться на машине
под чьим-то наблюдением. Это одна из причин, по которым наша функция error ()
не выводит никаких сообщений об ошибках (см. раздел 5.6.3); в общем, мы не мо-
жем знать, куда их писать.
10.8. Операторы вывода, определенные пользователем
Определение оператора вывода << для заданного типа, как правило, представля-
ет собой тривиальную задачу. Основная проблема при его разработке заключается
в том, что разные люди могут предпочитать разные представления результатов,
поэтому трудно прийти к общему соглашению о каком-то едином формате. Однако,
даже если не существует единого формата, который мог бы удовлетворить всех
пользователей, часто целесообразно предусмотреть оператор << для типа, опреде-
ленного пользователем. В ходе отладки и на первых этапах проектирования нам
нужно хотя бы просто записывать объекты, имеющие указанный тип. Позднее нам
может понадобиться более сложный оператор вывода <<, позволяющий пользовате-
лю получать форматированную информацию. Кроме того, если представление вы-
ходной информации отличается от стандартного представления, обеспечиваемого10.9. ОПЕРАТОРЫ ВВОДА, ОПРЕДЕЛЕННЫЕ ПОЛЬЗОВАТЕЛЕМ
38*
обычным оператором «, мы можем просто обойти этот оператор и записывать
отдельные части объектов пользовательского типа так, как мы хотим.
Рассмотрим простой оператор вывода для типа pate из раздела 9.8, который
просто печатает год, месяц и день, разделенные запятыми.
oetream& operator<<(ostream& os, const Datet d)
{
return os << '(' << d.yearO
<< ',' << d.month()
« •, • « d.dayO « ') ' ;
}
Таким образом, дата 30 августа 2004 года будет представлена как (204,8,30).
Такое простое представление элементов в виде списка типично для типов, содер-
жащих небольшое количество членов, хотя мы могли бы реализовать более слож-
ную идею или точнее учесть специфические потребности.
В разделе 9.6 мы упоминали о том, что оператор, определенный пользователем,
выполняется с помощью вызова соответствующей функции. Рассмотрим при-
мер. Если в программе определен оператор вывода « для типа Date, то инструкция
cout << dl;
где объект dl имеет тип Date, эквивалентна вызову функции
opera tor << (cout, dl) ;
Обратите внимание на то, что первый аргумент ostreamfc функции operator« ()
одновременно является ее возвращаемым значением. Это позволяет создавать
"цепочки" операторов вывода. Например, мы могли бы вывести сразу две даты.
cout << dl << d2;
В этом случае сначала был бы выполнен первый оператор «, а затем второй.
cout << dl << d2; // т.е. operator<<(cout,dl) << d2 ;
II т.е. operator<<(operator<<(cout,dl),d2);
Иначе говоря, сначала происходит первый вывод объекта dl в поток cout, а за-
тем вывод объекта d2 в поток вывода, являющийся результатом выполнения пер-
вого оператора. Фактически мы можем использовать любой из указанных трех ва-
риантов вывода объектов dl и d2. Однако один из этих вариантов намного проще
остальных.
10.9. Операторы ввода, определенные пользователем
Определение оператора ввода >> для заданного типа и формат ввода обычно
тесно связаны с обработкой ошибок. Следовательно, эта задача может оказаться до-
вольной сложной.
0384
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
Рассмотрим простой оператор ввода для типа Date из раздела 9.8, который счи-
тывает даты, ранее записанные с помощью оператора «, определенного выше.
istream& operator»(istreamfc is, Date& dd)
{
int y, m, d;
char chl, ch2, ch3/ ch4;
is » chl » у » ch2 >> m >> ch3 >> d >> ch4;
if (Us) return is;
if (chll-'C || ch21*',' || сЬЗ!*',' || ch4! = •)•) { // ошибка
// формата
is.clear(iosjbaee::failbit);
return is;
>
dd = Date (y.Date::Month(m) ,d); // обновляем объект dd
return is;
}
Этот оператор » вводит такие тройки, как (2004,8,20), и пытается создать
объект типа Date из заданных трех чисел. Как правило, выполнить ввод данных
намного труднее, чем их вывод. Просто при вводе данных намного больше возмож-
ностей для появления ошибок, чем при выводе.
Если данный оператор » не находит трех чисел, заданных в формате {целое, целое,
целое), то поток ввода перейдет в одно из состояний, fail, eof или bad, а целевой
объект типа Date останется неизмененным. Для установки состояния потока istream
используется функция-член clear (). Очевидно, что флаг iosbase: tfailbit пере-
водит поток в состояние fail О. В идеале при сбое во время чтения следовало бы ос-
тавить объект класса Date без изменений; это привело бы к более ясному коду.
В идеале хотелось бы, чтобы функция operator>> () отбрасывала любые символы,
которые она не использует, но в данном случае это было бы слишком трудно сделать:
мы должны были бы прочитать слишком много символов, пока не обнаружится
ошибка формата. В качестве примера рассмотрим тройку (2004, 8, 30}. Только ко-
гда мы увидим закрывающую фигурную скобку, }, обнаружится ошибка формата,
и нам придется вернуть в поток много символов. Функция unget () позволяет вернуть
только один символ. Если функция operator>>() считывает неправильный объект
класса Date, например (2004,8,32), конструктор класса Date сгенерирует исключе-
ние, которое приведет к прекращению выполнения оператора opera tor >> ().
10.10. Стандартный цикл ввода
В разделе 10.5 мы видели, как считываются и записываются файлы. Однако
тогда мы еще не рассматривали обработку ошибок (см. раздел 10.6) и считали, что
файл считывается от начала до конца. Это разумное предположение, поскольку мы
часто отдельно проверяем корректность файла. Тем не менее мы часто хотим вы-
полнять проверку считанных данных в ходе их ввода. Рассмотрим общую страте-
гию предполагая что объект ist относится к классу is trват.10.10. СТАНДАРТНЫЙ ЦИКЛ ВВОДА
385
Mytype var;
while (ist>>var) { // читаем до конца файла
// тут можно было бы проверить, является ли переменная var
корректной
// тут мы что-нибудь делаем с переменной var
}
// выйти из состояния bad удается довольно редко;
// не делайте этого без крайней необходимости:
if (ist.badO) error ("плохой поток ввода");
if (ist.failO) {
// правильно ли выполнен ввод?
}
// продолжаем: обнаружен конец файла
Иначе говоря, мы считываем последовательность значений, записывая их пере-
менные, а когда не можем больше считать ни одного значения, проверяем состояние
потока, чтобы понять, что случилось. Как показано в разделе 10.6, эту стратегию
можно усовершенствовать, заставив поток istream генерировать исключение типа
failure в случае сбоя. Это позволит нам не постоянно выполнять проверку.
// где-то: пусть поток ist генерирует исключение при сбое
ist.exceptions(ist.exceptions() |ios_base:rbadbit) ;
Можно также назначить признаком завершения ввода (terminator) какой-нибудь
символ.
My_type var;
while (ist>>var) { // читаем до конца файла
// тут можно было бы проверить, является ли переменная var
// корректной
// тут мы что-нибудь делаем с переменной var
}
if (ist.failO) { // в качестве признака завершения ввода используем
// символ ■|■ и/или разделитель
ist.clear();
char ch;
if (l(ist>>ch && ch=='|'))
error("неправильное завершение ввода");
}
// продолжаем: обнаружен конец файла или признак завершения ввода
Если вы не хотите использовать в качестве признака завершения ввода какой-то
символ, т.е. хотите ограничиться только признаком конца файла, то удалите про-
верку перед вызовом функции error (). Однако признаки завершения чтения ока-
зываются очень полезными, когда считываются файлы с вложенными конструкция-
ми, например файлы с помесячной информацией, содержащей ежедневную инфор-
мацию, включающую почасовую информацию, и т.д. В таких ситуациях стоит
подумать о символе завершения ввода.
К сожалению, этот код остается довольно запутанным. В частности, слишком
утомительно при считывании многих файлов каждый раз повторять проверку сим-386 глава 10 • ПОТОКИ ВВОДА И ВЫВОДА
вола завершения ввода. Для решения этой проблемы следует написать отдельную
функцию.
// где-то: пусть поток ist генерирует исключение при сбое
ist.exceptions (ist .exceptions () | iosjbase: :badbit) ;
void end__of_loop(istream& ist, char term, const string& message)
{
if (ist. fail ()) { // используем символ завершения ввода
// и/или разделитель
ist.clearO ;
char ch;
if (ist>>ch && ch==term) return; // все хорошо
error(message);
}
}
Это позволяет нам сократить цикл ввода.
My_type var;
while (ist»var) { // читаем до конца файла
// тут можно было бы проверить, является ли переменная var
// корректной
// тут мы что-нибудь делаем с переменной var
}
end_of_loop(ist, ' | ', "неправильное завершение файла") ; // проверяем,
// можно ли
// продолжать
// продолжаем: обнаружен конец файла или признак завершения ввода
Функция endofloopO не выполняет никаких действий, кроме проверки,
находится ли поток в состоянии fail (). Мы считаем, что эту достаточно простую
и универсальную функцию можно использовать для разных целей.
10.11. Чтение структурированного файла
Попробуем применить этот стандартный цикл в конкретном примере. Как обыч-
но, используем этот пример для иллюстрации широко распространенных методов
проектирования и программирования. Предположим, в файле записаны результаты
измерения температуры, имеющие определенную структуру.
• В файле записаны годы, в течение которых производились измерения.
• Запись о годе начинается символами { year, за которыми следует целое
число, обозначающее год, например 1900, и заканчивается символом }.
• Год состоит из месяцев, в течение которых производились измерения.
• Запись о месяце начинается символами { month, за которыми следует трех-
буквенное название месяца, например jan, и заканчивается символом }.
• Данные содержат показания времени и температуры.
• Показания начинаются с символа (, за которыми следует день месяца, час дня
и температура, и заканчиваются символом ).10.11. ЧТЕНИЕ СТРУКТУРИРОВАННОГО ФАЙЛА
387
Рассмотрим пример.
{ year 1990 }
{year 1991 { month jun }}
{ year 1992 { month jan ( 1 0 61.5) } {month feb (1 1 64) (2 2
65.2) } }
{year 2 000
{ month feb (1 1 68 ) (2 3 66.66 ) ( 1 0 67.2)}
{month dec (15 15 -9.2 ) (15 14 -8.8) (14 0 -2) }
}
=h Этот формат довольно своеобразен. Форматы записи файлов часто оказываются
=1 довольно специфическими. В промышленности наблюдается тенденция к ши-
рокому использованию все более упорядоченных и иерархически структурированных
файлов (например, HTML и XML), но в действительности мы по-прежнему редко мо-
жем контролировать формат файла, который необходимо прочитать. Файлы таковы,
каковы они есть, и нам нужно их прочитать. Если формат слишком неудачен или фай-
лы содержат много ошибок, можем написать программу преобразования формата
в более подходящий. С другой стороны, мы, как правило, имеем возможность выби-
рать представление данных в памяти в удобном для себя виде, а при выборе формата
вывода часто руководствуемся лишь собственными потребностями и вкусом.
Предположим, данные о температуре записаны в указанном выше формате и нам
нужно их прочитать. К счастью, формат содержит автоматически идентифицируе-
мые компоненты, такие как годы и месяцы (немного напоминает форматы HTML
и XML). С другой стороны, формат отдельной записи довольно неудобен. Напри-
мер, в ней нет информации, которая могла бы нам помочь, если бы кто-то перепутал
день месяца с часом дня или представил температуру по шкале Цельсия, хотя нужно
было по шкале Фаренгейта, и наоборот. Все эти проблемы нужно как-то решать.
10.11.1. Представление в памяти
Как представить эти данные в памяти? На первый взгляд, необходимо создать
три класса, Year, Month и Reading, точно соответствующие входной информации.
Классы Year и Month очевидным образом могли бы оказаться полезными при об-
работке данных; мы хотим сравнивать температуры разных лет, вычислять средне-
месячные температуры, сравнивать разные месяцы одного года, одинаковые месяцы
разных лет, показания температуры с записями о солнечном излучении и влажности
и т.д. В принципе классы Year и Month точно отображают наши представления
о температуре и погоде: класс Month содержит ежемесячную информацию, а класс
Year— ежегодную. А как насчет класса Reading? Это понятие низкого уровня,
связанное с частью аппаратного обеспечения (сенсором). Данные в классе Reading
(день месяца, час дня и температура) являются случайными и имеют смысл только в
рамках класса Month. Кроме того, они не структурированы: никто не обещал, что
данные будут записаны по дням или по часам. В общем, для того чтобы сделать
с данными что-то полезное, сначала их необходимо упорядочить.388 ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
Для представления данных о температуре в памяти сделаем следующие предпо-
ложения.
• Если есть локазания для какого-то месяца, то их обычно бывает много.
• Если есть показания для какого-то дня, то их обычно бывает много.
В этом случае целесообразно представить класс Year как вектор, состоящий
из 12 объектов класса Month, класс Month — как вектор, состоящий из 30 объектов
класса Day, а класс Day — как 24 показания температуры (по одному в час). Это по»
зволяет просто и легко манипулировать данными при решении самых разных задач.
Итак, классы Day, Month и Year — это простые структуры данных, каждая из кото-
рых имеет конструктор. Поскольку мы планируем создавать объекты классов Month
и Day как часть объектов класса Year еще до того, как узнаем, какие показания тем*
пературы у нас есть, то должны сформулировать, что означает "пропущены данные"
для часа дня, до считывания которых еще не подошла очередь.
const int not_a_reading я -7777; // ниже абсолютного нуля
Аналогично, мы заметили, что часто в течение некоторых месяцев не произво-
дилось ни одного измерения, поэтому ввели понятие "пропущен месяц", вместо то-
го чтобы проверять пропуски для каждого дня.
const int not_a_month = -1;
Три основных класса принимают следующий вид:
struct Day {
vector<double> hour;
Day(); // инициализируем массив hour значениями "нет данных"
>»
Day: :Day()
: hour(24)
{
for (int i = 0; i<hour.size() ; ++i) hour[i]=not_a_reading;
}
struct Month { // месяц
int month; // [0:11] январю соответствует О
vector<Day> day; // [1:31] один вектор для всех данных по дням
MonthO // не больше 31 дня в месяце (day[0]
// не используется)
:month(not_a_month), day(32) { }
};
struct Year { // год состоит из месяцев
int year; // положительный == н.э.
vector<Month> month; // [0:11] январю соответствует 0
Year() :month(12) { } // 12 месяцев в году
};10.11. ЧТЕНИЕ СТРУКТУРИРОВАННОГО ФАЙЛА
389
В принципе каждый класс — это просто вектор, а классы Month и Year содер-
жат идентифицирующие члены month и year соответственно.
0 В этом примере существует несколько "волшебных констант" (например, 24,
32 и 12). Как правило, мы пытаемся избегать таких литеральных констант
в коде. Эти константы носят фундаментальный характер (количество месяцев в году
изменяется редко) и в остальной части кода не используются. Однако мы оставили
их в коде в основном для того, чтобы напомнить вам о проблеме "волшебных чи-
сел", хотя намного предпочтительнее использовать символьные константы (см. раз-
дел 7.6.1). Использование числа 32 для обозначения количества дней в месяце оп-
ределенно требует объяснений; в таком случае число 32 действительно становится
"волшебным".
10.11.2. Считывание структурированных значений
Класс Reading будет использован только для ввода данных, к тому же он намно-
го проще остальных
struct Reading {
int day;
int hour;
double temperature;
};
istream& operator»(istreamb is, Reading^ r)
// считываем показания температуры из потока is в объект г
// формат: ( 3 4 9.7 )
// проверяем формат, но не корректность данных
{
char chl;
if (is>>chl && chl! = ' ('){// можно это превратить в объект типа
// Reading?
is.unget();
is.clear(ios_base::failbit);
return is;
char ch2;
int d;
int h;
double t;
is >> d >> h >> t >> ch2;
if (lis || ch2!=■)') error("плохая запись"); // перепутанные
// показания
г. day = d;
г.hour = h;
r.temperature = t;
return is;390
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
В принципе мы проверяем, правильно ли начинается формат. Если нет, то пере-
водим файл в состояние fail О и выходим. Это позволяет нам попытаться считать
информацию как-то иначе. С другой стороны, если ошибка формата обнаруживает^
ся после считывания данных и нет реальных шансов на возобновление работы,
то вызываем функцию error ().
Операции ввода в классе Month почти такие же, за исключением того, что в нем
вводится произвольное количество объектов класса Reading, а не фиксированный
набор значений (как делает оператор » в классе Reading).
istreams operator>> (istream& is, Monthfc m)
// считываем объект класса Month из потока is в объект га
// формат: { month feb . . . }
{
char ch « 0;
if (is » ch && chl='{') {
is.unget();
is.clear(ios_base::failbit); // ошибка при вводе Month
return is;
}
string monthmarker;
string mm;
is >> monthmarker >> mm;
if (lis || monthmarker !="month") error ("неверное начало Month");
m. month * monthtoint (mm) ;
Reading r;
int duplicates « 0;
int invalids =0;
while (is >> r) {
if (isvalid(r)) {
if (m.day [r.day] .hour [r.hour] != not_a_reading)
++duplicates;
m.day [r. day] .hour [r. hour] * r. temperature;
}
else
++invalids;
}
if (invalids) error("неверные показания в Month", invalids);
if (duplicates) error("повторяющиеся показания в Month",
duplicates);
endofloop (is, ' } ' # "неправильный конец Month") ;
return is;
}
Позднее мы еще вернемся к функции monthtointO; она преобразовывает
символические обозначения месяцев, такие как jun, в число из диапазона [0:11).
Обратите внимание на использование функции endofloopO из раздела 10.10
для проверки признака завершения ввода. Мы подсчитываем количество непра-<10.11. ЧТЕНИЕ СТРУКТУРИРОВАННОГО ФАЙЛА
**1
пильных и повторяющихся объектов класса Readings (эта информация может к<$-
му-нибудь понадобиться).
Оператор » в классе Month выполняет грубую проверку корректности объекта
класса Reading, прежде чем записать его в память.
const int implausiblemin « -200;
const int ixnplausible_max e 200;
bool isvalid(const Readings r)
// грубая проверка
{
if (r.day<l || 31<r.day) return false;
if (r.hour<0 || 23<r.hour) return false;
if (r.temperature<implausible_min||
implausible_max<r.temperature)
return false;
return true;
}
В заключение можем прочитать объекты класса Year. Оператор » в классе
Year аналогичен оператору >> в классе Month.
istreamfc operator>>(istreamfc is, Year& y)
// считывает объект класса Year из потока is в объект у
// формат: { year 1972 . . . }
{
char ch;
is >> ch;
if (ch!='{') {
is.unget();
is.clear(ios::failbit) ;
return is;
}
string year_marker;
int yy;
is >> yearmarker >> yy;
if (lis || уеаг_тагкег1=пуеаги)
error("неправильное начало Year");
у.year = yy;
while(true) {
Month m; // каждый раз создаем новый объект m
if (!(is >> m)) break;
y.month[m.month] = m;
}
end_of_loop(is,■}■,"неправильный конец Year");
return is;
}
Можно было бы сказать, что этот оператор "удручающе аналогичен", а не просто
аналогичен, но здесь кроется важный нюанс. Посмотрите на цикл чтения. Ожидали
ли вы чего-нибудь подобного следующему фрагменту?392
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
Month m;
while (is » m)
y.month[m.month] = m;
Возможно, да, поскольку именно так мы до сих пор записывали все циклы ввода.
Именно этот фрагмент мы написали первым, и он является неправильным. Проблема
заключается в том, что функция operator>>(istream& is, Months m) не при-
сваивает объекту m совершенно новое значение; она просто добавляет в него данные
из объектов класса Reading. Таким образом, повторяющаяся инструкция is>>m до-
бавляла бы данные в один и тот же объект т. К сожалению, в этом случае каждый но-
вый объект класса Month содержал бы все показания всех предшествующих месяцев
текущего года. Для того чтобы считывать данные с помощью инструкции is»m, нам
нужен совершенно новый объект класса Month. Проще всего поместить определение
объекта m в цикл так, чтобы он инициализировался на каждой итерации.
В качестве альтернативы можно было бы сделать так, чтобы функция
operator>>(istream& is, Month& m) перед считыванием в цикле присваивала
бы объекту m пустой объект.
Month m;
while (is >> m) {
y.month[m.month] = m;
m = Month(); // "повторная инициализация" объекта m
}
Попробуем применить это.
// открываем файл для ввода:
cout << "Пожалуйста, введите имя файла для ввода\п";
string name;
cin >> name;
ifstream ifs(name.cstr ());
if (!ifs) error ("невозможно открыть файл для ввода",name) ;
ifs.exceptions (if s. exceptions () | iosbase: rbadbit); // генерируем bad()
// открываем файл для вывода:
cout << "Пожалуйста, введите имя файла для ввода\п";
cin >> name;
ofstream ofs(name.cstr());
if (!ofs) error ("невозможно открыть файл для ввода", name) ;
// считываем произвольное количество объектов класса Year:
vector<Year> ys;
while(true) {
Year у; // объект класса Year каждый раз очищается
if (!(ifs>>y)) break;
ys.pushback(y);
}
cout << "считано " << ys.size() << " записей по годам\пя;
for (int i = 0; i<ys.size(); ++i) print_year(ofs,ys [il) ;
Функцию printyear () мы оставляем в качестве упражнения.10.11. ЧТЕНИЕ СТРУКТУРИРОВАННОГО ФАЙЛА
393
10.11.3. Изменение представления
Для того чтобы оператор >> класса Month работал, необходимо предусмотреть
способ для ввода символьных представлений месяца. Для симметрии мы описываем
способ сравнения с помощью символьного представления. Было бы слишком уто-
мительно писать инструкции if, подобные следующей:
if (s=="jann)
m = 1;
else if (s=="febn)
m = 2;
• • •
Это не просто утомительно; таким образом мы встраиваем названия месяцев
в код. Было бы лучше занести их в таблицу, чтобы основная программа оставалась
неизменной, даже если мы изменим символьное представление месяцев. Мы реши-
ли представить входную информацию в виде класса vector<string>, добавив
к нему функцию инициализации и просмотра.
vector<string> month_input_tbl; // month_input_tbl [0] ==" jan"
void init^inputtbl(vector<string>& tbl)
// инициализирует вектор входных представлений
{
tbl.push_back
tbl.push_back
tbl.pushback
tbl.push_back
tbl.push_back
tbl.pushback
tbl.pushback
tbl.push_back
tbl.pushback
tbl.pushback
tbl.push_back
tbl.push_back
}
int month to_int(string s)
// Является ли строка s названием месяца? Если да, то возвращаем ее
// индекс из диапазона [0:11], в противном случае возвращаем -1
{
for (int i=0; i<12; ++i) if (month_input_tbl[i]==s) return i;
return -1;
}
На всякий случай заметим, что стандартная библиотека С-н- предусматривает бо-
лее простой способ решения этой задачи. См. тип map<string, int> в разделе 21.6.1.
Если мы хотим вывести данные, то должны решить обратную задачу. У нас есть
представление месяца с помощью чисел int, и мы хотели бы представить их в сим-
вольном виде. Наше решение очень простое, но вместо использования таблицы пе-
"jan"
"feb"
"mar"
"аргп
"may"
"jun"
"jul"
"aug"
"sep"
"oct"
"nov"
"dec"394
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
рехода от типа string к типу int мы теперь используем таблицу перехода от типа
int к типу string.
vector<string> month_print_tbl; // month_print_tbl [0] ==" January"
void init_print_tbl (vector<string>& tbl)
// инициализируем вектор представления для вывода
{
tbl.pushback("January");
tbl.push_back("February");
tbl.push_back("March");
tbl.pushback("April");
tbl.push_back("May");
tbl.pushback("June");
tbl.pushback("July");
tbl.pushback("August");
tbl.pushback("September");
tbl.push_back("October");
tbl.push_back("November");
tbl.push_back("December");
}
string int_to_month(int i)
// месяцы [0:11]
{
if (i<0 || 12<=i) error ("неправильный индекс месяца") ;
return month_print_tbl [i];
}
Для того чтобы этот подход работал, необходимо где-то вызвать функции ини-
циализации, такие как указаны в начале функции main ().
// первая инициализация таблиц представлений:
init_print_tbl(month_print_tbl);
init_input_tbl (month_input_tbl) ;
Итак, действительно ли вы прочитали все фрагменты кода и пояснения к ним?
Или ваши глаза устали, и вы перешли сразу в конец главы? Помните, что са-
мый простой способ научиться писать хорошие программы — читать много чужих
программ. Хотите — верьте, хотите — нет, но методы, использованные в описан-
ном примере, просты, хотя и не тривиальны, и требуют объяснений. Ввод дан-
ных — фундаментальная задача. Правильная разработка циклов ввода (с коррект-
ной инициализацией каждой использованной переменной) также очень важна.
Не меньшее значение имеет задача преобразования одного представления в другое.
Иначе говоря, вы должны знать такие методы. Остается лишь выяснить, насколько
хорошо вы усвоили эти методы и не упустили ли из виду важные факты.
0ЗАДАНИЕ
395
Задание
1. Разработайте программу, работающую с точками (см. раздел 10.4). Начните
с определения типа данных Point, имеющего два члена — координаты х и у.
2. Используя код и обсуждение из раздела 10.4, предложите пользователю ввести
семь пар (ху). После ввода данных запишите их в вектор объектов класса Point
С именем originalpoints.
3. Выведите на печать данные из объекта original_points, чтобы увидеть, как
они выглядят.
4. Откройте поток of stream и выведите все точки в файл my-data.txt. В системе
Windows для облегчения просмотра данных с помощью простого текстового ре-
дактора (например, WordPad) лучше использовать суффикс файла . txt.
5. Закройте поток of stream, а затем откройте поток if stream для файла шу-
data. txt. Введите данные из файла my data, txt и запишите их в новый вектор
с именем processedpoints.
6. Выведите на печать данные из обоих векторов.
7. Сравните эти два вектора и выведите на печать сообщение Что-то не так!,
если количество элементов или значений элементов в векторах не совпадает.
Контрольные вопросы
1. Насколько разнообразными являются средства ввода и вывода у современных
компьютеров?
2. Что делает поток istream?
3. Что делает поток ostream?
4. Что такое файл?
5. Что такое формат файла?
6. Назовите четыре разных типа устройств для ввода и вывода данных из про-
грамм.
7. Перечислите четыре этапа чтения файла.
8. Перечислите четыре этапа записи файлов.
9. Назовите и определите четыре состояния потоков.
10. Обсудите возможные способы решения следующих задач ввода.
10.1. Пользователь набрал значение, выходящее за пределы допустимого
диапазона.
10.2. Данные исчерпаны (конец файла).
10.3. Пользователь набрал значение неправильного типа.
11. В чем ввод сложнее вывода?
12. В чем вывод сложнее ввода?396
ГЛАВА 10 • ПОТОКИ ВВОДА И ВЫВОДА
13. Почему мы (часто) хотим отделить ввод и вывод от вычислений?
14. Назовите две ситуации, в которых чаще всего используется функция clear ()
класса i stream.
15.Как определить операторы « и » для пользовательского типа X?
Термины
bad ()
buffer
clear()
close()
eof()
fail ()
good ()
ifstream
iostream
istream
ofstream
open()
ostream
unget()
драйвер устройства
оператор ввода
оператор вывода
признак завершения ввода
состояние потока
структурированный файл
устройство ввода
устройство вывода
файл
Упражнения
1. Напишите программу, вычисляющую сумму всех целых чисел, записанных
в файле и разделенных пробелами.
2. Напишите программу, создающую файл из данных, записанных в виде объектов
класса Reading, определенного в разделе 10.5. Заполните файл как минимум
50показаниями температуры. Назовите эту программу store_temps.cpp,
а файл —raw_temps.txt.
3. Напишите программу, считывающую данные из файла raw_temps.txt, соз-
данного в упр. 2, в вектор, а затем вычислите среднее и медиану температур.
Назовите программу temp_stats. срр.
4. Модифицируйте программу store_temps. срр из упр. 2, включив в нее суф-
фикс с для шкалы Цельсия и суффикс f для шкалы Фаренгейта. Затем модифи-
цируйте программу temp_stats.срр, чтобы перед записью в вектор проверить
каждое показание, преобразовать показание из шкалы Цельсия в шкалу Фарен-
гейта.
5. Напишите функцию print_year (), упомянутую в разделе ЮЛ 1.2.
6. Определите класс Roman_int для хранения римских цифр (как чисел типа int)
с операторами << и >>. Включите в класс Roman_int функцию as_int(), воз-
вращающую значение типа int, так, чтобы, если объект г имеет тип Romanint,
мы могли написать cout << "Roman" << г << " равен " « r,as_int()
« ■ \п';.
7. Разработайте вариант калькулятора из главы 7, который работал бы не с араб-
скими, а с римскими цифрами, например XXI + Civ =» CXXV.ПОСЛЕСЛОВИЕ
397
8. Напишите программу, принимающую на вход имена двух файлов и создающую
новый файл, содержащий первый файл, за которым следует второй; иначе гово-
ря, программа должна конкатенировать два файла.
9. Напишите программу, принимающую на вход два файла, содержащие упоря-
доченные слова, разделенные пробелами, и объедините их, сохранив порядок.
10. Добавьте в калькулятор из главы 7 команду from x, осуществляющую ввод
данных из файла х. Добавьте в калькулятор команду to у, выполняющую вы-
вод (как обычных данных, так и сообщений об ошибках) в файл у. Напишите
набор тестов, основанных на идеях из раздела 7.3, и примените его для проверки
калькулятора. Объясните, как вы используете эти команды для тестирования.
11. Напишите программу, вычисляющую сумму целых чисел, хранящихся в тексто-
вом файле и разделенных пробелами и словами. Например, после ввода строки
"bears: 17 elephants 9 end" результат должен быть равен 26.
12. Напишите программу, принимающую на вход имя файла и выводящую слова по
одному на каждой строке, предваряя их номером строки. Подсказка: используй-
те функцию getline().
Послесловие
Большинство вычислений связано с переносом больших объемов данных из од-
ного места в другое, например копирование текста из файла на экран или пересылка
музыки из компьютера на МРЗ-плеер. Часто по ходу дела приходится производить
определенные преобразования данных. Библиотека ввода-вывода позволяет решить
многие из задач, в которых данные можно интерпретировать как последователь-
ность (поток) значений. Ввод и вывод могут оказаться удивительно крупной частью
программирования. Частично это объясняется тем, что мы (или наши программы)
нуждаемся в больших объемах данных, а частично — тем, что точка, в которой дан-
ные поступают в систему, очень уязвима для ошибок. Итак, мы должны сделать
ввод и вывод как можно более простыми и минимизировать возможность просачи-
вания в нашу систему некорректных данных.Настройка ввода и вывода
"Все должно быть как можно более простым,
но не проще".
Альберт Эйнштейн (Albert Einstein)
В этой главе мы обсудим, как адаптировать потоки ввода-вывода, опи-
санные в главе 10, к конкретным потребностям и вкусам. Это связано
со множеством деталей, которые обусловлены тем, как люди читают тексты,
а также с ограничениями на использование файлов. Заключительный пример
иллюстрирует проект потока ввода, в котором можно задавать собственный
набор операторов.400 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
В этой главе.»
11.1. Регулярность и нерегулярность 11.4. Потоки строк
11.2. Форматирование вывода 11.5. Ввод, ориентированный на строки
11.2.1. Вывод целых чисел 11>6. Классификация символов
11.2.2. Ввод целых чисел .. , ,.
11.2.3. Вывод чисел с плавающей точкой 117" Использование нестандартных раз-
11.2.4. Точность делителей
11.2.5. Поля 11.8. И еще много чего
11.3. Открытие файла и позиционирование
11.3.1. Режимы открытия файлов
11.3.2. Бинарные файлы
11.3.3. Позиционирование в файлах
11.1. Регулярность и нерегулярность
Библиотека ввода-вывода является частью стандартной библиотеки языка C++.
Она обеспечивает единообразную и расширяемую базу для ввода и вывода текста.
Под словом "текст" мы подразумеваем нечто, что можно представить в виде после-
довательности символов. Таким образом, когда мы говорим о вводе и выводе,
то целое число 1234 рассматривается как текст, поскольку его можно записать
с помощью четырех символов: 1, 2, 3 и 4.
До сих пор мы не делали различий между источниками входной информации.
Однако иногда этого оказывается недостаточно. Например, файлы отличаются
от других источников данных (например, линий связи), поскольку они допускают
адресацию отдельных байтов. Кроме того, мы работали, основываясь на предполо-
жении, что тип объекта полностью определен схемой его ввода и вывода. Это не со-
всем правильно и совсем недостаточно. Например, при выводе мы часто хотим ука-
зывать количество цифр, используемых для представления числа с плавающей точ-
кой (его точность). В данной главе описано много способов, с помощью которых
можно настроить ввод и вывод для своих потребностей.
Будучи программистами, мы предпочитаем регулярность. Единообразная
обработка всех объектов, находящихся в памяти, одинаковый подход ко всем
источникам входной информации и стандартное унифицированное представление
объектов при входе в систему и выходе из нее позволяют создавать самый ясный,
простой, понятный и часто самый эффективный код. Однако наши программы
должны служить людям, а люди имеют стойкие предпочтения. Таким образом, как
программисты мы должны поддерживать баланс между сложностью программы
и настройкой на персональные вкусы пользователей.11.2. ФОРМАТИРОВАНИЕ ВЫВОДА
401
11.2. Форматирование вывода
Люди уделяют много внимания мелким деталям, связанным с представлением
выходной информации, которую им необходимо прочитать. Например, для
физика число 1.25 (округленное до двух цифр после точки) может сильно отличать-
ся от числа 1.24670477, а для бухгалтера запись (1.25) может сильно отличаться
от записи ( 1.2467) и совершенно не совпадать с числом 1.25 (в финансовых
документах скобки иногда означают убытки, т.е. отрицательные величины). Как
программисты мы стремимся сделать наш вывод как можно более ясным и как
можно более близким к ожиданиям потребителей нашей программы. Потоки выво-
да (ostream) предоставляют массу возможностей для форматирования вывода дан-
ных, имеющих встроенные типы. Для типов, определенных пользователем, про-
граммист сам должен определить подходящие операции «.
Количество деталей, уточнений и возможностей при выводе кажется неограни-
ченным, а при вводе, наоборот, есть лишь несколько вариантов. Например, для обо-
значения десятичной точки можно использовать разные символы (как правило, точ-
ку или запятую), денежные суммы в разных валютах также выводятся по-разному,
а истинное логическое значение можно выражать как словом true (или vrai or
sandt), так и числом 1, если в вашем распоряжении находятся только символы,
не входящие в набор ASCII (например, символы в системе Unicode). Кроме того,
существуют разные способы ограничения символов, записываемых в строку.
Эти возможности не интересны, пока они вам не нужны, поэтому мы отсылаем чи-
тателей к справочникам и специализированным книгам, таким как Langer Standard
C++ IOStrearns and Locales; главе 21 и приложению D в книге The C+ + Program-
ming Language Страуструпа; а также к §22 и 27 стандарта ISO C++. В настоящей
книге мы рассмотрим лишь самые распространенные варианты вывода и некоторые
общие понятия.
11.2.1. Вывод целых чисел
Целые числа можно вывести как восьмеричные (в системе счисления с основа-
нием 8), десятичные (в обычной системе счисления с основанием 10) и шестнадца-
теричные (в системе счисления с основанием 16). Если вы ничего не знаете об этих
системах, сначала прочитайте раздел А. 1.2.1. В большинстве случаев при выводе
используется десятичная система. Шестнадцатеричная система широко распростра-
нена при выводе информации, связанной с аппаратным обеспечением.
Причина популярности шестнадцатеричной системы кроется в том, что шестна-
дцатеричные цифры позволяют точно представить четырехбитовые значения.
Таким образом, две шестнадцатеричные цифры можно использовать для представ-
ления восьмибитового байта, четыре шестнадцатеричные цифры представляют два
байта (которые часто являются полусловом), восемь шестнадцатеричных цифр мо-
гут представить четыре байта (что часто соответствует размеру слова или регистра).
0402 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
Когда был разработан язык С— предшественник языка C++(в 1970-х годах),
не менее популярной была восьмеричная система, но сейчас она используется редко.
Мы можем указать, что (десятичное число) 1234 при выводе должно трактовать-
ся как десятичное, шестнадцатеричное или восьмеричное.
cout « 1234 « "\t (decimal) \n"
« hex « 1234 << "\t (hexadecimal)\n"
« oct « 1234 « "\t(octal)\n";
Символ '\t' означает "символ табуляции". Он обеспечивает следующее пред-
ставление выходной информации:
1234 (decimal)
4d2 (hexadecimal)
2322 (octal)
Обозначения « hex и << oct не являются значениями, предназначенными для
вывода. Выражение « hex сообщает потоку, что любое целое число в дальнейшем
должно быть представлено как шестнадцатеричное, а выражение << oct означает,
что любое целое число в дальнейшем должно быть представлено как восьмеричное.
Рассмотрим пример.
cout « 1234 << '\t' << hex << 1234 << '\t' « oct « 1234 << '\n';
cout << 1234 << '\n'; // восьмеричная основа продолжает действовать
В итоге получаем следующий вывод:
1234 4d2 2322
2322 // целые числа продолжают трактоваться как восьмеричные
Обратите внимание на то, что последнее число выведено как восьмеричное; ина-
че говоря, термины oct, hex и dec (для десятичных чисел) являются персистент-
ными (инертными) — они применяются к каждому целому числу, пока мы не дадим
потоку другое указание. Термины hex и oct используются для изменения поведе-
ния потока и называются манипуляторами (manipulators).
Э ПОПРОБУЙТЕ
Выведите ваш день рождения в десятичном, восьмеричном и шестнадцатеричном
форматах. Обозначьте каждое из этих значений. Выровняйте ваш вывод по столб-
цам, используя символ табуляции, и выведите свой возраст.
Представление чисел в системе счисления, отличной от десятичной, может вве-
сти читателя в заблуждение. Например, если заранее не знать, в какой системе
представлено число, то строка 11 может означать десятичное число 11, а не восьме-
ричное число 9 (т.е. 11 в восьмеричной системе) или шестнадцатеричное число 17
(т.е 11 в шестнадцатеричной системе). Для того чтобы избежать таких проблем,
можно попросить поток показать базу, в которой представлено целое число.
Рассмотрим пример11.2. ФОРМАТИРОВАНИЕ ВЫВОДА
403
cout « 1234 << '\t' « hex « 1234 « «Xt1 « oct « 1234 « "Vl
cout << showbaee << dec; // показывать базы
cout << 1234 << '\t' « hex « 1234 « '\t' « oct « 1234 « '\n'?
В результате получим следующий вывод:
1234 4d2 2322
1234 0x4d2 02322
Итак, десятичные числа не имеют префиксов, восьмеричные числа имеют пре-
фикс о, а шестнадцатеричные числа имеют префикс Ох (или ох). Именно так обо-
значаются целочисленные литералы в языке C++. Рассмотрим пример.
cout << 1234 << '\t' « 0x4d2 « '\t' « 02322 « '\n';
В десятичном виде эти числа выглядели бы так:
1234 1234 1234
Как вы могли заметить, манипулятор showbaee является персистентным, как
и манипуляторы oct и hex. Манипулятор noshowbase отменяет действие манипу-
лятора showbaee, возвращая поток в состояние по умолчанию, в котором любое
число выводится без указания его базы счисления.
Итак, существует несколько манипуляторов вывода.
Манипуляторы для вывода целых чисел
oct Использовать восьмеричную систему счисления
dec Использовать десятичную систему счисления
hex Использовать шестнадцатеричную систему счисления
showbase Префикс 0 для восьмеричных и Ох для шестнадцатеричных
noshowbase He использовать префиксы
11.2.2. Ввод целых чисел
По умолчанию оператор >> предполагает, что числа используются в десятичной
системе счисления, но его можно заставить вводить целые числа как шестнадцате-
ричные или восьмеричные.
int a;
int b;
int с;
int dj
cin >> a >> hex >> b >> oct >> с >> d;
cout << a << '\t' << b << '\t' << с << '\t' << d << '\n';
Если набрать на клавиатуре числа
1234 4d2 2322 2322
то программа выведет их так:
1234 1234 1234 1234404
ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
Обратите внимание на то, что при вводе манипуляторы oct, dec и hex являются
персистентными, как и при выводе.
* ПОПРОБУЙТЕ
Завершите фрагмент кода, приведенный выше, и преобразуйте его в программу.
Попробуйте ввести предлагаемые числа; затем введите числа
1234 1234 1234 1234
Объясните результат. Попробуйте ввести другие числа, чтобы увидеть, что произойдет.
Для того чтобы принять и правильно интерпретировать префиксы 0 и Ох, можно
использовать оператор ». Для этого необходимо отменить установки, принятые
по умолчанию. Рассмотрим пример.
cin.unsetf (ios: :dec); // не считать десятичным
// (т.е. Ох может означать
// шестнадцатеричное число)
cin.unsetf (ios: :oct) ; // не считать восьмеричным
// (т.е. 12 может означать двенадцать)
cin.unsetf (ios::hex) ; // не считать шестнадцатеричным
// (т.е. 12 может означать двенадцать)
Функция-член потока unsetf О сбрасывает флаг (или флаги), указанный как
аргумент. Итак, если вы напишете
cin >>а >> b >> с >> d;
и введете
1234 0x4d2 02322 02322
то получите
1234 1234 1234 1234
11.2.3. Вывод чисел с плавающей точкой
Если вы непосредственно работаете с аппаратным обеспечением, то вам нужны
шестнадцатеричные числа (и, возможно, восьмеричные). Аналогично, если вы про-
водите научные вычисления, то должны форматировать числа с плавающей точкой.
Они обрабатываются манипуляторами потока iostream почти так, как и десятич-
ные числа. Рассмотрим пример.
cout « 1234.56789 « "\t\t (общий) \nn // \t\t - выравнивание столбцов
<< fixed << 1234.56789 << "\t(фиксированный)\n"
<< scientific << 1234.56789 << "\t(научный)\n";
В итоге получим следующие строки:
1234.57 (общий)
1234.567890 (фиксированный)
1 234568е+003 (научный)11.2. ФОРМАТИРОВАНИЕ ВЫВОДА
40S
Манипуляторы fixed и ecientific используются для выбора форматов для
представления чисел с плавающей точкой. Интересно, что в стандартной библиоте-
ке нет манипулятора general, который устанавливал бы формат, принятый
по умолчанию. Однако мы можем определить его сами, как это сделано в заголо-
вочном файле std_lib_facilitiea.h. Для этого не требуются знания о внутрен-
нем устройстве библиотеки ввода-вывода.
inline iosbasefc general (iosjbasefc b) // фиксированный и научный
// формат
// сбрасывает все флаги формата с плавающей точкой
{
b.setf (iosjbase: :fmtflags(0) , iosbase: :floatfield) ;
return b;
}
Теперь можем написать следующий код:
cout « 1234.56789 << '\t'
<< fixed << 1234.56789 « '\t'
<< scientific << 1234.56789 « '\n';
cout << 1234.56789 << '\n'; // действует формат
// с плавающей точкой
cout << general << 1234.56789 << ■ \t' // предупреждение:
<< fixed << 1234.56789 << '\t' // general — нестандартный
// манипулятор
<< scientific << 1234.56789 << '\n';
В итоге получим следующие числа:
1234.57 1234.567890 1.234568е+003
1.234568е+003 // манипулятор научного формата является
// персистентным
1234.57 1234.567890 1.234568е+003
Итак, существует несколько манипуляторов для работы с числами с плавающей
точкой.
Формат чисел с плавающей точкой
fixed Использовать представление с фиксированной точкой
scientific Использовать мантиссу и показатель степени; мантисса всегда лежит
в диапазоне [1:10), т.е. перед десятичной точкой всегда стоит ненулевая де-
сятичная цифра
general Выбирает манипулятор fixed или scientific для наиболее точного
представления чисел в рамках точности самого манипулятора general.
Формат general принят по умолчанию, но для его явного определения
general О
11.2.4. Точность
По умолчанию число с плавающей точкой выводится на печать с помощью шес-
ти цифр в формате general. Формат, состоящий из шести цифр (точность формата406 ГЛАВА 1 i • НАСТРОЙКА ВВОДА И ВЫВОДА
general по умолчанию), считается наиболее подходящим, а такое округление
числа — наилучшим. Рассмотрим пример.
1234.567 выводится на печать как 1234.57
1.2345678 выводится на печать как 1.23457
Округление, как правило, выполняется по правилу 4/5: от 0 до 4 — округление
вниз, а от 5 до 9 — вверх. Обратите внимание на то, что такое форматирование от-
носится только к числам с плавающей точкой.
1234567 выводится на печать как 1234567 (поскольку число целое)
1234567.0 выводится на печать как 1.23457е+006
В последнем случае поток ostream распознает, что число 1234567.0 нельзя вы-
вести на печать в формате fixed, используя только шесть цифр, и переключается
на формат scientific, чтобы обеспечить как можно более точное представление
числа. В принципе формат general может автоматически заменяться форматами
scientific и fixed, чтобы обеспечить максимально точное представление числа
с плавающей точкой в рамках общего формата, предусматривающего использова-
ние шести цифр.
Э ПОПРОБУЙТЕ
Напишите программу, три раза выводящую на печать число 1234567.89, сначала
в формате general, затем — в fixed, потом — в scientific. Какая форма вывода
обеспечивает наиболее точное представление числа и почему?
Программист может установить точность представления числа, используя мани-
пулятор setprecision(). Рассмотрим пример.
cout « 1234.56789 « '\t'
« fixed « 1234.56789 « '\t'
« scientific « 1234.56789 « ' \n';
cout << general << setprecision(5)
« 1234.56789 « '\t'
« fixed « 1234.56789 « '\t'
« scientific « 1234.56789 « '\n';
cout << general << setprecision(8)
<< 1234.56789 « '\tf
« fixed « 1234.56789 « '\t'
« scientific « 1234.56789 « ■ \n';
Этот код выводит на печать следующие числа (обратите внимание на округление):
1234.57 1234.567890 1.234568е+003
1234.6 1234.56789 1.23457е+003
1234.5679 1234.56789000 1.23456789е+003
Точность определятся по правилам, приведенным ниже.11.2. ФОРМАТИРОВАНИЕ ВЫВОДА
401
Точность чисел с плавающей точкой
general Точность определяется общим количеством цифр
scient i f i с Точность определяется количеством цифр после десятичной точки
f ixed Точность определяется количеством цифр после десятичной точки
1 ill i I ji i и i
Мы рекомендуем использовать формат, принятый по умолчанию (формат gen-
eral с точностью, равной шести цифрам), если у вас нет весомых причин для при-
менения другого формата. Обычно причина, по которой выбираются другие форма-
ты, такова: "Мы хотим получить большую точность при выводе".
11.2.5. Поля
С помощью научного и фиксированного формата программист может точно кон-
тролировать, сколько места займет число на выходе. Это очень полезно при распе-
чатке таблиц и т.п. Эквивалентный механизм для целых чисел называют полями
(fields). Вы можете точно указать ширину поля, используя манипулятор setw().
Рассмотрим пример.
cout << 12 3456 // поля не используются
«■|'« setw(4) << 123456 « '|' // число 123456
//не помещается в поле
<< setw(8) << 123456 << ■ | ■ // из 4 символов,
// расширим до 8
<< 123456 << "|\пи; // размеры полей не инертны
В итоге получим следующий результат:
1234561123456I 123456I123456I
Обратите внимание на два пробела перед третьим появлением числа 123456.
Это является результатом того, что мы выводим шесть цифр в поле, состоящее
из восьми символов. Однако число 123456 невозможно усечь так, чтобы оно помеща-
лось в поле, состоящее из четырех символов. Почему? Конечно, числа 112341 или
134561 можно интерпретировать как вполне допустимые для поля, состоящего из че-
тырех символов. Однако в этом случае на печать будут выведены числа, которые со-
вершенно не соответствуют ожиданиям программиста, причем он не получит об этом
никакого предупреждения. Поток oatrearn не сделает этого; вместо этого он аннули-
рует неправильный формат вывода. Плохое форматирование почти всегда лучше, чем
"плохие результаты". В большинстве случаев (например, при выводе таблиц)
переполнение полей сразу бросается в глаза и может быть исправлено.
Поля также можно использовать при выводе строк и чисел с плавающей точкой.
Рассмотрим пример.
cout « 12345 <<'|'« setw(4) << 12345 « '|'
<< aetw(8) << 12345 << '|' « 12345 « "|\пи;
cout << 1234.5 <<'|'<< aetw(4) « 1234.5 « ■ ■408 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
« eetw(8) « 1234.5 « «I1 « 1234.S « "|\п*;
cout « "asdfg" «,J'« eetw(4) « "aedfg" << • | •
« setw(8) « "asdfg" « • (• « "asdfg" « "j\n";
Этот код выводит на печать следующие числа:
12345|12345| 12345|12345|
1234.5|1234.5| 1234.5|1234.5|
asdfg|asdfg| asdfg|asdfg|
Обратите внимание на то, что ширина поля не является инертным параметром.
Во всех трех случаях первое и последнее числа по умолчанию выведены с макси-
мальным количеством цифр, которые допускает текущий формат. Иначе говоря, ес-
ли мы непосредственно перед выводом не укажем ширину поля, то понятие поля
вообще не будет использовано.
* ПОПРОБУЙТЕ
Создайте простую таблицу, содержащую фамилию, имя, номер телефона и адрес
электронной почты не менее пяти ваших друзей. Поэкспериментируйте с разной
шириной поля, пока не найдете приемлемый вид таблицы.
11.3. Открытие файла и позиционирование
В языке C++ файл— это абстракция возможностей операционной системы.
Как указано в разделе 10.3, файл — это последовательность байтов, пронумерован-
ных начиная с нуля.
0: 1: 2:
Вопрос заключается лишь в том, как получить доступ к этим байтам. При работе
с потоками iostream вид доступа определяется в тот момент, когда мы открываем
файл и связываем с ним поток. Поток сам определяет, какие операции можно вы-
полнить после открытия файла и каков их смысл. Например, когда мы открываем
для файла поток istream, то можем прочитать его содержимое, а когда открываем
для файла поток ostream, то можем записать в него данные.
11.3.1. Режимы открытия файлов
Файл можно открыть в одном из нескольких режимов. По умолчанию поток
if stream открывает файлы для чтения, а поток of stream - для записи. Эти опера-
ции удовлетворяют большинство наших потребностей. Однако существует несколь-
ко альтернатив.11.3. ОТКРЫТИЕ ФАЙЛА И ПОЗИЦИОНИРОВАНИЕ
409
Режимы открытия файлов
lOS
ios_
ios_
ios
ios_
ios
_base:
_base:
_base:
_base:
_base:
base :
:app
: ate
:binary
: in
: out
:trunc
Добавить (т.е. приписать в конце файла)
В конец (открыть и перейти в конец файла)
Бинарный режим — зависит от специфики системы
Для чтения
Для записи
Обрезать файл до нулевой длины
Режим открытия файла можно указать после его имени. Рассмотрим пример.
ofstream ofl (namel) ; // по умолчанию ios_base: :out
ifstream ifl(name2); // по умолчанию ios_base::in
ofstream ofs(name, ios_base::app); // по умолчанию ofstream —
// для записи
fstream fs ("myfile" , ios_base: tin| iosjbase: rout) ; // для ввода и вывода
Символ | в последнем примере— это побитовый оператор ИЛИ (раздел А.5.5),
который можно использовать для объединения режимов. Опция арр часто используется
для записи регистрационных файлов, в которых записи всегда добавляются в конец.
В любом случае конкретный режим открытия файла может зависеть от операци-
онной системы. Если операционная система не может открыть файл в требуемом
режиме, то поток перейдет в неправильное состояние.
if (!fs) // ой: мы не можем открыть файл в таком режиме
В большинстве ситуаций причиной сбоя при открытии файла для чтения являет-
ся его отсутствие.
ifstream ifs("redungs");
if (!ifs) // ошибка: невозможно открыть файл readings для чтения
В данном случае причиной ошибки стала опечатка.
Обычно, когда вы пытаетесь открыть несуществующий файл, операционная сис-
тема создает новый файл для вывода, но, к счастью, она не делает этого, когда вы
обращаетесь к несуществующему файлу для ввода.
ofstream ofs("no-such-file"); // создает новый файл no-such-file
ofstream ifs("no-file-of-this-name"); // ошибка: поток ifs не нахо-
// дится в состоянии good()
11.3.2. Бинарные файлы
В памяти мы можем представить значение 123 как целое или как строку.
Рассмотрим пример.
int n = 123;
string s = "123";
В первом случае число 123 интерпретируется как (двоичное) число. Объем па-
мяти, который оно занимает, совпадает с объемом памяти, который занимает любое410
ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
1
2
3
?
?
?
■л
?
t
2
3
4
5
?
?
?
123
12345
другое целое число (4 байта, т.е. 32 бита на персональном компьютере). Если вме-
сто числа 123 мы выберем число 12345, то оно по-прежнему будет занимать те же
самые четыре байта. Во втором варианте значение 123 хранится как строка из трех
символов. Если мы выберем строку "12345", то для ее хранения нам потребуются
пять символов (плюс накладные расходы памяти на управление объектом класса
string). Проиллюстрируем сказанное, используя обычные десятичное и символь-
ное представления, а не двоичное, как в памяти компьютера.
123 в виде символов:
12345 в виде символов:
123 в двоичном виде:
12345 в двоичном виде:
Когда мы используем символьное представление, то какой-то символ должен
служить признаком конца числа, так же как на бумаге, когда мы записываем одно
число 123456 и два числа 123 456. На бумаге для разделения чисел мы используем
пробел. То же самое можно сделать в памяти компьютера.
123456 в виде символов:
123 456 в виде символов:
Разница между хранением двоичного представления фиксированного размера
(например, в виде типа int) и символьного представления переменного размера
(например, в виде типа string) проявляется и при работе с файлами. По умолча-
нию потоки iostream работают с символьными представлениями; иначе говоря,
поток istream считывает п — оследовательность символов и превращает их в объ-
ект заданного типа. Поток ostream принимает объект заданного типа и преобразует
их в последовательность записываемых символов. Однако можно потребовать, что-
бы потоки istream и ostream просто копировали байты из файла в файл. Такой
ввод-вывод называется двоичным (binary I/O). В этом случае файл необходимо от-
крыть в режиме iosbase:: binary. Рассмотрим пример, в котором считываются и
записываются двоичные файлы, содержащие целые числа. Главные сроки, предна-
значенные для обработки двоичных файлов, объясняются ниже.
int main ()
{
// открываем поток istream для двоичного ввода из файла;
cout << "Пожалуйста, введите имя файла для ввода\п";
string name;
cin >> name;
ifstream if s (name.cstrO , iosbase:: binary) ; // примечание: опция
/ binary сообщает потоку, чтобы он ничего не делал
/ с байтами
1
2
3
4
5
6
?
1
2
3
4
5
6
■11.3. ОТКРЫТИЕ ФАЙЛА И ПОЗИЦИОНИРОВАНИЕ
411
if (life) error("невозможно открыть файл для ввода ", паше);
// открываем поток ostream для двоичного вывода в файл:
cout << "Пожалуйста, введете имя файла для внвода\п"?
cin >> name;
ofstream ofs (name.c_str () ,ios_baee: :binary) ; // примечание: опция
// binary сообщает потоку, чтобы он ничего не делал
// с байтами
if (!ofs) error ("невозможно открыть файл для ввода "«name);
vector<int> v;
// чтение из бинарного файла:
int i ;
while (ifs.read(asbytea (i),sizeof(int))) // примечание:
// читаем байты
v.push_back(i);
II... что-то делаем с вектором v . . .
// записываем в двоичный файл:
for(int i=0; i<v.size(); ++i)
ofs.write(asbytes (v [i]),sizeof(int)); // примечание:
// запись байтов
return 0;
}
Мы открыли эти файлы с помощью опции ios_base: :binary.
if stream ifs(name.cstr(), iosbase::binary);
ofstream of s (name.cstr () , ios_base: : binary);
В обоих вариантах мы выбрали более сложное, но часто более компактное дво-
ичное представление. Если мы перейдем от символьно-ориентированного ввода-
вывода к двоичному, то не сможем использовать обычные операторы ввода и выво-
да >> и <<. Эти операторы преобразуют значения в последовательности символов,
руководствуясь установленными по умолчанию правилами (например, строка
"asdf" превращается в символы a, s, d, f, а число 123 превращается в символы
1, 2, 3). Если вы не хотите работать с двоичным представлением чисел, достаточно
ничего не делать и использовать режим, заданный по умолчанию. Мы рекомендуем
применять опцию binary, только если вы (или кто-нибудь еще) считаете, что так
будет лучше. Например, с помощью опции binary можно сообщить потоку, что он
ничего не должен делать с байтами.
А что вообще мы могли бы сделать с типом int? Очевидно, записать его в па-
мять размером четыре байта; иначе говоря, мы могли бы обратиться к представле-
нию типа int в памяти (последовательность четырех байтов) и записать эти байты
в файл. Позднее мы могли бы преобразовать эти байты обратно в целое число.
ifs. read(asbytes(i),sizeof(int)) // чтение байтов
ofs.write(as_bytes(v[i]),sizeof(int) ) // запись байтов
Функция write () потока ostream и функция read () потока istream принимают
адрес (с помощью функции asbyte ()) и количество байтов (символов), полученное412 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
с помощью оператора sizeof. Этот адрес должен ссылаться на первый байт в памяти,
хранящей значение, которое мы хотим прочитать или записать. Например, если у нас
есть объект типа int со значением 1234, то мы могли бы получить четыре байта
(используя шестнадцатеричную систему обозначений) — 00,00,04, d2:
asjbyt es(1)
00
00
04
d2
i:
Функция as_bytes О позволяет получить адрес первого байта объекта. Ее опре-
деление выглядит так (некоторые особенности языка, использованные здесь, будут
рассмотрены в разделах 17.8 и 19.3):
template<class T>
char* as_bytes(T& i) // рассматривает объект Т как последовательность
// байтов
{
void* addr = &i; //получаем адрес первого байта
//памяти, использованной для хранения объекта
return static cast<char*>(addr); // трактуем эту память как байты
}
Небезопасное преобразование типа с помощью оператора staticcast необхо-
димо для того, чтобы получить переменную в виде совокупности байтов. Понятие
адреса будет подробно изучено в главах 17 и 18. Здесь мы просто показываем, как
представить любой объект, хранящийся в памяти, в виде совокупности байтов, что-
бы прочитать или записать его с помощью функций read () и write ().
Этот двоичный вывод запутан, сложен и уязвим для ошибок. Однако програм-
мисты не всегда должны иметь полную свободу выбора формата файла, поэтому
иногда они просто вынуждены использовать двоичный ввод-вывод по воле кого-то
другого. Кроме того, отказ от символьного представления иногда можно логично
обосновать. Типичные примеры — рисунок или звуковой файл, — не имеющие ра-
зумного символьного представления: фотография или фрагмент музыкального про-
изведения по своей природе является совокупностью битов.
Символьный ввод-вывод, по умолчанию предусмотренный в библиотеке,
не изменяется при переносе программ из одного компьютера в другой, доступен
для человеческого понимания и поддерживается любыми средствами набора текстов.
Если есть возможность, рекомендуем использовать именно символьный ввод-вывод,
а двоичный ввод-вывод применять только в случае крайней необходимости.
11.3.3. Позиционирование в файлах
При малейшей возможности считывайте и записывайте файлы от начала до
конца. Это проще всего и открывает меньше возможностей для совершения11.4. ПОТОКИ СТРОК
413
ошибок. Каждый раз, когда вы понимаете, что пора изменить файл, лучше создайте
новый и запишите в него все изменения. Однако, если вы должны поступить иначе,
то можно выполнить позиционирование и указать конкретное место для чтения
и записи в файле. В принципе в любом файле, открытом для чтения, существует по-
зиция для считывания/ввода ("read/get position"), а в любом файле, открытом для за-
писи, есть позиция для записи/вывода ('^write/put position").
Позиция для ввода: 2 Позиция для вывода: 6
Файл:
0: 1
Эти позиции можно использовать следующим образом.
fstream f в (name.c_str О ) ; // открыть для ввода и вывода
if (!fs) error("can't open ",name);
fs.seekg(5) ; // перенести позицию считывания (буква g означает "get")
//на пять ячеек вперед (шестой символ)
char ch;
fs>>ch; // считать и увеличить номер позиции для считывания
cout « "шестой символ - это " « ch « '(' « int(ch) « "iXn";
fs.seekp(l); // перенести позицию для записи (буква р означает "put")
//на одну ячейку вперед
fs<<'y'; // записать и увеличить позицию для записи
Будьте осторожны: ошибки позиционирования не распознаются. В частности,
если вы попытаетесь выйти за пределы файла (используя функцию seekgO ил»
seekp ()), то последствия могут быть непредсказуемыми и состояние операционной
системы изменится.
11.4. Потоки строк
lyYi В качестве источника ввода для потока istream или цели вывода для поток*
ostream можно использовать объект класса string. Поток istream, считы-
вающий данные из объекта класса string, называется istringstream, а потов
ostream, записывающий символы в объект класса string, называется ostring-
stream. Например, поток istringstream полезен для извлечения числовых значе-
ний из строк.
double strtodouble(string s)
// если это возможно, преобразовывает символы из строки s
// в число с плавающей точкой
{
istringstream is(s); // создаем поток для ввода из строки s
double d;
is » d;
if (lis) error("ошибка форматирования типа double: n,s);414 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
return d;
}
double dl * str_to_double("12.4"); // проверка
double d2 a etr_to_double("1.34e-3");
double d3 ■ etr_to_double("twelve point three"); // вызывается
// error()
Если попытаться прочитать данные за пределами строки, предназначенной для
ввода в поток strlngetream, то он перейдет в состояние ео£(). Это значит, что
для потока strlngetream можно использовать обычный цикл ввода; строковый по-
ток на самом деле является разновидностью потока istream.
Поток ostringstream, наоборот, может быть полезен для форматирования вы-
вода в системах, ожидающих аргумента в виде простой строки, например в систе-
мах графического пользовательского интерфейса (раздел 16.5). Рассмотрим пример.
void my_code(string label. Temperature temp)
{
// . . .
ostringstream os; // поток для составления сообщения
os « setw(8) << label << ": "
« fixed << setprecision(5) << temp.temp « temp.unit;
someobject. display (Point (100,100) , os.str () .cstr ()) ;
// . . .
}
Функция-член str() класса ostringstream возвращает объект класса string,
составленный операторами вывода, в поток ostringstream. Функция cstrO —
это функция-член класса string, возвращающая строки в стиле языка С, которые
ожидаются интерфейсами многих систем.
Ш Потоки stringstrearn обычно используются, когда мы хотим отделить соб-
ственно ввод-вывод от обработки данных. Например, аргумент типа string
в функции str_to_double() обычно поступает из файла (например, из журнала
событий веб) или с клавиатуры. Аналогично, сообщение, составленное функцией
mycodeO, в конце концов выводится на экран. Например, в разделе 11.7 мы ис-
пользуем поток stringstream при выводе для фильтрации нежелательных симво-
лов. Таким образом, потоки stringstream можно интерпретировать как механизм
настройки ввода-вывода для особых потребностей и вкусов.
Продемонстрируем использование потока ostream на простом примере конка-
тенации строк.
int seq__no = get_next_number (); // вводим число из системного журнала
ostringstream name;
name << "myfile" << seq_no; // например, myfilel7
ofstream logfile(name.str() .c_str()) ; // например, открыть myfilel7
Как правило, поток istringstream инициализируется объектом класса string,
а затем считывает из него символы, используя операторы ввода. И наоборот, поток
ostringstream инициализируется пустым объектом класса string, а затем запол-11.5. ВВОД, ОРИЕНТИРОВАННЫЙ НА СТРОКИ
415
няется с помощью операторов вывода. Существует более простой способ доступа
к символам в потоке s brings tream, который иногда оказывается полезным: функ-
ция ss. str () возвращает копию строки из объекта as, а функция as. str (s) при-
сваивает строке в объекте ее копию строки е. В разделе 11.7 приведен пример,
в котором функция ss. str (в) играет существенную роль.
11.5. Ввод, ориентированный на строки
Оператор >> вводит данные в объекты заданного типа в соответствии со стан-
дартным форматом, установленным для этого типа. Например, при вводе чисел
в объект типа int оператор >> будет выполнять ввод, пока не обнаружит символ, не
являющийся цифрой, а при вводе в объект класса string оператор » будет счи-
тывать символы, пока не обнаружит разделитель (whitespace). Стандартная библио-
тека is tream содержит также средства для ввода отдельных символов и целых
строк. Рассмотрим пример.
string name;
cin >> name; // ввод: Dennis Ritchie
cout << name << '\n'; // вывод: Dennis
Что, если мы захотим прочитать всю строку сразу, а способ ее форматирования
выберем потом? Это можно сделать с помощью функции getline(). Рассмотрим
пример.
string name;
getline(cin,name) ; // ввод: Dennis Ritchie
cout << name << 'Xn'; // вывод: Dennis Ritchie
Теперь мы считали целую строку. Зачем нам это было нужно? Например, непло-
хой ответ: "Потому что мы сделали то, чего не может оператор >>". Часто можно
слышать совершенно неудачное объяснение: "Потому что пользователь набрал пол-
ную строку". Если это все, что вы можете сказать, то используйте оператор »,
потому что, если вы ввели строку, то должны как-то ее разобрать на части. Рассмот-
рим пример.
string firstname;
string secondname;
stringstream ss(name);
ss>>firstname; // ввод строки Dennis
ss>>second__name; // ввод строки Ritchie
Непосредственный ввод данных в строки firstname и second_name можно
было бы выполнить проще. Одна из распространенных причин для считывания
полной строки заключается в том, что определение разделителя не всегда является
достаточно приемлемым. Иногда переход на новую строку желательно трактовать
не как разделитель. Например, в ходе обмена сообщениями в компьютерной игре416 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
текст разумнее интерпретировать как предложение, не полагаясь на общепринятую
пунктуацию.
идти налево, пока не увидишь картину справа на стене
сними картину со стены и открой дверь позади нее. Возьми сундук
В данном случае мы сначала прочитаем всю строку, а затем извлечем из нее
отдельные слова.
string command;
getline (cin,command); // вводим строку
stringstream ss(command);
vector<string> words;
string s;
while (ss>>s) words.push_back(s) ; // извлекаем отдельные слова
С другой стороны, если есть выбор, то лучше всего ориентироваться на знаки
пунктуации, а не на символ перехода на новую строку.
11.6. Классификация символов
Как правило, мы вводим целые числа, числа с плавающей точкой, слова и так
далее, в соответствии с общепринятым форматом. Однако мы можем, а иногда
и должны, снизить уровень абстракции и ввести отдельные символы. Для этого не-
обходимо затратить больше усилий, но, считывая отдельные символы, мы получаем
полный контроль на тем, что делаем. Рассмотрим задачу распознавания лексем
в выражениях из раздела 7.8.2.
Допустим, мы хотим разделить выражение l+4*x<=y/z*5 на одиннадцать лексем.
l+4*x<=y/z*5
Для ввода чисел мы могли бы использовать оператор >>, но, пытаясь ввести
идентификаторы как строки, должны были бы прочитать фразу х<*у как целую
строку (поскольку символы < и = не являются разделителями). Сочетание символов
z* мы также должны были бы ввести как целую строку (поскольку символ * также
не является разделителем).
Вместо этого можно сделать следующее:
char ch;
while (cin.get(ch)) {
if (isspace (ch)) { // если символ ch является разделителем,
// ничего не делаем (так как разделители
// игнорируются)
}
if dsdigit(ch)) {
// вводим число
}
else if (isalpha(ch)) {
/ вводим идентификатор11.6. КЛАССИФИКАЦИЯ СИМВОЛОВ
417
}
else {
// обрабатываем операторы
}
}
Функция ietream: :get О считывает отдельный символ в свой аргумент. Разде-
лители при этом не игнорируются. Как и оператор », функция get О возвращает
ссылку на свой поток ietream, так что можно проверить его состояние.
При вводе отдельных символов мы обычно хотим классифицировать их: это
символ или цифра? В верхнем регистре или в нижнем? И так далее. Для этого суще-
ствует набор стандартных библиотечных функций.
Классификация символов
isspace(c) Является ли с разделителем (' ', '\t', ' \n' и т.д.)?
isalpha (с) Является ли с буквой ('a'.-'z1, ' А'..' Z ') (примечание: не ■ _')?
isdigit (с) Является ли с десятичной цифрой (' 0 '.. ■ 9 ■)?
isxdigi t (с) Является ли с шестнадцатеричной цифрой (десятичной цифрой или симво-
лом 'а'.. ■ f 'или 'А'.. " F1)?
isupper (с) Является ли с буквой в верхнем регистре?
is lower (с) Является ли с буквой в нижнем регистре?
isalnum (с) Является ли с буквой или десятичной цифрой?
iscntrl (с) Является ли с управляющим символом (ASCII 0..31 и 127)?
ispunct(c) Правда ли, что с не является ни буквой, ни цифрой, ни разделителем,
ни невидимым управляющим символом?
isprint (с) Выводится ли символ с на печать (ASCII ■ »..' ~ ')?
isgraph(c) Выполняется ли для с условие isalpha () | isdigit () | ispunct ()
(примечание: не пробел)?
Обратите внимание на то, что категории классификации можно объединять
с помощью оператора ИЛИ (|). Например, выражение iealnum(c) означает isal-
pha (с) | isdigit (с); иначе говоря, "является ли символ с буквой или цифрой?"
Кроме того, в стандартной библиотеке есть две полезные функции для уничто-
жения различий между символами, набранными в разных регистрах.
Регистр символа
toupper (с) с или его эквивалент в верхнем регистре
tolower (с) с или его эквивалент в нижнем регистре
Это удобно, когда мы хотим устранить различия между символами, набранными
в разных регистрах. Например, если пользователь ввел слова Right, right и rigHT,
то, скорее всего, он имел в виду одно и то же (например, слово rigHT чаще всего
является результатом нечаянного нажатия клавиши <Caps Lock>). Применив функ-
цию tolower О к каждому символу в каждой из строк, мы можем получить одно418 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
и то же значение: right. Эту операцию можно вьшолнить с любым объектом класса
string.
void tolower(strings s) // вводит строку s в нижнем регистре
{
for (int isO; i<s.length() ; ++i) s [i] = tolower (s [i]) ;
}
Для того чтобы действительно изменить объект класса etring, используем
передачу аргумента по ссылке (см. раздел 8.5.5). Если бы мы хотели сохра-
нить старую строку без изменения, то могли бы написать функцию, создающую ее
копию в нижнем регистре. Мы предпочитаем функцию tolower (), а не toupper О,
поскольку она лучше работает с текстами на некоторых естественных языках, на-
пример немецком, в которых не каждый символ в нижнем регистре имеет эквива-
лент в верхнем регистре.
11.7. Использование нестандартных разделителей
В этом разделе мы рассмотрим гипотетические примеры использования потоков
iostream для решения реальных задач. При вводе строк слова по умолчанию раз-
деляются пробелами или другими специальными символами (whitespace). К сожа-
лению, поток istream не имеет средств, позволяющих определять, какие символы
должны играть роль разделителей, или непосредственно изменять способ, с помо-
щью которого оператор » считывает строки. Итак, что делать, если мы хотим дать
другое определение разделителю? Рассмотрим пример из раздела 4.6.3, в котором
мы считывали слова и сравнивали их друг с другом. Между этими словами стояли
разделители, поэтому если мы вводили строку
As planned, the guests arrived; then
то получали слова
As
planned,
the
guests
arrived;
then,
Это слова невозможно найти в словаре: "planned," и "arrived;"— это вообще
не слова. Это набор букв, состоящий из слов, к которым присоединены лишние и не
относящиеся к делу знаки пунктуации. В большинстве случаев мы должны рассмат-
ривать знаки пунктуации как разделители. Как же избавиться от этих знаков пунк-
туации9 Мы могли бы считать символы, удалить знаки пунктуации или преобразо-
вать их в пробелы, а затем ввести "очищенные" данные снова,
string line;
getline(cin,line); // вводим строку line11.7. ИСПОЛЬЗОВАНИЕ НЕСТАНДАРТНЫХ РАЗДЕЛИТЕЛЕЙ
419
for (int i-0; i<line.eizeО; ++i) //заменяем знаки пунктуации
//пробелами
switch(line[i]) {
case ■;•: case '.': case •,•: case '?': case ' 1 ':
line[i] = ' ';
}
stringstream ss(line); // создаем поток istream ss, вводя в него
строку line
vector<string> vs;
string word;
while (ss»word) // считываем слова без знаков пунктуации
vs.pushback(word);
Применив такой способ, получаем желаемый результат.
As
planned
the
guests
arrived
then
К сожалению, этот код слишком сложен и излишне специализирован. А что де-
лать, если знаки пунктуации определены иначе? Опишем более общий и полезный
способ удаления нежелательных символов из потока ввода. Как должен выглядеть
этот поток? Как должен выглядеть наш код? Может быть, так?
ps.whitespace (" ; :, . ") ; // точка с запятой, двоеточие, запятая и точка
// считаются разделителями
string word;
while (ps>>word) vs.push back(word);
Как определить поток, работающий так, как поток ps? Основная идея заключа-
ется в том, чтобы считывать слова в обычный поток ввода, а затем обрабатывать
символы-разделители, заданные пользователем, как настоящие разделители, т.е.
не передавать разделители пользователю, а просто использовать их для отделения
слов друг от друга. Рассмотрим пример.
as.not
Слова as и not должны быть двумя самостоятельными словами
as
not
Для того чтобы сделать это, можно определить класс. Он должен принимать
символы из потока istream и содержать оператор », работающий так же, как опе-
ратор ввода потока istream, за исключением того, что мы сами можем указывать,
какие символы являются разделителями. Для простоты будем считать существую-
щие символы-разделители (пробел, символ перехода на новую строку и т.д.) обыч-420 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
ными символами; мы просто позволим пользователю указать дополнительные раз-
делители. Кроме того, мы не будем удалять указанные символы из потока;
как и прежде, мы превратим их в разделители. Назовем наш класс Punct_stream.
class Punct_stream { // аналогичен потоку istream, но пользователь
// может самостоятельно задавать разделители
public:
Punct_stream(istream& is)
: source(is)/ sensitive(true) { }
void whitespace(const stringfc s) // создает строку
// разделителей s
{ white = в; }
void add_white(char c) { white += c; } // добавляет символ
//в набор разделителей
bool is_whitespace(char с); // является ли с набором
// разделителей?
void case_sensitive(bool b) { sensitive = b; }
bool is_case_sensitive() { return sensitive; }
Punct_stream& operator>> (strings s);
operator bool();
private:
istream& source; // источник символов
istringstream buffer; // буфер для форматирования
string white; // символы-разделители
bool sensitive; // является ли поток чувствительным
// к регистру?
}|
Как и в предыдущем примере, основная идея — ввести строку из потока istream
как одно целое, преобразовать символы-разделители в пробелы, а затем использовать
поток stringstrearn для форматирования. Кроме обработки разделителей, заданных
пользователем, в классе Punct_stream есть аналогичная возможность: если вызвать
функцию casesensitiveO, то она преобразует ввод, чувствительный к регистру,
в нечувствительный.
Например, можно приказать объекту класса Punct_stream прочитать строку
Man bites dog!
как
man
bites
dog
Конструктор класса Punctstream получает поток i stream, используемый как
источник символов, и присваивает ему локальное имя source. Кроме того, конст-
руктор по умолчанию делает поток чувствительным к регистру, как обычно. Можно
создать объект класса Punct_stream, считывающий данные из потока cin, рас»11.7. ИСПОЛЬЗОВАНИЕ НЕСТАНДАРТНЫХ РАЗДЕЛИТЕЛЕЙ
421
сматривающий точку с запятой, двоеточие и точку как разделители, а также перево-
дящий все символы в нижний регистр.
Punct_stream ps (cin) ; // объект ps считывает данные из потока cin
ps.whitespace(";:."); // точка с запятой, двоеточие и точка
// также являются разделителями
ps.casesensitive(false); // нечувствительный к регистру
Очевидно, что наиболее интересной операцией является оператор ввода ».
Он также является самым сложным для определения. Наша общая стратегия состо-
ит в том, чтобы считать всю строку из потока istream в строку line. Затем мы
превратим все наши разделители в пробелы (■ ■). После этого отправим строку
в поток istringstream с именем buffer. Теперь для считывания данных из потока
buffer можно использовать обычные разделители и оператор ». Код будет выгля-
деть немного сложнее, поскольку мы только пытаемся считать данные из потока
buffer и заполняем его, только если он пуст.
Punct_stream& Punctstream: :operator>>(string& s)
{
while (!(buffer>>s)) { // попытка прочитать данные
// из потока buffer
if (buffer,bad() || !source.good()) return *this;
buffer.clear();
string line;
getline(source,line); // считываем строку line
// из потока source
// при необходимости заменяем символы
for (int i =0; i<line.size(); ++i)
if (iswhitespace(line[i]))
line[i]= ' '; //в пробел
else if ({sensitive)
line[i] = tolower(line[i]); // в нижний регистр
buffer.str(line); // записываем строку в поток
}
return *this;
}
Рассмотрим этот код шаг за шагом. Сначала обратим внимание не нечто не-
обычное.
while (! (buffer»s)) {
Если в потоке buffer класса istringstream есть символы, то выполняется ин-
струкция buffer>>sH объект s получит слово, разделенное разделителями; больше
эта инструкция ничего не делает. Эта инструкция будет выполняться, пока в объекте
buffer есть символы для ввода. Однако, когда инструкция buffer>>s не сможет
выполнить свою работу, т.е. если выполняется условие ! (buffer»s), мы должны422 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
наполнить объект buffer символами из потока source. Обратите внимание на то,
что инструкция buf f er»s выполняется в цикле; после попытки заполнить объект
buffer мы должны снова попытаться выполнить ввод.
while (1(buffer>>s)) { // попытка прочитать символы из буфера
if (buffer.bad() || !source.good()) return *this;
buffer.clear();
// заполняем объект buffer
}
Если объект buffer находится в состоянии bad() или существуют проблемы
с источником данных, работа прекращается; в противном случае объект buffer
очищается и выполняется новая попытка. Мы должны очистить объект buffer, по-
тому что попадем в "цикл заполнения", только если попытка ввода закончится не»
удачей. Обычно это происходит, если вызывается функция ео£()дпя объекта
buffer; иначе говоря, когда в объекте buffer не остается больше символов для
чтения. Обработка состояний потока всегда запутанна и часто является причиной
очень тонких ошибок, требующих утомительной отладки. К счастью, остаток цикла
заполнения вполне очевиден.
string line;
getline (source, line); // вводим строку line из потока source
// при необходимости выполняем замену символов
for (int i =0; i<line.size(); ++i)
if (iswhitespace(line[i]))
line[i]= ' '; //в пробел
else if ([sensitive)
line[i] = tolower (line [i] ) ; // в нижний регистр
buffer.str(line) ; // вводим строку в поток
Считываем строку в объект buffer, затем просматриваем каждый символ стро-
ки в поисках кандидатов на замену. Функция iswhitespace () является членом
класса Punctstream, который мы определим позднее. Функция tolower О —
это стандартная библиотечная функция, выполняющая очевидное задание, напри-
мер превращает символ А в символ а (см. раздел 11.6).
После правильной обработки строки line ее необходимо записать в поток is-
tringstream. Эту задачу выполняет функция buffer.str(line); эту команду
можно прочитать так: "Поместить строку из объекта buffer класса stringstream
в объект line".
Обратите внимание на то, что мы "забыли" проверить состояние объекта source
после чтения данных с помощью функции getline (). Это не обязательно, посколь*
ку в начале цикла выполняется проверка условия ! source. good ().
Как всегда, оператор >> возвращает ссылку на поток «this (раздел 17.10).11.7. ИСПОЛЬЗОВАНИЕ НЕСТАНДАРТНЫХ РАЗДЕЛИТЕЛЕЙ
423
Проверка разделителей проста; мы сравниваем символ с каждым символом
из строки, в которой записаны разделители.
bool Punct_strearn: : is_wb.itespace (char c)
{
for (int i = 0; i<white.size() ; ++i)
if (c«white[i] ) return true;
return false;
}
Напомним, что поток istringstream обрабатывает обычные разделители
(например, символы перехода на новую строку или пробел) по-прежнему, поэтому
никаких особых действий предпринимать не надо.
Осталась одна загадочная функция.
Punct_stream::operator bool()
{
return 1(source.fail() || source.bad()) && source.good() ;
}
Обычное использование потока istream сводится к проверке результата опера-
тора >>. Рассмотрим пример.
while (ps>>s) { /* . . . */ }
Это значит, что нам нужен способ для проверки результата выполнения инст-
рукции ps>>s, представленного в виде булевого значения. Результатом инструкции
ps>>s является объект класса Punct_stream, поэтому нам нужен способ неявного
преобразования класса Punctstream в тип bool. Эту задачу решает функция op-
erator bool () в классе Punc tst ream.
Функция-член operator bool О определяет преобразование класса Punct_
stream в тип bool. В частности, она возвращает значение true, если эта операция
над классом Punct_stream прошла успешно.
Теперь можем написать программу.
int main()
// вводит текст и создает упорядоченный список всех слов
// из заданного текста, игнорируя знаки пунктуации и регистры,
// а также удаляя дубликаты из полученного результата
Punct_stream ps (cin);
ps.whitespaceC; :, .?! О \"{}<>/&$@#%A* | ~") ; // \" в строке
// означает "
ps.casesensitive(false);
cout << "Пожалуйста, введите слова\п";
vector<string> vs;
string word;
while (ps>>word) vs.pushback(word); // ввод слов424 ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
sort (vs. begin (), vs. end О ) ; // сортировка в лексикографическом
// порядке
for (int i=0; i<vs.size(); ++i) // запись в словарь
if (i==0 || vs[i] !=vs[i-l] ) cout « vs [i] « endl;
}
Этот код создает упорядоченный список введенных слов. Инструкция
if (i==0 || vs[i]l=vs[i-l])
удаляет дубликаты. Если в программу ввести слова
There are only two kinds of languages: languages that people complain
about, and languages that people don't use.
то результат ее работы будет выглядеть следующим образом:
and
are
complain
don't
languages
of
only-
people
that
there
two
use
Почему мы получили на выходе don't, а не dont? Потому что оставили апост-
роф за пределами списка разделителей white space ().
IvTl Внимание: класс Punct_stream во многом похож на класс istream, но на са-
*—■ мом деле отличается от него. Например, мы не можем проверить его состояние
с помощью функции rdstate(), функция eof ()не определена, и нет оператора »,
который вводит целые числа. Важно отметить, что мы не можем передать
объект класса Punctstream в качестве аргумента функции, ожидающей поток
istream. Можно ли определить класс Punct_istream, который в точности повто-
рял бы поведение класса istream? Можно, но у вас пока нет достаточного опыта
программирования, вы еще не освоили основы проектирования и не знаете всех
возможностей языка (если впоследствии вы вернетесь к этой задаче, то сможете
реализовать буферы потоков на уровне профессионала).
=*| Легко ли читать определение класса Punct_stream? Понятны ли вам объяс-
==^ нения? Могли бы вы самостоятельно написать такую программу? Еще не-
сколько дней назад вы были новичком и честно закричали бы: "Нет, нет! Никогда!"
или "Нет, нет! Вы что, с ума сошли? Очевидно, что ответ на поставленный вопрос
отрицательный". Цель нашего примера заключается в следующем:
• показать реальную задачу и способ ее решения;
• доказать что это решение можно найти с помощью вполне доступных средств;11.8. И ЕЩЕ МНОГО ЧЕГО
425
описать простое решение простой задачи;
продемонстрировать разницу между интерфейсом и реализацией.
Для того чтобы стать программистом, вы должны читать программы, причем
не только учебные. Приведенный пример относится как раз к таким задачам.
Через несколько дней или недель вы разберетесь в нем без труда и сможете улуч-
шить это решение.
Этот пример можно сравнить с уроком, на котором учитель английского языка для
иностранцев произносит выражения на сленге, чтобы показать его колорит и живость.
11.8. И еще много чего
Г7Г Подробности ввода-вывода можно описывать бесконечно. Этот процесс огра-
•—' ничен лишь терпением слушателей. Например, мы не рассмотрели сложности,
связанные с естественными языками. То, что в английском языке записывается как
12.3 5, в большинстве европейских языков означает 12,35. Естественно, стандарт-
ная библиотека C++ предоставляет возможности для устранения этих и многих дру-
гих проблем. А как записать китайские иероглифы? Как сравнивать строки, запи-
санные символами малайского языка? Ответы на эти вопросы существуют, но они
выходят далеко за рамки нашей книги. Если вам потребуется более детальная ин-
формация, можете обратиться к более специализированным книгам (например,
Langer, Standard C++ lOStr earns and Locales и Stroustrup, The C++ Programming
Language), а также к библиотечной и системной документации. Ищите ключевое
слово locale (местная специфика); этот термин обычно применяется к функциональ-
ным возможностям для обработки различий между естественными языками.
Другим источником сложностей является буферизация; стандартные библиотеч-
ные потоки iostream основаны на концепции под названием streambuf.
Для сложных задач, связанных с потоками iostream, при решении которых важна
производительность или функциональность, без объектов класса istreambuf обой-
тись нельзя. Если хотите определить свой собственный класс iostream или настро-
ить объекты класса iostream на новые источники данных, см. главу 21 книги
The C++ Programming Language Страуструпа или системную документацию.
При программировании на языке C++ вы можете обнаружить семейство стан-
дартных функций ввода-вывода printf ()/scanf О, определенных в языке С.
В этом случае прочитайте разделы 27.6, В. 10.2, или прекрасный учебник Кернигана
и Ритчи Язык программирования С (Kernighan and Ritchie, The C Programming Lan-
guage), или же любой из многочисленных источников информации в веб. Каждый
язык имеет свои собственные средства ввода-вывода; все они изменяются, иногда
неправильно, но в большинстве случаев правильно (совершенно по-разному) отра-
жая основные понятия, изложенные в главах 10 и 11.
Стандартная библиотека ввода-вывода описана в приложении Б, а связанные
с ней графические пользовательские интерфейсы — в главах 12-16.426
ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
Задание
1. Напишите программу с именем Test_output.cpp. Объявите целочисленную
переменную birth_year и присвойте ей год своего рождения.
2. Выведите переменную birth_year в десятичном, шестнадцатеричноц
и восьмеричном виде.
3. Выведите основание системы счисления для каждого числа.
4. Выровняли ли вы результаты по столбцам с помощью символа табуляции? Если
нет, то сделайте это.
5. Теперь выведите год вашего рождения.
6. Были ли какие-то проблемы? Что произошло? Замените ваш вывод на деся-
тичный.
7. Вернитесь к упр. 2 и выведите основание системы счисления для каждого числа.
8. Попытайтесь прочитать данные как восьмеричные, шестнадцатеричные и т.д.
cin >> a »oct >> b >> hex » с >> d;
cout « a « '\t'« b « '\t'« с « • \t*<< d « ' \n' ;
Запустите программу со следующими входными данными:
1234 1234 1234 1234
Объясните результаты.
9. Напишите программу, три раза выводящую на печать число 1234567.89: сна-
чала в формате general, затем — в fixed и в scientific. Какой способ пред-
ставления обеспечивает наибольшую точность? Почему?
10. Создайте простую таблицу, содержащую фамилию, имя, телефонный номер
и адрес электронной почты хотя бы пяти ваших друзей. Поэкспериментируйте
с разной шириной полей, пока не найдете приемлемый.
Контрольные вопросы
1. Почему ввод-вывод является сложной задачей для программиста?
2. Что означает выражение « hex?
3. Какие шестнадцатеричные числа используются в компьютерных науках? Поче-
му?
4. Перечислите несколько возможностей, которые вы хотели бы реализовать
при форматировании вывода целых чисел.
5. Что такое манипулятор?
6. Назовите префикс десятичного, восьмеричного и шестнадцатеричного числа.
7. Какой формат по умолчанию применяется при выводе чисел с плавающей точкой?
8 Что такое поле вывода?
9 Объясните, что делают функции eetprecision () И setw ().ТЕРМИНЫ
427
10. Для чего нужны разные режимы при открытии файлов?
11. Какие из перечисленных далее манипуляторов не являются инертными; hex,
scientific, setprecision,showbase, setw?
12. Укажите разницу между символьным и двоичным вводом.
13. Приведите пример, демонстрирующий преимущество использования двоичного
файла вместо текстового.
14. Приведите два примера, в которых может оказаться полезным класс etring-
stream.
15. Что такое позиция в файле?
16. Что произойдет, если позиция в файле будет установлена за его пределами?
17. Когда ввод строк предпочтительнее, чем ввод, ориентированный на тип?
18. Что делает функция isalnum(c) ?
Термины
fixed
general
noshowbase
scientific
setprecision
showbase
восьмеричный
двоичный
десятичный
классификация символов
манипулятор
нерегулярность
нестандартный разделитель
позиционирование файла
регулярность
строковый ввод
форматирование вывода
шестнадцатеричный
Упражнения
1. Напишите программу, вводящую текстовый файл и записывающую его содер-
жимое в новый файл, используя нижний регистр.
2. Напишите программу, удаляющую из файла все гласные буквы. Например, фра-
за Once upon a time! принимает вид nc pn tail. Удивительно часто резуль-
тат остается вполне читабельным; проверьте это на своих друзьях.
3. Напишите программу под названием multiinput.cpp, которая предлагает
пользователю ввести несколько целых восьмеричных, десятичных и шестнад-
цатеричных чисел в любом сочетании, используя суффиксы 0 и Ох; интер-
претируйте эти числа правильно и приведите в десятичный вид. Ваша прог-
рамма должна выводить на экран примерно такие результаты:
0x4 шестнадцатеричное превращается в 67 десятичное
0123 восьмеричное превращается в 83 десятичное
65 десятичное превращается в 65 десятичное
4. Напишите программу, считывающую строки и выводящую категории каждого
символа в соответствии с правилами классификации, описанными в раз-
деле 11.6. Помните, что один и тот же символ может относиться к разным кате-
гориям (например, х — это и буквенный, и буквенно-цифровой символ).428
ГЛАВА 11 • НАСТРОЙКА ВВОДА И ВЫВОДА
5. Напишите программу, заменяющую знаки пунктуации пробелами. Например,
строка" - don't use the as-if rule", принимает вид" dont use the
asif rule ".
6. Модифицируйте программу из предыдущего упражнения, чтобы она заменяла
сокращения don't словами do not, can't — cannot и т.д.; дефисы внутри
слов не трогайте (таким образом, мы получим строку " do not use the as-if
rule"); переведите все символы в нижний регистр.
7. Используйте программу из предыдущего упражнения для создания словаря
(в качестве альтернативы подходу, описанному в разделе 11.7). Примените ее
к многостраничному текстовому файлу, проанализируйте результат и подумайте,
можно ли улучшить эту программу, чтобы получить более качественный словарь.
8. Разделите программы ввода-вывода из раздела 11.3.2 на две части: одна про-
грамма пусть конвертирует обычный текстовый файл в двоичный, а другая —
считывает двоичный файл и преобразует его в текстовый. Протестируйте эти
программы, сравнивая текстовые файлы до и после преобразования в двоичный
файл.
9. Напишите функцию vector<string> split (const string& s), возвращаю-
щую вектор подстрок аргумента s, разделенных пробелами.
10. Напишите функцию vector<string> split (const strings s, const stringfc
w), возвращающую вектор подстрок аргумента s, между которыми стоят разде-
лители, при условии, что в качестве разделителя может использоваться как
обычный пробел, так и символы из строки w.
11. Измените порядок следования символов в текстовом файле. Например, строка
asdfghjkl примет вид lkjhgfdsa. Подсказка: вспомните о режимах открытия
файлов.
12. Измените порядок следования слов (определенных как строки, разделенные
пробелами). Например, строка Norwegian Blue parrot примет вид parrot
Blue Norwegian. Вы можете предположить, что все строки из файла могут по-
меститься в памяти одновременно.
13. Напишите программу, считывающую текстовый файл и записывающую в дру-
гой файл количество символов каждой категории (см. раздел 11.6).
14. Напишите программу, считывающую из файла числа, разделенные пробелами,
и выводящую в другой файл числа, используя научный формат и точность, рав-
ную восьми в четырех полях по двадцать символов в строке.
15 Напишите программу, считывающую из файла числа, разделенные пробелами,
и выводящую их в порядке возрастания по одному числу в строке. Каждое чис-
ло должно быть записано только один раз, если обнаружится дубликат, то необ-
ходимо вывести количество таких дубликатов в строке. Например, срока "7 5 5
7 з 117 5' примет следующий вид:ПОСЛЕСЛОВИЕ
429
з
5 3
7 2
117
Послесловие
Ввод и вывод сложны, поскольку вкусы и предпочтения у людей разные и не
подчиняются стандартизации и математическим законам. Как программисты мы
редко имеем право навязывать пользователям свои взгляды, а когда можем выби-
рать, должны сдерживаться и стараться предлагать простые альтернативы, которые
выдержат проверку временем. Следовательно, мы должны смириться с определен-
ными неудобствами ввода и вывода и стремиться, чтобы наши программы были как
можно более простыми, но не проще.Вывод на экран
"Сначала мир был черным, а затем белым,
а в 1930-х годах появился цвет".
Папаша Кальвина (Calvin's dad)1
В главе описана модель вывода на экран дисплея (часть графического
пользовательского интерфейса, отвечающая за вывод информации),
приведены примеры ее использования, а также сформулированы основные
понятия, такие как координаты экрана, линии и цвет. Рассмотрены классы
Line, Lines, Polygon, Axis и Text, являющиеся подклассами класса Shape.
Объект класса Shape хранится в памяти, отображается на экране и допускает
манипуляции с ним. В следующих двух главах мы глубже исследуем эти
классы. В главе 13 рассмотрим их реализацию, а в главе 14— вопросы, свя-
занные с проектированием.
1 Папаша Кальвина — персонаж популярного в США комикса Calvin and Hobbes. —
Примеч. ред.432 ГЛАВА 12 • ВЫВОД НА ЭКРАН
В этой главе...
12.1. Почему графика?
12.2. Вывод на дисплей
12.3. Первый пример
12.4. Использование библиотеки
графического пользова-
тельского интерфейса
12.5. Координаты
12.6. Класс Shape
12.1. Почему графика?
Почему мы посвящаем четыре главы графике и одну главу — графическим поль-
зовательским интерфейсам (graphical user interface— GUI)? Как никак, эта книга
о программировании, а не о графике. Существует огромное количество интересных
тем, связанных с программированием, которые мы не обсуждаем и в лучшем случае
можем сделать лишь краткий обзор вопросов, касающихся графики. Итак, почему
графика? В основном потому, что графика — это предмет, позволяющий исследо-
вать важные вопросы, относящиеся к проектированию программного обеспечения,
программирования, а также к инструментам программирования.
• Графика полезна. Программирование как тема намного шире графики, а про-
граммное обеспечение намного содержательнее, чем проблемы манипулиро-
вания кодом с помощью графического пользовательского интерфейса. Одна-
ко во многих областях хорошая графика играет существенную или очень
важную роль. Например, мы не могли бы и мечтать об изучении проблем,
связанных с научными вычислениями, анализом данных или просто с количе-
ственными исследованиями, не имея возможности изображать данные с по-
мощью графики. Простые (но содержательные) примеры использования гра-
фики для представления данных приведены в главе 15.
• Графика красива. Это одна из редких сфер деятельности, связанных с вычис-
лениями, в которых результат выполнения фрагмента кода был бы таким на-
глядным и приятным (после устранения ошибок). С графикой приятно рабо-
тать даже тогда, когда она не приносит ощутимой пользы!
• Графические программы очень интересны. Обучение программированию
подразумевает чтение множества программ, чтобы получить представление
о хорошем коде. Аналогично, для того чтобы хорошо овладеть английским
языком, необходимо прочитать много книг, журналов и газет. Благодаря пря-
12.7. Использование графических примитивов
12.7.1. Графические заголовочные файлы и функ-
ция main
12.7.2. Почти пустое окно
12.7.3. Оси координат
12.7.4. График функции
12.7.5. Многоугольники
12.7.6. Прямоугольник
12.7.7. Заполнение
12.7.8. Текст
12.7.9. Изображения
12.7.10. И многое другое
12.8. Запуск программы
12.8.1. Исходные файлы12 2 ВЫВОД НА ДИСПЛЕИ
433
мой зависимости между тем, что мы видим на экране, и тем, что написано
в программе, простой графический код легче для понимания, чем большинст-
во программ, сравнимых с ним по сложности. В этой главе мы начнем читать
графические коды практически сразу после введения, а в главе 13 покажем,
как написать эти коды за несколько часов.
• Графика — изобильный источник примеров, связанных с проектированием.
Разработать и реализовать хорошую графику и библиотеку графического
пользовательского интерфейса трудно. Графика— очень богатый источник
конкретных и практических примеров проектных решений и методов проек-
тирования. Некоторые из наиболее полезных методов проектирования клас-
сов и функций, разделения программного обеспечения на слои (абстракций)
и создания библиотек можно проиллюстрировать с помощью относительно
небольшого количества программ, реализующих графический вывод данных
и графический пользовательских интерфейс.
• Графика удобна для введения в объектно-ориентированное программирова-
ния и языковые средства его поддержки. Несмотря на то что молва утвер-
ждает обратное, объектно-ориентированное программирование вовсе не было
изобретено для того, чтобы появилась возможность работать с графическими
программами (подробнее об этом речь пойдет в главе 22), но этот подход
практически сразу же был применен для реализации графики, которая стала
одним из наиболее ярких примеров, демонстрирующих преимущество объ-
ектно-ориентированного проектирования.
• Некоторые понятия, связанные с графикой, нетривиальны. Поэтому они за-
служивают тщательного изложения. Эти вопросы нельзя оставлять на само-
тек, надеясь на пытливость и терпение читателей. Если не показать, как рабо-
тают графические программы, читатели станут относиться к ним, как
к "черным ящикам", а это прямо противоречит основным целям нашей книги.
12.2. Вывод на дисплей
Библиотека ввода-вывода ориентирована на чтение и запись потоков символов.
Единственными символами, непосредственно связанными с понятием графической
позиции, являются символы перехода на новую строку и табуляции. Кроме того,
в одномерный поток символов можно внедрить также понятия цвета и двумерных
позиций. Именно так устроены такие языки разметки, как Troff, Тех, Word, HTTP
и XML (а также связанные с ними графические пакеты). Рассмотрим пример.
<hr>
<h2>
Организация
</h2>
Этот список состоит иэ трех частей:434
ГЛАВА 12 • ВЫВОД НА ЭКРАН
<ul>
<11><Ь>Предложениж/Ь>, пронумерованные EPddd, . . .</li>
<11><Ь>Пункты</Ь>, пронумерованные BIddd, . . .</!!>
<11><Ь>Предположения</Ь>, пронумерованные ESddd, . . .</li>
</ul>
<р>Мы пытаемся . . .
<Р>
Это фрагмент кода на языке HTML, в котором указан заголовок (<h2> . . .
</Ь2>), список (<ul> . . . </ul>) с пунктами (<il> . . . </il>) и параграфы
(<р>). Мы оставили часть текста, поскольку он в данном случае роли не играет.
Главное, что мы можем выразить свое представление о разметке в обычном тексте,
а связи между тем, как записаны символы и как они появляются на экране, являют-
ся опосредованными и управляются программой, интерпретирующей команды раз-
метки. Такой метод очень прост и чрезвычайно полезен (все, что вы сейчас читаете,
было создано с его помощью), но имеет некоторые ограничения.
В данной и следующих четырех главах мы описываем альтернативный подход:
понятие графики и графического пользовательского интерфейса, непосредственно
связанных с экраном компьютера. Основные концепции — координаты, линии,
прямоугольники и окружности — по своей сути являются графическими (и двумер-
ными, поскольку они адаптированы к прямоугольному экрану компьютера). С точки
зрения программирования цель этих понятий заключается в создании прямой зави-
симости между объектами памяти и образами на экране.
\Т7[ Основная модель имеет следующий вид. Мы составляем объекты из элемен-
'—' тарных объектов, предоставляемых графической системой, например линий.
Затем связываем эти графические объекты с окном объекта, представляющим собой
физический экран. Затем программа, которую мы можем интерпретировать как
дисплей, драйвер дисплея, графическую библиотеку, библиотеку графического ин-
терфейса и даже (шутка) как маленького гномика, находящегося по ту сторону
экрана, принимает объекты, добавляемые нами в окне, и рисует их на экране.
Драйвер дисплея рисует линии на экране, размещает на нем текстовые строки,
закрашивает его области и т.д. Для простоты обозначения драйвера дисплея мы ис-
пользуем слова графическая библиотека и даже система, несмотря на то, что биб-
attach()
"Окно"
attach()12.3. ПЕРВЫЙ ПРИМЕР
435
лиотека графического пользовательского интерфейса может значительно больше,
чем просто рисовать объекты. Точно так же как наш код может заставить библиоте-
ку графического пользовательского интерфейса делать за нас большую часть рабо-
ты, сама библиотека делегирует большинство своих заданий операционной системе.
12.3. Первый пример
Наша задача— определить классы, из которых можно создавать объекты
для вывода на экран. Например, мы можем нарисовать график в виде ломаной ли-
нии. Вот небольшая программа, выполняющая эту работу:
#include "Simple_window.h" // открывает доступ к оконной библиотеке
#include "Graph.h" // открывает доступ к графической биб-
лиотеке
int main ()
{
using namespace Graph_lib; // наши графические средства
// находятся в пространстве
// имен Graph_lib
Point tl(100,100); // задаем левый верхний угол экрана
Simple_window win(tl,600,400,"Канва"); // создаем простое окно
Polygon poly; // создаем фигуру (многоугольник)
poly.add(Point(300,200)); // добавляем точку
poly.add(Point(350,100)); // добавляем другую точку
poly.add(Point(400,200)); // добавляем третью точку
poly.set_color(Color::red); // уточняем свойства объекта poly
win.attach (poly); // связываем объект poly с окном
}
win.wait_for_button (); // передаем управление драйверу
// дисплея
Запустив эту программу, мы увидим примерно такую картину.
Пройдемся по строкам программы и посмотрим, как она работает. Сначала
подставляем в программу заголовочные файлы нашей библиотеки графического ин-
терфейса.
#include "Simple_window.h" // открывает доступ к оконной библиотеке
#include "Graph.h" // открывает доступ к графической
// библиотеке
Затем в функции main() мы сообщаем компьютеру, что средства нашей графи-
ческой библиотеки находятся в пространстве имен Graphlib.
using namespace Graph_lib; // наши графические средства находятся
// в пространстве имен Graph__lib436 ГЛАВА 12 • ВЫВОД НА ЭКРАН
Потом определяем точку, которую будем считать координатой левого верхнего
угла нашего окна.
Point tl(100,100); // задаем координаты левого верхнего угла экрана
Затем создаем окно на экране.
Simple_window win (tl, 600,400, "Канва") ; // создаем простое окно
Для этого мы используем класс simplewindow, представляющий окно в нашей
библиотеке Graphlib. Конкретный объект класса Simple_window носит имя win;
иначе говоря, win— это переменная класса Simple_window. Список инициализа-
ции объекта win начинается с точки, которая будет использована в качестве левого
верхнего угла tl, за ней следуют числа 600 и 400. Это ширина и высота окна соот-
ветственно, измеренные в пикселях. Мы объясним их смысл позднее, а пока лишь
укажем, что они позволяют задать прямоугольник с заданными шириной и высотой.
Строка Canvas используется для пометки окна. Если присмотритесь, то увидите
слово Canvas в левом верхнем углу рамки окна.
Окно на нашем экране появится в позиции, выбранной библиотекой графическо-
го пользовательского интерфейса. В разделе 13.7.2 мы покажем, как выбрать кон-
кретную позицию, а пока просто примем то, что выберет сама библиотека; часто
этот выбор оказывается наиболее удачным.
Далее помещаем в окно некий объект.
Polygon poly; // создаем фигуру (многоугольник)
poly.add(Point(300, 200) ) ; / добавляем точку
poly.add(Point(350 100)); добавляем другую точку
oly.add(Point(400, 200) ) ; добавляем третью точку438 ГЛАВА 12 • ВЫБЙД ЙА бкРАН
Обратите внимание на то, что мы немного схитрили. А где же кнопка Next?
Мы встроили ее в классе Simplewindow. В главе 16 мы перейдем от класса Sim-'
ple_window к обьиному классу Window, в котором нет скрытых возможностей,
и покажем, как написать свой собственный код, позволяющий управлять взаимо-
действием с окном.
В следующих трех главах мы будем просто использовать кнопку Next для пере-
хода от одного дисплея к другому для отображения информации, связанной с раз-
ными этапами некоего процесса ("кадр за кадром").
Вы настолько привыкли к тому, что вокруг каждого окна операционная система
автоматически рисует рамку, что уже не замечаете ее. Рисунки в этой и следующих
главах созданы с помощью системы Microsoft Windows, поэтому в правом верхнем
углу каждого окна расположены три кнопки. Они могут быть полезными, если ваша
программа зашла в тупик (а это в ходе отладки иногда случается), вы можете пре-
кратить ее выполнение, щелкнув на кнопке со знаком х. Если вы запустите про-
грамму в другой операционной системе, рамка изменится. Наш вклад в оформление
рамки заключается лишь в создании метки (в данном случае Canvas).
12.4. Использование библиотеки графического
пользовательского интерфейса
В этой книге мы не используем непосредственно возможности графики и гра-
фического пользовательского интерфейса конкретных операционных систем.
Это ограничило бы использование наших программ одной операционной системой
и вынудило бы учитывать массу запутанных деталей. Как и для ввода-вывода тек-
стов, чтобы упростить наши программы, мы будем использовать библиотеку, сгла-
живающую различия между операционными системами, устройствами ввода-
вывода и т.д. К сожалению, язык C++ не имеет стандартной библиотеки графиче-
ского пользовательского интерфейса, аналогично библиотеке стандартных потоков
ввода-вывода, поэтому мы используем одну из многих доступных библиотек.
Поскольку нам не хотелось бы тесно привязываться ни к одной из этих библио-
тек и погружаться в тонкости их устройства, мы выделили набор простых интер-
фейсных классов, которые можно реализовать с помощью нескольких сотен строк
кода и которые можно найти практически в любой библиотеке графического поль-
зовательского интерфейса.
Набор инструментов для создания графического пользовательского интерфейса,
который мы используем в нашей книге, называется FLTK (Fast Light Tool Kit, про-
износится как "fall tick") и находится по адресу www. fltk.org. Наш код можно вы-
полнять везде, где выполняется код библиотеки (под управлением операционных
систем Windows, Unix, Mac, Linux и др.). Наши интерфейсные классы можно было
бы реализовать с помощью другой библиотеки, так что программы стали бы еще
более мобильными.
012 5 КООРДИНАТЫ
439
Модель программирования, представленная в наших интерфейсных классах, на-
много проще, чем предлагает обычный набор инструментальных средств. Напри-
мер, наша полная библиотека графических средств и графического пользователь-
ского интерфейса содержит около 600 строк кода на языке C++, в то время как
чрезвычайно немногословная документация библиотеки FLTK содержит 370 стра-
ниц. Вы можете загрузить ее с веб-сайта www. fltk.org, но мы пока не рекоменду-
ем делать это. Можно вообще обойтись без этой документации. Для создания любо-
го популярного графического пользовательского интерфейса можно использовать
идеи, изложенные в главах 12-16. Разумеется, мы объясним, как наши интерфейс-
ные классы связаны с библиотекой FLTK, так что, если захотите, сможете (в конце
концов) применить эту библиотеку непосредственно.
Части нашего "мира графики" можно представить следующим образом.
Наша программа
Наша интерфейсная библиотека
\
Библиотека графики/GUI
(в данном случае, FLTK)
X
Операционная система
(например, Windows или Linux)
Наш экран
Наши интерфейсные классы образуют простую и расширяемую основу для соз-
дания двумерных фигур с ограниченной поддержкой цвета. Для управления этими
классами предлагаем использовать простой механизм графического пользователь-
ского интерфейса, основанный на функциях обратного вызова, запускаемых кноп-
ками и другими элементами управления, расположенными на экране (подробнее
они будут рассмотрены в главе 16).
12.5. Координаты
Экран компьютера — это прямоугольная область, составленная из пикселей.
Пиксель — это маленькая цветная точка. Чаще всего экран в программе моде-
лируется как прямоугольник пикселей. Каждый пиксель имеет горизонтальную ко-
ординату х и вертикальную координату у. Начальная координата х равна нулю
и соответствует крайнему левому пикселю. Ось х направлена направо к крайнему
правому пикселю. Начальная координата у равна нулю и соответствует самому
верхнему пикселю. Ось у направлена вниз к самому нижнему пикселю.
0
0440
ГЛАВА 12 • ВЫВОД НА ЭКРАН
0,0
0,
200,0
50,50
00
100,200
K7I Пожалуйста, обратите внимание на то, что координаты у возрастают по на-
'■—■' правлению вниз. Математикам это покажется странным, но экраны (и окна,
возникающие на экране) могут иметь разные размеры, и верхняя левая точка —
это единственное, что у них есть общего.
Количество пикселей зависит от экрана: самыми распространенными являются
1024x768, 1280x1024, 1450x1050 и 1600x1200. В контексте взаимодействия с ком-
пьютером окно рассматривается как прямоугольная область экрана, имеющая опре-
деленное предназначение и управляемая программой. Окно размечается точно так
же, как и экран. В принципе окно можно интерпретировать как маленький экран.
Например, если программа содержит инструкцию
Simplewindow win(tl,600,400,"Канва");
то это значит, что мы хотим создать прямоугольную область, ширина которой равна
600 пикселям, а высота — 400, чтобы адресовать ее от 0 до 599 слева направо и от 0
до 399 сверху вниз. Область окна, которую можно изобразить на экране, называется
канвой (canvas). Область 600x400 считается внутренней областью окна, т.е. область,
расположенной в системном кадре; она не содержит строки заголовка, кнопок вы-
хода и пр.
12.6. Класс Shape
Наш основной набор инструментов для рисования на экране состоит из двена-
дцати классов.
Стрелка означает, что класс, из которого она выходит, может быть использован
там, где требуется класс, на который она указывает. Например, класс Polygon мо-
Window
Line.style
Simple_window
Shape
Color
Point
Une J [ Lines j [ Polygon J [Axis J I Rectangle Text [ hn*qe12 7 ИСПОЛЬЗОВАНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ
441
жет быть использован там, где требуется класс Shape; иначе говоря, класс Polygon
является разновидностью класса Shape.
Сначала опишем использование следующих классов:
• Simplewindow, Window
• Shape, Text, Polygon, Line, Lines, Rectangle, Function и Т.Д.
• Color, Linestyle, Point
• Axis
Позднее (в главе 16) добавим к ним классы графического пользовательского
интерфейса:
• Button, In_box, Menu И Т.Д.
К этому набору можно было бы более или менее легко добавить много других
классов, например
• Spline, Grid, Block_chart, Pie_chart и т.д.
Однако описание полного набора инструментов для создания графического
пользовательского интерфейса со всеми его возможностями выходит за рамки на-
шей книги.
12.7. Использование графических примитивов
В этом разделе мы рассмотрим некоторые элементарные примитивы нашей гра-
фической библиотеки: Simple_window, Window, Shape, Text, Polygon, Line,
Lines, Rectangle, Color, Linestyle, Point, Axis. Цель этого обзора — дать чи-
тателям представление о том, что можно сделать с помощью этих средств без уг-
лубления в детали реализации этих классов. Каждый из этих классов будет подроб-
но изучен в следующих главах.
Начнем с простой программы, объясняя ее строчка за строчкой и демонстрируя
результаты ее работы на экране. Когда вы запустите эту программу, то увидите, как
изменяется изображение при добавлении новых и модификации существующих фи-
гур, расположенных в окне. В принципе такой анализ напоминает анимацию.
12.7.1. Графические заголовочные файлы и функция main
Во-первых, включим заголовочные файлы, в которых определены графические
классы и класс графического пользовательского интерфейса.
#include "Window.hn // обычное окно
#include "Graph.h"
или
#include nSimple_window.hn // если нам нужна кнопка Next-
#include "Graph.h"442
ГЛАВА 12 • ВЫВОД НА ЭКРАН
Как вы, возможно, уже догадались, файл window.h содержит средства, связан-
ные с окнами, а файл Graph.h - инструменты, связанные с рисованием фигур
(включая текст) в окне. Эти средства определены в пространстве имен Graph_lib.
Для упрощения обозначений мы используем директиву using namespace, чтобы
получить доступ к именам из пространства Graph_lib.
using namespace Graph_lib;
Как обычно, функция main() содержит код, который мы хотим выполнить
(прямо или косвенно), а также обработку исключительных ситуаций.
int main ()
try
{
II... здесь находится наш код . . .
}
catch(exception& e) {
// сообщения об ошибках
return 1;
}
catch(...) {
// другие сообщения об ошибках
return 2;
}
12.7.2. Почти пустое окно
Здесь мы не будем обсуждать обработку ошибок (см. главу 5, в частности раз-
дел 5.6.3), а сразу перейдем к описанию графики в функции main ():
Point tl(100#100); // левый верхний угол нашего окна
Simple_window win(tl,600,400,"Канва");
// координаты окна tl задают положение левого верхнего угла
// размер окна 600*400
// заголовок: Canvas
win.wait_for_button() ; // изобразить!
Этот фрагмент программы создает объект класса Simple_window, т.е. окно
с кнопкой Next, и выводит его на экран. Очевидно, что для создания объекта класса
simpiewindow нам необходима директива #include, включающая в программу
заголовочный файл simple_window.h, а не window.h. Здесь мы указываем, в каком
месте экрана должно появиться окно: его левый верхний угол должен находиться в
точке Point (100,100). Это близко, но не очень близко к левому верхнему углу эк-
рана. Очевидно, что Point — это класс, конструктор которого получает пару целых
чисел и интерпретирует их как пару координат (х, у). Эту инструкцию можно было
бы написать так:
Simpiewindow win(Point(100,100) ,600,400,"Канва");
Однако мы хотим использовать точку (100, 100) несколько раз, поэтому удобнее
присвоить ей символическое имя. Число 600 — это ширина окна, 400 — его высота,
а строка "канва' — метка, которую мы хотим поместить на рамке окна.2 7 ИСПОЛЬЗОВАНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ
443
Для того чтобы окно действительно было нарисовано на экране, мы должны пе-
редать управление системе графического пользовательского интерфейса. Для этого
вызываем функцию win.wait_for_button(). Результат показан на следующем
рисунке.
=*) На фоне нашего окна мы видим экран ноутбука (на всякий случай очищенный
=1 от лишних пиктограмм). Для любопытных людей, интересующихся деталями,
не относящимися к делу, сообщаю, что эту фотографию я сделал, стоя возле библио-
теки Пикассо в Антибе и глядя через залив на Ниццу. Черное консольное окно, час-
тично скрытое нашим окном, автоматически открывается при запуске нашей про-
граммы. Консольное окно выглядит некрасиво, но позволяет эффективно закрыть на-
ше окно при отладке программы, если мы попадем в бесконечный цикл и не сможем
выйти из программы обычным способом. Если внимательно присмотреться, то можно
заметить, что мы использовали компилятор Microsoft C++, но вместо него можно бы-
ло бы использовать любой другой компилятор (например, Borland или GNU).
Для дальнейшей демонстрации нашей программы мы удалили с экрана все лиш-
нее, оставив только само окно (см. ниже).
Реальный размер окна (в дюймах) зависит от разрешающей способности вашего
экрана. Кроме того, на некоторых экранах размер пикселей больше, чем на других.
12.7.3. Оси координат
Практически пустое окно не очень интересно, поэтому попробуем добавить в не-
го какую-нибудь информацию. Что бы мы хотели изобразить? Давайте вспомним,
что графика — это не только игры и развлечения, и сделаем что-нибудь серьезное444
ГЛАВА 12 • ВЫВбД ЙА &КРАН
i/ *
V. f ^
.A ■ ■, V ft
r ./ -r rl™4? '<?Jji -■■■ . •.' *
1 , •».
JM1?
Л ■" ' * I.
r^i"
.-' h
L
it ^ч t
:)/
I 1 mi
и сложное, например оси координат. График без осей координат, как правило, ужа-
сен. Невозможно себе представить, какие данные можно изобразить, не пользуясь
осями координат. Может быть, вам удастся оправдать это в приложении к програм-
ме, но намного лучше добавить оси координат; люди часто не читают объяснений,
а хорошее графическое представление обычно не нуждается в комментариях. Итак,
нам необходимы координатные оси.
Axis xa(Axis::x, Point (20,300) , 280, 10, "Ось х") ; // создаем
// объект Axis
// класс Axis — разновидность класса Shape
// Axis::x означает горизонтальную ось
// начало оси — в точке (20,300)
// длина оси — 280 пикселей 10 делений
// "Ось х" — метка оси
Jr'itmrnfteaBJ
1
I, II !_
a.<s
J 1 112 7 ИСПОЛЬЗОВАНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ
445
win attach(xa)•
win setlabel("Канва #2n);
win wait for buttonO ;
// связываем объект ха с окном win
// изменяем метку окна
// изобразить!
Последовательность действий такова: создаем объект класса Axis, добавляем его
в окне и выводим на экран.
Как видим, параметр Axis: :x задает горизонтальную линию. Кроме того, ось
имеет десять делений и метку "Ось х". Как правило, метка объясняет, что представ-
ляет собой ось и ее деления. Естественно, ось х следует выбирать где-то ближе к
нижнему краю окна. В реальной программе мы обозначили бы ширину и высоту ка-
кими-нибудь символическими константами, чтобы придать фразе "где-то ближе
к нижнему краю окна" конкретный смысл, например, выраженный в виде инструк-
ции y_max-bottom_margin, и не использовали бы "магические константы", такие
как 3 00 (см. раздел 4.3.1, раздел 15.6.2).
Для того чтобы идентифицировать результаты, мы изменили метку экрана
на строку Канва #2 с помощью функции-члена set_label() класса Window.
Теперь добавим ось у.
Axis ya(Axis::y, Point(20,300), 280
ya.setcolor(Color::cyan);
ya. label.set_color(Color::darkred)
win.attach(ya);
win.setlabel("Канва #3");
win.wait for buttonO;
10, "ось у");
// выбираем цвет
// выбираем цвет текста
// изобразить!
Просто для того чтобы продемонстрировать некоторые возможности, мы раскра-
сили ось у в голубой цвет (cyan), а метку сделали темно-красной.
На самом деле мы не считаем удачной идею присваивать разные цвета осям*
и у. Мы просто хотели показать, как можно задать цвет фигуры и ее отдельных эле-
Canvas #3
алз
UJmLj
..> i <l рщ I. I . I I i< и ). и" it it—ни .> .п. 1,1,1 . t I . it
xaxts t
JHMiментов. Использование большого количества цветов не всегда оправдано. В часто-
сти, новички часто злоупотребляют раскраской графиков, демонстрируя избыток
энтузиазма и недостаток вкуса.
12.7.4. График функции
Что дальше? Теперь у нас есть окно с координатными осями, и кажется естест-
венным нарисовать на нем график функции. Создадим фигуру, представляющую
график синуса, и свяжем ее с окном.
Function sine(sin,0,100,Point(20,150),1000,50,50) ; // график синуса
// рисуем sin() в диапазоне [0:100) от (0,0) до (20,150),
// используя 1000 точек; для масштабирования координаты
// умножаются на 50
win.attach(sine) ;
win. setlabeK "Канва #4");
win.wait_for_button();
Здесь объект класса Function с именем sine рисует график синуса, используя
стандартную библиотечную функцию sin О. Детали построения графиков функций
излагаются в разделе 15.3. А пока отметим, что для построения такого графика не-
обходимо выбрать отправную точку (объект класса Point), диапазон изменения
входных значений, а также указать некоторую информацию, чтобы график помес-
тился в окне (масштабирование).
Теперь кривая будет заканчиваться на краю окна. Точки, изображенные за пре-
делами окна, игнорируются системой графического пользовательского интерфейса
и остаются невидимыми.12 7 ИСПОЛЬЗОВАНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ
447
12.7.5. Многоугольники
График функции является примером представления данных. Подробно эта тема
исследуется в главе 15. Однако в окне можно рисовать и другие объекты, например
геометрические фигуры. Эти фигуры используются для создания графических ил-
люстраций, рисования элементов пользовательского интерфейса (например, кнопок)
и просто для украшения результатов работы программы. Объект класса Polygon за-
дается последовательностью точек, соединенных линиями. Первая линия соединяет
первую точку со второй, вторая линия соединяет вторую точку с третьей, а послед-
няя линия соединяет последнюю точку с первой,
sine.setcolor(Color::blue); // мы изменили цвет графика синуса
Polygon poly; // класс Polygon - это разновидность класса Shape
poly.add(Point(300,200)); // три точки образуют треугольник
poly.add(Point(350,100));
poly.add(Point(400,200));
poly.set_color(Color::red);
poly.setstyle(Line_style::dash);
win.attach(poly);
win.set_label("Канва #5");
win.wait_for_button();
На этот раз мы изменили цвет графика синуса (sine) просто для того, чтобы по-
казать, как это делается. Затем мы добавили треугольник, так же как в первом при-
мере из раздела 12.3, представляющий собой разновидность многоугольника. Здесь
мы также задали цвет и стиль. Линии в классе Polygon имеют стиль. По умолчанию
они сплошные, но их можно сделать пунктирными, точечными и т.п. (подробнее
об этом — в разделе 13.5). Итак, мы получаем следующий результат.щ
12.7.6. Прямоугольник
Экран— это прямоугольник, окно— это прямоугольник и лист бумаги —
это прямоугольник. Фактически огромное количество фигур являются прямоуголь-
никами (или прямоугольниками с закругленными углами), потому что это простей*
шая фигура. Например, его легко описать (координаты левого верхнего угла, шири-
на и высота, или координаты левого верхнего и правого нижнего углов), как в нем,
так и за его пределами легко задать местоположение точки. Кроме того, его можно
легко и быстро нарисовать на экране. По этой причине большинство высокоуровне-
вых графических библиотек эффективнее работают с прямоугольниками, чем с лю-
быми другими замкнутыми фигурами. Следовательно, целесообразно описать пря-
моугольник с помощью отдельного класса Rectangle, отделив его от класса
Polygon. Класс Rectangle характеризуется координатами верхнего левого угла,
шириной и высотой.
Rectangle г(Point(200,200), 100, 50); // левый верхний угол, ширина,
// высота
win.attach(г) ;
win. setlabeK "Канва #6");
win.wait for button();
Этот фрагмент открывает на экране следующее окно.
j i ,, i i j * i ■ i.i
a. is
I I
Обратите, пожалуйста, внимание на то, что нарисовать ломаную, соединяющую
четыре точки, для создания объекта класса Rectangle еще недостаточно. Легко
южно создать объект класса ciosed_polyline, который на экране выглядит как
объект класса Rectangle (можно даже создать объект класса Openjpolyline,
который б дет выглядеть точно так же)1 ИСПОЛЬЗО АНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ
449
lo ed_p lyline poly_rect;
pol rect.add(Point(100,50));
pol rect.add(Point(200,50));
poly_rect.add(Point(200,100));
poly_ ect add(Point(100,100));
Изображение (image) объекта poly_rect на экране действительно является
прямоугольником. Однако объект класса poly_rect в памяти не является объектом
класса Rectangle и не "знает" ничего о прямоугольниках. Проще всего это дока-
зать, попытавшись добавить новую точку,
polyrect.add(Point(50,75));
Прямоугольник не может состоять из пяти точек.
i~ I I, , I ,1 L , ,1 ,. , I, .1 )
xaxis
1 „ I , 1,. I ) U Л~?—I—„i 1 1-•so
Важно понимать, что объект класса Rectangle должен не только выглядеть как
прямоугольник на экране, он должен также обладать его геометрическими свойст*
вами. Наша программа существенно использует то обстоятельство, что объект клас-
са Rectangle действительно является прямоугольником.
12.7.7. Заполнение
До сих пор наши фигуры были нарисованы схематично. Их можно заполнить
цветом.
r.set_fill_color (Color: :yellow) ; // цвет внутри прямоугольника
poly.set_style(Line_style (Line_style: :dash, 4)) ;
poly_rect.set_style(Line_style(Line_style:;dash,2)) ;
poly_rect.set_fill_color(Color::green) ;
win.set_label("Канва #7И);
win.wait for button();
Мы также решили, что прежний стиль линии в нашем треугольнике (poly) нам
не нравится, и изменили его на жирный пунктир (в четыре раза толще обычного
пунктира). Аналогично мы изменили стиль объекта polyrect (теперь он не вы-
глядит как прямоугольник).
Если внимательно присмотреться к объекту polyrect, то можно увидеть,
что он рисуется поверх заполнения.
Заполнить цветом можно любую замкнутую фигуру (рис. 13.9). Прямоугольники
просто весьма удобны для этого.
12.7.8 Текст
В заключение укажем, что ни одна система, рисующая графические изображе-
ния не ожет считаться полной, если она не способна выводить текст про-
м сп собом — вырисовывание каждого символа с помощью набора линий
012 7 ИСПОЛЬЗОВАНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ 451
■ ■ * < ■ I——l_—1 i _j
xaxs
в расчет не принимается. Мы приписываем окну метку, оси также могут иметь мет-
ки, но помимо этого мы можем вывести текст в любое место окна, используя объект
класса Text.
Text t(Point(150,150), "Привет, графический мир! ") ;
win.attach(t);
win.setlabel("Канва #8");
win.wait_for_button();
Из элементарных графических элементов, показанных в этом окне, можно соз-
дать сколь угодно сложные и утонченные фигуры. Пока мы просто отметим особен-
ность кода в этой главе: они не содержат циклов, условных конструкций, а все дан-
ные в них встроены. Выходная информация скомпонована из примитивов простей-
шим образом. Как только мы начнем составлять из этих примитивов сложные
фигуры с помощью данных и алгоритмов, все станет намного интереснее.
Мы видели, как можно управлять цветом текста: метка оси (см. раздел 12.7.3)
просто представляет собой объект класса Text. Кроме того, мы можем выбирать
шрифт и размер символов.
t.set_font(Font::times_bold);
t.set_font_size(20);
win.set_label("Канва #9");
win.wait_for_button();
Здесь мы увеличили буквы в строке "Привет, графический мир!" до 20 пунктов
и выбрали жирный шрифт Times.
12.7.9. Изображения
Мы можем также загружать изображения из файлов.452
" »«|
Image ii(Point(100,50),"image.jpg"); // файл 400x212 пикселей
//в формате jpg
win.attach(ii) ;
win.set_label("Канва #10");
win.wait_for_button();
Файл image, jpg — это фотография двух самолетов, преодолевающих звуковой
барьер.
Эта фотография относительно велика и размещается поверх нашего текста и фи-
гур. Итак, рисунок требуется немного улучшить. Для этого мы немного сдвинем фо-
тографию.
Canvas #9
зеш12 7 ИСПОЛЬЗОВАНИЕ ГРАФИЧЕСКИХ ПРИМИТИВОВ
453
li.move(100,200);
win.setlabel("Канва #11");
win.waitforbuttonO ;
Обратите внимание на то, что части фотографии, не попавшие в окно, не пред-
ставлены на экране, поскольку то, что выходит за его пределы, обрезается.
12.7.10. И многое другое
Приведем без объяснений еще один фрагмент кода
Circle c(Point(100,200) ,50) ;
Ellipse e(Point(100,200), 75,25);
e.setcolor(Color::dark_red);
Mark m(Point(100,200),'x');
ostringstream oss;
oss << "screen size: " << x_max() << "*" << y_max()
<< "; window size: " << win.x_max() << "*" << win.y_max();
Text sizes(Point(100,20),oss.str());
Image cal(Point(225,225),"snow_cpp.gif"); // 320*240 пикселей,
// формат gif
cal.set mask(Point(40,40),200,150); // отобразить рисунок
// в центре
win.attach(c);
win.attach(m) ;
win.attach(e);
win.attach(sizes);
win.attach(cal);43*»
I ЛАБА 12 ■ ииюиДМЯчЭКРАП
win.set_label("Канва #12");
win.wait for buttonQ;
Можете ли вы догадаться, что делает этот фрагмент?
=*| Между кодом и тем, что появляется на экране, существует прямая связь.
=1 Даже если вам пока непонятно, как этот код приводит к таким результатам,
то вскоре все станет ясно. Обратите внимание на то, что для форматирования тек-
стовых объектов, содержащих информацию о размерах, мы использовали поток
stringstream (см. раздел 11.4).
12.8. Запуск программы
Мы показали, как можно создать окно и нарисовать в нем разные фигуры. В сле-
дующих главах мы покажем, как определен класс Shape и его подклассы, а также
как их использовать.
Для того чтобы выполнить эту программу, требуется больше, чем для других
программ, описанных ранее. Помимо кода в функции main О, нам необходимо
скомпилировать код интерфейсной библиотеки и связать его с нашей программой,
но даже в этом случае программа не будет работать, пока на компьютере не будет
установлена библиотека FLTK (или другая система графического пользовательского
интерфейса).
Итак, можно сказать, что наша программа состоит из четырех частей.
• Код нашей программы (main () и т.д.).
• Наша интерфейсная библиотека (window, Shape, Polygon и т.д.).
• Библиотека FLTK library
• С анд ртная библиотека языка C++12 8 ЗАПУСК ПРОГРАММЫ
455
Кроме того, мы неявно используем операционную систему. Оставляя в стороне
операционную систему и стандартную библиотеку, мы можем проиллюстрировать
организацию графической программы следующим образом.
Point.h:
struct Point {...};
Graph.h:
Заголовочные
файлы FLTK
Window.h:
//графический интерфейс
struct Shape {...};
//оконный интерфейс
class Window {...};
window.cpp:
Graph, cpp:
Graph code
Window code
Simple.window.h:
Код библио-
теки FLTK
GUI.h:
//GUI интерфейс
struct In.box {...};
GUI.cpp:
//оконный интерфейс
class Simple.window {...};
GUI code
chapter12.cpp:
«Include "Graph.h"
♦include "Simple.window.h"
Int main() {...}
Как заставить эту программу работать, объясняется в приложении Г.
12.8.1. Исходные файлы
Наша библиотека графики и графического пользовательского интерфейса состо-
ит лишь из пяти заголовочных и трех исходных файлов.
• Заголовки
• Point.h
• Window.h
• Simple_window.h
• Graph.h
• GUI.h
До главы 16 мы можем игнорировать файлы графического пользовательского
интерфейса.
Исходные файлы
• Window.cpp
• Graph.cpp
• GUI.cpp-*5©
NIHUM IH IIIIIHlin VUCJUf
Задание
Это задание напоминает программу "Привет, мир!". Его цель —* ознакомить вас
с простейшими графическими средствами.
1. Напишите программу, создающую пустой объект класса Simplewindow разме-
ром 600x400 пикселей с меткой Мое окно, скомпилируйте ее, отредактируйте
связи и выполните. Помните о том, что вы должны подключить библиотеку
FLTK, описанную в приложении Г, выполнить директивы #include Graph.h,
window.h, и GUl.h в вашем коде, а также включить в проект файлы Graph.срр
и Window, cpp.
2. Добавьте примеры из раздела 12.7 один за другим, сравнивая их друг с другом.
3. Выполните программу, внеся небольшие изменения (например, измените цвет,
местоположение фигур или количество точек) в каждом из примеров.
Контрольные вопросы
1. Зачем нужна графика?
2. Почему нельзя обойтись без графики?
3. Чем графика интересна программисту?
4. Что такое окно?
5. В каком пространстве имен находятся наши классы графического интерфейса
(наша графическая библиотека)?
6. Какие графические файлы необходимы для использования графических средств
из нашей библиотеки?
7. Что представляет собой простейшее окно?
8. Что представляет собой минимальное окно?
9. Что такое метка окна?
10. Как задать метку окна?
11. Что собой представляют экранные, оконные и математические координаты?
12. Приведите примеры простых фигур, которые можно отобразить на экране.
13. Какие команды связывают фигуру с окном?
14. Какие основные фигуры можно использовать для того, чтобы нарисовать шес-
тиугольник?
15. Как вывести текст в окне?
16. Как поместить в окне фотографию вашего лучшего друга или подруги? Напи-
шите свою программу.
17. Представьте, что вы создали объект класса window, но на экране ничего не поя-
вилось Перечислите возможные причины.
18 Представьте, что вы создали объект класса shape, но на экране ничего не поя-
вилось. Перечислите возможные причины.ТЕРМИНЫ
457
Термины
HTTP
JPEG
XML
библиотека FLTK
библиотека графического
пользовательского интерфейса
графика
графический пользова-
тельский интерфейс
дисплей
заполнение цветом
изображение
координаты
окно
слой программного
обеспечения
стиль линии
цвет
Упражнения
Для выполнения приведенных ниже изображений рекомендуем использовать
класс Simple_window.
1. Нарисуйте прямоугольник как объект класса Rectangle и как объект класса
Polygon. Сделайте линии объекта класса Polygon красными, а линии объекта
класса Rectangle синими.
2. Нарисуйте объект класса Rectangle с размерами 100x300 и поместите в него
слово "Привет!".
3. Нарисуйте ваши инициалы высотой 150 пикселей. Используйте толстую линию.
Нарисуйте каждый инициал другим цветом.
4. Нарисуйте доску для шахмат 8x8, чередуя белые и красные квадраты.
5. Нарисуйте красную рамку шириной один дюйм вокруг прямоугольника, высота
которого составляет три четверти высоты вашего экрана, а ширина — две трети
ширины экрана.
6. Что произойдет, если вы нарисуете фигуру, которая не помещается в окне? Что
произойдет, если вы нарисуете окно, которое не помещается на экране? Напи-
шите две программы, иллюстрирующие эти эффекты.
7. Нарисуйте двумерный дом анфас, как это делают дети: дверь, два окна и крыша
с дымовой трубой. Детали можете выбрать сами, можете даже нарисовать ды-
мок из трубы.
8. Нарисуйте пять олимпийских колец. Если помните их цвета, то раскрасьте их.
9. Выведите на экран фотографию вашего друга. Напишите его имя в заголовке
окна и в заголовке внутри окна.
10. Нарисуйте диаграмму файлов из раздела 12.8.
11. Нарисуйте ряд правильных многоугольников, вложенных друг в друга. Наибо-
лее глубоко вложенный многоугольник должен быть равносторонним треуголь-
ником, вложенным в квадрат, вложенный в пятиугольник, и т.д. Для любителей
математики: пусть все точки каждого N-многоугольника касаются сторон (N+1) -
многоугольника.458 ГЛАВА 12 • ВЫВОД НА ЭКР,
12. Суперэллипс — это двумерная фигура, определенная уравнением
m л
Х У л
— +— =1, т,п>0.
13. Поищите в веб информацию о суперэллипсе, чтобы лучше представит его себе*
Напишите программу, которая рисует звездообразные шаблоны, соединяя точ-
ки, лежащие на суперэллипсе. Пусть параметры а, Ь, m, n и N вводятся как аргу-
менты. Выберите N точек на суперэллипсе, определенном параметрами a, b, a
и п. Пусть эти точки лежат на равном расстоянии друг от друга. Соедините каж-
дую из этих N точек с одной или несколькими другими точками (если хотите,
можете задать количество таких точек с помощью дополнительного аргумент*
или использовать число N-1, т.е. все другие точки).
14. Придумайте способ раскрасить суперэллипс из предыдущего упражнения,
Нарисуйте разные линии разным цветом.
Послесловие
В идеальном проекте каждая сущность непосредственно представляется
в программе. Часто мы выражаем наши идеи в виде классов, реальные ве-
щи — в виде объектов классов, а действия и вычисления — в виде функций. Графи-
ка — это область, в который эта мысль нашла очевидное воплощение. У нас есть
понятия, например окружности и многоугольники, и мы выражаем их в программе
в виде классов, например Circle и Polygon. Графика отличается от других прило-
жений тем, что, создавая графические программы, программист может сразу видеть
объекты классов на экране. Иначе говоря, состояние такой программы непосредст-
венно доступно для наблюдения — в большинстве приложений этой возможности
мы лишены. Это непосредственное соответствие между идеями, кодом и выводом
делает программирование графики очень привлекательным. Однако помните, что
графика — это лишь иллюстрация общей идеи использования классов для выраже-
ния основных понятий в виде кода. Эта идея носит намного более общий характер:
все наши идеи могут быть выражены в коде либо в виде класса, либо в виде объекта
класса, либо в виде совокупности классов. чГрафические классы
"Язык, не изменяющий ваш образ мышления,
изучать не стоит".
Расхожее мнение
В главе 12 описано, что можно сделать с помощью графики и набора
простых интерфейсных классов и как это сделать. В этой главе рас-
сматриваются многие из этих классов. Она посвящена проектированию, ис-
пользованию и реализации индивидуальных интерфейсных классов, таких как
Point, Color, Polygon и Open_polyline, а также методам их использова-
ния. В следующей главе будут изложены идеи, связанные с проектированием
связанных классов, а также описаны другие их методы реализации.460
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
В этой главе...
13.1. Обзор графических классов
13.2. Классы Point и Line
13.3. Класс Lines
13.4. Класс Color
13.5. Класс Line_style
13.6. Класс Open_polyline
13.7. Класс Closed_polyline
13.8. Класс Polygon
13.9. Класс Rectangle
13.10. Управление неименованными объектами
13.11. Класс Text
13.12. Класс Circle
13.13. Класс Ellipse
13.14. Класс Marked_polyline
13.15. Класс Marks
13.16. Класс Mark
13.17. Класс Image
13.1. Обзор графических классов
Библиотеки графики и графического пользовательского интерфейса предостав-
ляют множество возможностей. Слово "множество" означает сотни классов, часто
содержащих десятки функций. Их описания, справочные руководства и документа-
ция напоминают учебники по ботанике, в которых перечислены тысячи растений,
упорядоченных в соответствии с устаревшей классификацией. Это обескураживает!
Обзор возможностей совершенных библиотек графики и графического пользова-
тельского интерфейса может быть увлекательным занятием. Он может вызвать
у читателей ощущения ребенка, попавшего в кондитерскую лавку и не понимающе-
го, с чего начать и понравится ли ему то, что он выберет.
Цель нашей интерфейсной библиотеки— компенсировать шок, вызванный
сложностью библиотек графики и графического пользовательского интерфейса.
Мы опишем только два десятка классов с немногими операциями. Тем не менее они
позволяют создавать полезные графические приложения. Кроме того, эти классы
позволяют ввести ключевые понятия графики и графического пользовательского
интерфейса. С их помощью читатели уже могут представлять результаты своей ра-
боты в виде простых графиков. Прочитав эту главу, вы сможете расширить спектр
своих приложений и удовлетворить больше требований. Прочитав к тому же гла-
ву 14, вы освоите основные идеи и методы проектирования, которые позволят вам
глубже разобраться в графических библиотеках и создать еще более сложные при-
ложения. Этого можно достичь либо включив в свои программы описанные здесь
классы, либо адаптировав другие библиотеки графики и графического пользова-
тельского интерфейса.
Основные интерфейсные классы перечислены в следующей таблице.
Интерфейсные графические классы
Color
Line_style
Point
Используется для создания линий, текста и заполнения фигур
Используется для рисования линий
Используется для задания местоположения на экране и внутри
объекта класса Window13 1 ОБЗОР ГРАФИЧЕСКИХ КЛАССОВ
461
Окончание таблицы
Интерфейсные графические классы
Line
Open_polyline
Closedpolyline
Polygon
Text
Lines
Rectangle
Circle
Ellipse
Function
Axis
Mark
Marks
Marked_polyline
Image
Отрезок линии, видимый на экране, определенный двумя объектами
класса Point
Последовательность соединенных друг с другом отрезков линий, опре-
деленная последовательностью объектов класса Point
Похож на класс Open_polyline, за исключением того, что отрезок
линии соединяет последний объект класса Point с первым
Класс Closed_polyline, в котором никакие два отрезка никогда не
пересекаются
Строка символов
Набор отрезков линии, определенных парой объектов класса Point
Фигура, оптимизированная для быстрого и удобного отображения
Окружность, определенная центром и радиусом
Эллипс, определенный центром и двумя осями
Функция одной переменной, заданная в определенном отрезке
Помеченная ось координат
Точка, помеченная символом (например, х или о)
Последовательность точек, помеченных символами (например,
х или о)
Класс Open_polyline с точками, помеченными символами
Содержание файла изображений
Классы Function и Axis описываются в главе 15. В главе 16 рассматриваются
основные интерфейсные классы.
Класс графического пользовательского интерфейса
Window
S implewindow
Button
Inbox
Outbox
Menu
Область экрана, на которой отображаются графические объекты
Окно с кнопкой Далее
Прямоугольник в окне, обычно помеченный, нажав на который можно
вызвать одну из наших функций
Область в окне, обычно помеченная, в которой пользователь может
ввести строку
Область в окне, обычно помеченная, в которой приложение может вы-
вести строку
Вектор объектов класса Button
Исходный код состоит из следующих файлов.
Исходные интерфейсные графические файлы
Point, h
Graph. h
Класс Point
Все остальные графические интерфейсные классы462 ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
Окончание таблицы
Исходные интерфейсные графические файлы
I ■ I ■ ■ И — --—— ■ ■■ ■ —- ■ ■■■■- — . ■ ■ — ■ , . ■ I Ш М Ш+^ШШ*
Window. h Класс Window
Simple_window.h Класс Simple_window
GUI. h Button Все остальные классы графического пользовательского интерфейса
Graph. ерр Определения функции из файла Graph. h
Window. сер Определения функции из файла Window. h
GUI. ерр Определения функции из файла GUI. h
Кроме графических файлов, мы опишем класс, который может оказаться полез-
ным для создания коллекций объектов класса Shape или Widget.
Контейнер объектов класса Shape или Widget
Vector_ref Вектор с интерфейсом, обеспечивающий удобное хранение
неименованных элементов
Читая следующие разделы, не торопитесь, пожалуйста. Они не содержат ничего
такого, что не было бы совершенно очевидным, но цель этой главы — не просто
продемонстрировать несколько красивых рисунков — на экране своего компьютера
или телевизора вы каждый день можете увидеть более красивые изображения»
Основные цели этой главы перечислены ниже.
• Продемонстрировать связь между кодом и создаваемыми рисунками.
• Научить вас читать программы и размышлять над тем, как они работают.
• Научить вас размышлять о проектировании программ, в частности о том, как
выразить понятия в виде классов. Почему эти классы устроены так, а не ина-
че? Как еще их можно было бы написать? Вы можете принять много-много
проектных решений, и в большинстве своем они будут отличаться от наших
незначительно, а в некоторых случаях — кардинально.
Итак, пожалуйста, не торопитесь, иначе пропустите нечто важное и не сможете
выполнить упражнения.
13.2. Классы Point и Line
Самой главной частью любой графической системы является точка. Определив
это понятие, вы определите все ваше геометрическое пространство. В данной книге
1Ы используем обычное, компьютерно-ориентированное двумерное представление
точек в виде пары целочисленных координат (х, у). Как указано в разделе 12.5»
координаты х изменяются от нуля (левого края экрана) до тах_х () (правого Края
экрана), координаты у изменяются от нуля (верхнего края экрана) до maxjfO
н 1жнего края экрана)13 2 КЛАССЫ POINT И LINE
463
Как определено в файле Point.h, класс Point— это просто пара чисел типа
int (координаты).
struct Point {
int x, у;
Point(int хх, int yy) : x(xx), у(уу) { }
PointO :x(0), y(0) { }
};
bool operator==(Point a. Point b) { return a.x==b.x && a.y==b.y; }
bool operator!»(Point a, Point b) { return I(a==b); }
В файле Graph.h определены также класс Shape, подробно описанный в гла-
ве 14, и класс Line.
struct Line : Shape { // класс Line — это класс Shape,
// определенный двумя точками
Line(Point pi. Point p2); // создаем объект класса Line
// из двух объектов класса Points
};
Класс Line— это разновидность класса Shape. Именно это означает строка ":
Shape". Класс Shape называют базовым (base class) по отношению к классу Line.
В принципе класс Shape содержит возможности, чтобы упростить определение
класса Line. Как только мы столкнемся с конкретными фигурами, например Line
или Openjpolyline, то увидим, что это значит (см. главу 14).
Класс Line определяется двумя объектами класса Point. Оставляя в стороне
"леса" (директивы #include и прочие детали, описанные в разделе 12.3), мы можем
создать линию и нарисовать ее на экране.
// рисуем две линии
Simplewindow winl(Point(100,100),600,400,"две линии");
Line horizontal(Point(100,100),Point(200,100)); // горизонтальная
// линия
Line vertical(Point(150,50),Point(150,150)); // вертикальная
// линия
winl.attach(horizontal); // связываем их
//с экраном
winl.attach(vertical);
winl.wait_for_button(); // изобразить!
Выполнив этот фрагмент кода, получим на экране следующее изображение.
Пользовательский интерфейс предназначен для того, чтобы упростить работу,
и класс Line довольно неплохо справляется с этим заданием. Не нужно быть
Эйнштейном, чтобы понять, что инструкция
Line vertical (Point (150, 50) ,Point(150,150));
создает (вертикальную) линию, соединяющую точки (150,50) и (150,150). Разумеет-
ся, существуют детали реализации, но вам необязательно знать их, чтобы создавать
линии. Реализация конструктора класса Line довольно проста.464
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
Line: :Line (Point pi, Point p2) // создаем линию по двум точкам
{
add(pl); // добавляем точку pi
add(p2); // добавляем точку р2
}
Иначе говоря, конструктор просто добавляет две точки. Добавляет куда? И как
объект класса Line рисуется в окне? Ответ кроется в классе Shape. Как будет опи-
сано в главе 14, класс Shape может хранить точки, определяющие линии, знает, как
рисовать линии, определенные парами точек, и имеет функцию add (), позволяю-
щую добавлять объекты в объекты класса shape. Основной момент здесь заключа-
ется в том, что определение класса Line тривиально. Большая часть работы по реа-
лизации выполняется системой, поэтому программист может сосредоточиться
на создании простых классов, которые легко использовать.
С этого момента оставим в стороне определение класса simplewindow и вызо-
вы функции attach (). Они не более чем "леса", необходимые для завершения про-
граммы, но ничего не добавляющие к специфике объектов класса Shape.
13.3. Класс Lines
Оказывается, что мы редко рисуем отдельную линию. Как правило, мы пред-
ставляем себе объекты, состоящие из многих линий, например треугольники, мно-
гоугольники графы, лабиринты, сетки, диаграммы, графики математических функ-
ции и т.д. Одним из простейших компонентов этих составных графических объек-
т в являются объекты класса Lines.
struct Lines : Shape { // связанные друг с другом линии
oid dra lines() const;13 3 КЛАСС LINES
465
void add(Point pi. Point p2); // добавляем линию, заданную
// двумя точками
}'
Объект кла са Lines представляет собой коллекцию линий, каждая из которых
определен п рой объектов класса Point. Например, если бы мы рассматривали две
линии из примера в разделе 13.2 как часть отдельного графического объекта,
то могли бы дать такое определение:
Lines x;
x.add(Point(100,100), Point(200,100)); // первая линия:
// горизонтальная
x.add(Point(150,50) , Point(150,150)); // вторая линия: вертикальная
В этом случае мы получили бы совершенно такой же результат (вплоть до по-
следнего пикселя), как и в варианте с классом Line.
im^rV.
L^JfeA-J
Единственный способ, который позволяет различить эти варианты,— создать
отдельное окно и приписать ему другую метку.
Г7Т Разница между совокупностью объектов класса Line и совокупностью линий
^~* в объекте класса Lines заключается лишь в нашей точке зрения на то, что
должно произойти. Используя класс Lines, мы выражаем наше мнение, что две ли-
нии образуют одно целое и должны обрабатываться одновременно. Например, мы
можем изменить цвет всех линий, являющихся частью объекта Lines, с помощью
одной команды. С другой стороны, мы можем присвоить каждой линии, являющей-
ся отдельным объектом класса Line, разные цвета. В качестве более реалистичного
примера рассмотрим определение сетки. Сетка состоит из большого количества го-
ризонтальных и вертикальных линий, проведенных на одинаковых расстояниях
друг от друга. Однако мы считаем сетку одним целым, поэтому определяем ее ли-
нии как части объекта класса Lines, который называется grid.466
ГЛАВА 13 • ГРАФИЧЕСМ
int x size
int y_size
int x grid
int y__grid
win3.xmax(); // определяем размер нашего окна
win3.y_max();
80;
40;
Lines grid;
for (int x=x_grid; x<x_size; x+=x__grid)
grid.add(Point(x,0),Point(x,y_size));
for (int у = y_grid; y<y_size; y+=y_grid)
grid, add (Point (0#y) , Point (x_size#y) ) ; // горизонтальна
// вертикальная
Обратите внимание на то, как мы определили размеры нашего окна <
функций xmax () и ymax (). Это первый пример, в котором мы Hanncaj
числяющий объект, подлежащий выводу на экран. Было бы невыносимо
ределять сетку, вводя именованные переменные для каждой линии, из к<
состоит. Данный фрагмент кода создает следующее окно.
'^^^МФШШШш
$^^&Ш|*:У^^^ - ■■ ■' :.: ■' -0@Й
■
.
а
i
ы*1
j '
't
Вернемся к классу Lines. Как реализованы функции-члены класса Li:
Lines выполняет только две операции. Функция add() просто добавл:
определенную паро i точек, к набору линий, которые будут выведены на:
void Lines.:add Point pi, Point p2)
{
Shape •add pi),
Shape-:add(p2 •
}
Да -вал фик тор shape:: необходим, поскольку в противном случа
а - Tpi вал бы выражение add(pl) как недопустимую попыт]
н ш add из класса Lines, а не из класса Shape13 4 КЛАСС COLOR
467
Функция draw_lines () рисует линии, определенные с помощью функции add ().
void Lines::draw_lines() const
{
if (color().visibility())
for (int i=l; i<number_of_points(); i+=2)
fl_line(point(i-1).x,point(i-1).yf
point(i).x,point(i).y);
}
Иначе говоря, функция Lines: :draw_lines О на каждом шаге цикла получает
две точки (начиная с точек 0 и 1) и рисует линию, соединяющую эти точки с помо-
щью библиотечной функции fl_draw(). Видимость (visibility)— это свойство
объекта класса Color (раздел 13.4), поэтому, прежде чем рисовать эти линии, мы
должны проверить, что они являются видимыми.
Как будет показано в главе 14, функция draw_lines() вызывается системой.
Мы не обязаны проверять, является ли количество точек четным, так как функция
add () класса Lines может добавлять только пары точек. Функции num-
ber_of_points () и point () определены в классе Shape (см. раздел 14.2), и их
смысл очевиден. Эти две функции обеспечивают доступ к точкам объекта класса
Shape только для чтения. Функция-член draw_lines() определена как const
(см. раздел 9.7.4), поскольку она не изменяет фигуру.
=2| Мы не предусмотрели в классе Lines конструктор, поскольку наша модель
=1 в исходном положении не имеет точек, которые затем добавляются с помо-
щью функции add (). Этот подход более гибкий, чем использование конструктора.
Мы могли бы предусмотреть конструкторы в простом классе (например, для одной,
двух или трех линий) и даже для произвольного количества линий, но это кажется
нам ненужным. Если сомневаетесь, не добавляйте функциональную возможность
в класс. Если обнаружится, что она нужна, вы всегда сможете включить ее позднее,
но удалить ее из кода будет намного труднее.
13.4. Класс Color
Color — это тип, описывающий цвет. Его можно использовать примерно так:
grid.set_color (Color: :red) ;
Эта инструкция окрашивает линии, определенные в объекте grid, в красный
цвет. В итоге получается следующее изображение.
Класс Color определяет понятие цвета и приписывает символические имена
нескольким наиболее распространенным цветам.
struct Color {
enum Color_type {
red=FL_RED,
blue=FL_BLUE,
green=FL_GREEN,468
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАСС**
red grid
f-TiPilX!
!1Ш""' "'*"
};
yellow=FL_YELLOW/
white=FL_WHITE,
black=FL_BLACK,
magenta=FL_MAGENTAf
cyan=FL_CYAN,
dark_red=FL_DARK_RED,
dark_green=FL_DARKj3REEN,
darky e 11 ow= FL_DARK_YELLOW,
dark_blue=FL_DARK_BLUE,
dark_magenta=FL_DARK_MAGENTA,
dark_cyan=FL_DARK_CYAN
{ )
enum Transparency { invisible = 0, visible=255 };
Color(Colortype cc) :c(FlColor(cc)), v (visible) { }
Color (Colortype cc. Transparency w) :c (FlColor (cc) ) , v(w)
Color(int cc) :c(Fl_Color(cc)), v(visible) { }
Color (Transparency w) :c (Fl_Color () ) , v(w) { } // цвет по
// умолчанию
int as_int() const { return c; }
char visibility() const { return v; }
void setvisibility (Transparency w) { v=w; }
private:
char v; видимый или невидимый
Fl Color с;
};13 5 КЛАСС LINE STYLE
469
Предназначение класса Color заключается в следующем.
• Скрыть реализацию цвета в классе Fl_Color из библиотеки FLTK.
• Задать константы, соответствующие разным цветам.
• Обеспечить простую реализацию прозрачности (видимый или невидимый).
Цвет можно выбрать следующим образом.
• Выбрать константу из списка, например Color:: darkjblue.
• Выбрать цвет из небольшой палитры, которую большинство программ выво-
дит на экран (им соответствуют значения в диапазоне от 0-255; например,
выражение Color (99) означает темно-зеленый цвет). Пример такой про-
граммы приведен в разделе 13.9.
• Выбрать значение в системе RGB (Red, Green, Blue— красный, зеленый,
синий), которую мы здесь обсуждать не будем. При необходимости читатели
сами в ней разберутся. В частности, можно просто ввести запрос "RGB color"
в поисковую веб-машину. Среди прочих вы получите ссылки www. hyper so-
lutions, org/rgb.html и www.pitt.edu/~nisg/cis/web/cgi/rgb.html.
См. также упр. 13 и 14.
Обратите внимание на конструкторы класса Color, позволяющие создавать
объекты как из объектов типа Color_type, так и из обычных чисел типа int.
Каждый конструктор инициализирует член с. Вы можете возразить, что переменная
с названа слишком коротко и непонятно, но, поскольку она используется в очень
небольшой части класса Color и не предназначена для широкого использования,
это не является недостатком. Мы поместили член с в закрытый раздел, чтобы защи-
тить его от непосредственного обращения пользователей. Для представления
члена с мы используем тип Fl_Color, определенный в библиотеке FLTK, который
хотели бы скрыть от пользователей. Однако очень часто этот тип интерпретируется
как целочисленное представление значения RGB (или другого значения), поэтому
на этот случай мы предусмотрели функцию ae_int (). Обратите внимание на то,
что функция as_int () является константной функцией-членом, поскольку она не
изменяет объект класса Color, который ее использует.
Прозрачность задается членом v, который может принимать значения Trans-
parency: :visible и Transparency::invisible, имеющие очевидный смысл.
Вы можете удивиться: зачем нужен "невидимый цвет". Оказывается, он может быть
очень полезен для того, чтобы скрыть часть фигуры на экране.
13.5. Класс Line_style
Нарисовав на экране несколько линий, мы можем различать их по цвету, стилю
или по обоим этим признакам. Стиль линии — это шаблон, задающий ее внешний
вид. Класс Line_style используется приблизительно так:470
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
grid.set_style(Line_style::dot);
Эта инструкция выводит на экран линии, заданные в объекте grid, как последо-
вательность точек, а не как сплошную линию.
red dotted grid
0(0)®
м! '
ч
• • ■ ■"■?
•*—*♦*»!
'* I
Л' 1"
■ ft * *A ■
V'
4--.
4
' У
#6
I - ! | - 1
—!-
I
HfH^W^r^v
Это сделает сетку немного тоньше, зато более незаметной. Настраивая ширину
(толщину) линий, можем придать сетке требуемый вид.
Класс Line_style выглядит так:
struct Line_style {
enum Line style type {
solid=FL SOLID,
dash=FL DASH,
dot=FL DOT,
dashdot=FL DASHDOT,
dashdotdot=FL DASHDOTDOT,
};
//
//
//
//
//
- - - -
- . - .
— . . — . *
Linestyle(Line_style_type ss) :s(ss), w(0) { }
Linestyle (Linestyletype 1st, int ww) :s(lst), w(ww) { }
Linestyle(int ss) :s(ss), w(0) { }
int width() const { return w; }
int style() const { return s; }
private:
int s;
int w
};
Методы п огра мирования, использованные для определения класса Line_etyl*>
н чем не от л чаются от методов, использованных для класса Color. Здесь мы снова
кр вае 1 т т акт что для представления стилей линии библиотека FKTK использует
1 m П че 1 т -рь вать эту информацию? Потому что эти способы представ-ч3 5 КЛАСС LINE_STYLE
471
ления при модификации библиотеки могут измениться. В следующей версии библио-
теки FLTK может появиться тип Fllinestyle, да и мы сами можем перенастроить
наш интерфейс на другую библиотеку. В любом случае не стоит замусоривать свой
код переменными типа int только потому, что мы знаем, как они задают стиль линий.
Как правило, мы не заботимся о стиле вообще; мы просто полагаемся на па-
раметры, заданные по умолчанию (сплошные линии, ширина которых задана
по умолчанию). Если мы не указываем ширину линии явно, то она задается конст-
руктором. Установка значений по умолчанию — это одно из предназначений конст-
руктора, а правильно выбранные значения, задаваемые по умолчанию, могут значи-
тельно облегчить работу пользователей.
Класс Linestyle состоит из двух "компонентов": характеристики стиля
(например, пунктирные или сплошные линии) и ширины (толщина линий). Ширина
измеряется в целых числах. По умолчанию ширина равна единице. Если нам нужна
более широкая линия, то ее толщину можно задать следующим образом:
grid.set_style(Linestyle(Line_style::dash,2)) ;
В итоге получим следующее изображение:
:
fat dashed red grid #
i
i
т ~~
<—'—~"
i
i
■ р - --"
_„:
-_ __ _ (■—- — -
•
- — •» *»-.—
•
«
•
t
i
i
i
i
i
i
i
i
t
г
i
i
i
г
1
1
—
J
-r
1
1
t
$;k?^f :*^;У;%£?^^'г\\'*'■■-■
- 4-—-
_, f—,-_
•
_-..______....,...„_
i
i
i
C&A\'^
r
i
*
*,.
i
1 '
<
i
i
•
»
—r-*-
1
1
1
1
%
._}.—*
1
—K—
1
1
•
i
•
i 1 -I
apfa
~ffetf 1
ill
« i t
X \ l
. щшн — m **j* •* -.*»**** ~<h J*~ f**K~ «f» *r »*»»* «• Jit «^ -»
1 t 1
1 t t
I » 1
1 1 f
i 1 » ,
1 i l
1 » t
1 * «
1 t i
1 1 t
1 1
1 t
t i
i i
t
i-w^»*^.» *«—*«,■» —•» — ^Wff«*4^"**^«M«
III
i t i
• i i
Ht» «**«р«*4ч»й*^.^»«ч*-*«*ч«#^»|да"
1 • 1
i i r l
» ...... ..i. i .. .
Обратите внимание на то, что цвет и стиль относятся ко всем линиям, образую-
щим фигуру. Это одно из преимуществ группирования нескольких линий в один
графический объект, например класса Lines, Open_polyline или Polygon. Если
мы хотим управлять цветом или стилем линий по отдельности, то их следует задать
как отдельные объекты класса Line. Рассмотрим пример.
horizontal.setcolor(Color::red);
vertical.setcolor(Color::green);
На экране откроется окно, приведенное ниже.472
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
two lines colored
■4 ". ;; ■' , '« ;' ' \f ' ' '<■'■/'.," - " ■ '■".'", V'''
• ; ,. ■' ., : - Ь "Kit f ,j . ,y ' ■ '•_ <•'..,, T ■ ■' ".
/ ■ -V -, й* f'V"1' '/■■h""-^"'w'i-''-J't>r''F , , * ■'■' -:,.' / л ■ ■' .
', .' ' * ' ■ , ' ■:■■■ , ' V ■ a • '■ .w, '■ ^ ■ j. .. . '. '
. ' •• ■/" ■ ■' . * ■ : ; •, ' '''• ■';" '■ ■' '
BE®
ЛавдаЯи^***
' ' ' S
13.6. Класс Open_polyline
Класс Open_polyline определяет фигуру, состоящую из ряда отрезков линий,
соединенных между собой и заданных последовательностью точек. Слово poly име-
ет греческое происхождение и означает "много", a polyline — это удобное имя для
фигуры, состоящей из многих линий. Рассмотрим пример.
Open_polyline opl;
opl.add(Point(100,100))
opl.add(Point(150f200))
opl.add(Point(250/250) )
opl.add(Point(300f200))
Орел р*1у!те^МШ^ 1Ш
-tnim"tTri.iii,i'13 7 КЛАСС CLOSED POLYLINE
473
Этот фрагмент кода создает фигуру, которую можно нарисовать, соединяя сле-
дующие точки.
В принципе Open_polyline — это выдуманное слово, которое мы позаимство-
вали из детской игры "Connect the Dots" ("Соедини точки").
Класс Open_polyline определен следующим образом:
struct Open_polyline : Shape { // открытая последовательность линий
void add(Point p) { Shape::add(p); }
};
Да-да, это все определение. В нем практически ничего нет, кроме указания име-
ни класса и того факта, что он является наследником класса Shape. Функция add ()
класса Openpolyline просто позволяет пользователям получить доступ к функции
add О из класса Shape (т.е. Shape: :add()). Нам даже не нужно определять функ-
цию draw lines (), так как класс Shape по умолчанию интерпретирует добавлен-
ные точки как последовательность линий, соединенных друг с другом.
13.7. Класс Closed_polyline
Класс Closed_polyline похож на класс Open_polyline, за исключением того,
что последняя точка соединяется с первой. Например, можно было бы создать объ-
ект класса Closed_polyline из тех же точек, из которых был построен объект
класса Open_polyline в разделе 13.6.
Closed_polyline cpl;
cpl.add(Point(100,100));
cpl.add(Point(150,200));
cpl.add(Point(250,250)) ;
cpl.add(Point(300,200));
Как и ожидалось, результат идентичен тому, что мы получили в разделе 13.6,
за исключением последнего отрезка.
Определение класса closed_polyline приведено ниже.
struct Closed_polyline : Open_polyline { // замкнутый ряд линий
void drawlinesO const;
};
void Closed_polyline::draw_lines() const
{
Open_polyline::draw_lines0; // сначала рисуем открытый ряд линий,
// затем рисуем замыкающую линию:
if (colorO .visibilityO)
flline(point(number_of_points()-1).x,
point (number_of_points 0-1) .y,
point(0).x,
point(0).y);*т*
ГЛАВА 13 • I НАФИЧЫКИЬ КЛАССЫ
В классе Closed_polyline нужна отдельная функция draw_lines О, рисующая
замыкающую линию, которая соединяет последнюю точку с первой. К счастью,
для этого достаточно реализовать небольшую деталь, которая отличает класс
Closed_polyline от класса Shape. Этот важный прием иногда называют
"программированием различий" ("programming by difference"). Нам нужно запро-
граммировать лишь то, что отличает наш производный класс (Closed_polyline) от
базового (Open_polyline).
Итак, как же нарисовать замыкающую линию? Воспользуемся функцией
fl_line() из библиотеки FLTK. Она получает четыре аргументы типа int, задаю-
щих четыре точки. И здесь нам снова понадобится графическая библиотека. Однако
обратите внимание на то, что, как и во многих других ситуациях, упоминание биб-
лиотеки FLTK скрыто от пользователей. В программе пользователя нет никаких
ссылок на функцию fi_iine(), и ей неизвестно ничего о неявном представлении
точек в виде пар целых чисел. При необходимости мы могли бы заменить библио-
теку FLTK другой библиотекой графического пользовательского интерфейса,
а пользователи этого почти не заметили бы.
13.8. Класс Polygon
Класс Polygon очень похож на класс ciosed_polyline. Единственная разница
состоит в том, что в классе Polygon линии не могут пересекаться. Например, объект
класса ciosed_poiyiine, изображенный выше, был многоугольником, но если к не-
му добавить еще одну точку, то ситуация изменится.
cpl.add(Point(100,250));
Результат из бражен ниже.13 8 КЛАСС POLYGON
475
В соответствии с классическими определениями объект класса closed_polyline
многоугольником не является. Как определить класс Polygon так, чтобы он правиль-
но отображал связь с классом ciosed_polyline, не нарушая правил геометрии? Под-
сказка содержится в предыдущем описании. Класс Polygon— это класс Closed_
polyline, в котором линии не пересекаются. Иначе говоря, мы могли бы подчерк-
нуть способ образования фигуры из точек и сказать, что класс Polygon —
это класс Closed_polyline, в который невозможно добавить объект класса Point,
определяющий отрезок линии, пересекающийся с одной из существующих линий
в объекте класса Polygon.
Эта идея позволяет описать класс Polygon следующим образом:
struct Polygon : Closed_polyline { // замкнутая последовательность
// непересекающихся линий
void add(Point p);
void draw_lines() const;
};
void Polygon::add(Point p)
{
// проверка того, что новая линия не пересекает существующие
Shape::add(p);
}
Здесь мы унаследовали определение функции drawlines () из класса Closed_
polyline, сэкономив усилия и избежав дублирования кода. К сожалению, мы
должны проверить каждый вызов функции add (). Это приводит нас к неэффектив-
ному алгоритму, сложность которого оценивается как N в квадрате, — определение
объекта класса Polygon, состоящего из TV точек, требует N*(N-l)/2 вызовов функ-
ции intersect (). По существу, мы сделали предположение, что класс Polygon
будет использоваться для создания многоугольников с меньшим количеством точек.ито глава W • ГРА6ИЧЕСКИЕ Массы
Например, для того чтобы создать объект класса Polygon, состоящего из 24 точек,
потребуется 24*(24-1)/2 = 276 вызовов функции intersect О. Вероятно, это допус-
тимо, но если бы мы захотели создать многоугольник, состоящий из 2000 точек,
то вынуждены были бы сделать около 2 000 000 вызовов. Мы должны поискать более
эффективный алгоритм, который может вынудить нас модифицировать интерфейс.
В любом случае можем создать следующий многоугольник:
Polygon poly;
poly.add(Point(100,100));
poly.add(Point(150,200));
poly.add(Point(250f250));
poly.add(Point(300,200));
Очевидно, что этот фрагмент создает объект класса Polygon, идентичный
(вплоть до последнего пикселя) исходному объекту класса Closed_polyline:
Проверка того, что объект класса Polygon действительно представляет собой
многоугольник, оказывается на удивление запутанным. Проверка пересечений,
которая реализована в функции Polygon:: add О, является наиболее сложной
во всей графической библиотеке. Если вас интересуют кропотливые геометрические
манипуляции с координатами, взгляните на код. И это еще не все. Посмотрим, что
произойдет, когда мы попытаемся создать объект класса Polygon лишь из двух то-
чек. Лучше предусмотреть защиту от таких попыток.
void Polygon::draw_lines() const
{
if (number_of_points() < 3)
error("меньше трех точек вводить нельзя");
Closed_polyline::draw_lines();
}13 9 КЛАСС RECTANGLE 477
Проблема заключается в том, что инвариант класса Polygon — "точки обра-
зуют многоугольник" — невозможно проверить, пока не будут определены
все точки Иначе говоря, в соответствии с настоятельными рекомендациями мы
не задаем проверку инварианта в конструкторе класса Polygon. И все же "предуп-
реждение о трех точках" в классе Polygon: :draw_lines О — совершенно недо-
пустимый трюк. (См. также упр. 18.)
13.9. Класс Rectangle
Большинство фигур на экране являются прямоугольниками. Причина этого
явления объясняется частично культурными традициями (большинство дверей,
окон, картин, книжных шкафов, страниц и т.д. является прямоугольниками), а час-
тично техническими особенностями (задать координаты прямоугольника проще,
чем любой другой фигуры). В любом случае прямоугольник настолько широко рас-
пространен, что в системах графического пользовательского интерфейса он обраба-
тывается непосредственно, а не как многоугольник, имеющий четыре прямых угла.
struct Rectangle : Shape {
Rectangle(Point xy, int hh, int ww);
Rectangle(Point x, Point y);
void draw_lines() const;
int height() const { return h; }
int width() const { return w; }
private:
int h; // высота
int w; // ширина
};
Мы можем задать прямоугольник двумя точками (левой верхней и правой ниж-
ней) или одной точкой, шириной и высотой. Конструкторы этого класса могут
иметь следующий вид:
Rectangle::Rectangle(Point xy, int ww, int hh)
: w(ww), h(hh)
{
if (h<=0 || w<=0)
error("Ошибка: отрицательная величина");
add(xy);
}
Rectangle::Rectangle(Point x, Point y)
:w(y.x-x.x), h(y.y-x.y)
{
if (h<=0 || w<=0)
error("Ошибка: отрицательная ширина или длина");
add(x);
}478
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
Каждый конструктор соответствующим образом инициализирует члены h и w
(используя синтаксис списка инициализации; см. раздел 9.4.4) и хранит верхнюю
левую точку отдельно в базовом классе Shape (используя функцию add ()). Кроме
того, в конструкторах содержится проверка ширины и длины— они не должны
быть отрицательными.
Г7Г Одна из причин, по которым некоторые системы графики и графического
*—' пользовательского интерфейса рассматривают прямоугольники как отдельные
фигуры, заключается в том, что алгоритм определения того, какие пиксели попада-
ют внутрь прямоугольника, намного проще и, следовательно, быстрее, чем алгорит-
мы проверки для других фигур, таких как Polygon и Circle. По этой причине поня-
тие "заполнение цветом"— т.е. закраска пространства внутри прямоугольника —
чаще применяется по отношению к прямоугольникам, чем к другим фигурам.
Заполнение цветом можно реализовать в конструкторе или в виде отдельной
функции setfillcolorO (предусмотренной в классе Shape наряду с другими
средствами для работы с цветом).
Rectangle rectOO(Point(150,100),200,100) ;
Rectangle rectll(Point(50,50),Point(250,150)) ;
Rectangle recti2(Point(50,150),Point(250,250) ) ;
Rectangle rect21(Point(250,50),200,100) ;
Rectangle rect22(Point(250,150),200,100) ;
// ниже rectll
// правее rectll
// ниже rect21
rectOO.set_fill_color(Color::yellow);
rectll.set_fill_color(Color::blue);
rectl2.set_fill_color(Color::red);
rect21.set_fill_color(Color::green);
В итоге получаем следующее изображение:
rectangles
»1 J '.
*
fc*aw^rtfarM13 9 КЛАСС RECTANGLE
479
Если заполнение цветом не требуется, то прямоугольник считается прозрачным;
вот почему вы видите желтый угол объекта recto0.
Фигуры можно передвигать в окне (см. раздел 14.2.3). Рассмотрим пример.
rectll.move(400,0) ;
rectll.setfillcolor(Color::white);
winl2.set label("прямоугольники 2я);
// вправо от rect21
В итоге получим изображение, приведенное ниже.
')1^б(^ш-йШМШ^ШМШ.
4e«t
Заметьте, что только часть белого прямоугольника rectll помещается в окне.
То, что выходит за пределы окна, "отрезается"; иначе говоря, на экране эта часть
не отображается.
Г7Г Обратите внимание на то, как фигуры накладываются одна на другую. Это вы-
'—' глядит так, будто вы кладете на стол один лист бумаги на другой. Первый лист
окажется в самом низу. Наш класс Window (раздел Д.З) реализует простой способ
размещения фигуры поверх другой (используя функцию Window: :put_on_top()).
Рассмотрим пример.
winl2.putontop(rectOO);
winl2.setlabel("прямоугольники 3") ;
В итоге получаем следующее изображение:
Отметьте, что мы можем видеть линии, образующие прямоугольник, даже если
он закрашен. Если такое изображение нам не нравится, то линии можно удалить.
rectOO.setcolor(Color::invisible)
rectll.set_color(Color::invisible)
rectl2.setcolor(Color::invisible)
rect21.set_color(Color::invisible)
rect22.set color(Color::invisible)480
ГЛАВА 13 • ГРАФИЧЕСКИЕ КЛАССЫ
rectangles 3
Г** ..С* А?
ЖЕйЯ
" *SiI<*iS ■# SB/ 'J' fe «к Е ^>ЛУ "VV*1 vi
жшш! BMftSr
* * - - * ■- * -
ПН-'"
Это приводит к следующему результату:
Обратите внимание на то, что цвет заполнения и цвет линии заданы параметром
invisible, поэтому прямоугольник rect22 на экране больше не виден.
Поскольку мы должны работать как с цветом линии, так и с цветом заполнения,
функция-член draw_lines О класса Rectangle становится немного запутанной.
void Rectangle::draw_lines() const
{
if (fill_color() .visibility ()) { // заполнение
fl_color(fill_color() .asintO) ;
fl_rectf(point(0).x,point (0) .y,w,h) ;
}
rei^a^^^:^0^
[ГЦЙЖ1
LJOm.
■иду3 10 УПРАВЛЕНИЕ НЕИМЕНОВАННЫМИ ОБЪЕКТАМИ
481
if (color().visibilityО) { // линии поверх заполнения
fl_color(color().as_int());
flrect(point(0).x#point(0).y,w,h);
}
}
Как видим, библиотека FLTK содержит функции для рисования как заполненных
прямоугольников (f l_rectf О), так и пустых (f l_rect О). По умолчанию рисуют-
ся оба вида прямоугольников (пустой поверх заполненного).
13.10. Управление неименованными объектами
До сих пор мы именовали все наши графические объекты. Когда же объектов
много, то присваивать всем им имена становится нецелесообразно. В качестве при-
мера нарисуем простую цветную диаграмму, состоящую из 256 цветов, предусмот-
ренных в палитре библиотеки, иначе говоря, раскрасим 256 квадратов и нарисуем
их в матрице 16x16.
Вот что у нас получится.
Называть все эти 256 квадратов было бы не только утомительно, но и глупо.
Очевидно, что "имя" левого верхнего квадрата в матрице определяется его место-
положением в точке (0,0), а все остальные квадраты можно точно так же идентифи-
цировать с помощью пар координат (/, j ). Итак, нам необходим эквивалент матри-
цы объектов. Сначала мы подумали о векторе vector<Rectangle>, но оказалось,
что он недостаточно гибок. Например, было бы неплохо иметь коллекцию неимено-
ванных объектов (элементов), не все из которых имеют одинаковые типы. Пробле-
му гибкости мы обсудим в разделе 14.3, а здесь продемонстрируем наше решение:
векторный тип, хранящий именованные и неименованные объекты.